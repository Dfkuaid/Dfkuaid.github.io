<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello!</title>
    <url>/2021/09/18/hello-world/</url>
    <content><![CDATA[<p>Oh, this is my own blogs site.</p>
<span id="more"></span>
<p>Have a good time!</p>
<blockquote>
<p>本博客建于 2021.09.18 日，博主于 2019.11 起于 <a href="">博客园</a> 发布博文，目前仍有 70 余篇未搬来 QnQ</p>
</blockquote>
<blockquote class="blockquote-center">
<p>我们所过的每个平凡的日常，也许就是连续发生的奇迹。</p>
<p>—— 《日常》</p>

</blockquote>
]]></content>
  </entry>
  <entry>
    <title>「游记」THUPC2022 摸鱼记</title>
    <url>/2022/03/12/THUPC2022/</url>
    <content><![CDATA[<p>我菜死了，我就是傻逼。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>基础构造题题单</title>
    <url>/2022/03/09/%E5%9F%BA%E7%A1%80%E6%9E%84%E9%80%A0%E9%A2%98%E9%A2%98%E5%8D%95/</url>
    <content><![CDATA[<h2 id="accepted-atcoder_hitachi2020_c-three">[Accepted] ATcoder_hitachi2020_c ThREE</h2>
<blockquote>
<p><strong>考虑何时不合法</strong></p>
</blockquote>
<p>考虑什么时候构造出的方案不合法：存在距离为三的点模 <span class="math inline">\(3\)</span> 得到的结果都为 <span class="math inline">\(1\)</span> 或都为 <span class="math inline">\(2\)</span>。于是我们考虑怎么安排使得模三都为 <span class="math inline">\(1\)</span> 的点两两之间没有距离为 <span class="math inline">\(3\)</span> 的，模三都为 <span class="math inline">\(2\)</span> 的点两两之间没有距离为 <span class="math inline">\(3\)</span> 的。</p>
<p>于是考虑先将原树黑白染色，然后按照如下的方法进行构造：</p>
<ul>
<li>如果黑点的数量大于 <span class="math inline">\(\left\lfloor\frac n 3\right\rfloor\)</span> 个且白点的数量大于 <span class="math inline">\(\left\lfloor\frac n 3\right\rfloor\)</span> 个，那么可以直接将所有模 <span class="math inline">\(3\)</span> 同余 <span class="math inline">\(1\)</span> 的数填到黑点上，所有同余 <span class="math inline">\(2\)</span> 的数填到白点上，剩下的点都用同余 <span class="math inline">\(0\)</span> 的数填上，这样显然所有同余 <span class="math inline">\(1\)</span> 或所有同余 <span class="math inline">\(2\)</span> 的数两两之间的距离都是偶数，不可能出现距离为 <span class="math inline">\(3\)</span>.</li>
<li>若白点的数量小于 <span class="math inline">\(\left\lfloor\frac n 3\right\rfloor\)</span> 个，那么显然有黑点的数量大于等于 <span class="math inline">\(2\left\lfloor\frac n 3\right\rfloor\)</span>，于是我们可以直接让所有的模 <span class="math inline">\(3\)</span> 同余 <span class="math inline">\(1\)</span> 的数与同余 <span class="math inline">\(2\)</span> 的数都填到黑点上，剩下的点都用同余 <span class="math inline">\(0\)</span> 的数补齐。</li>
<li>若黑点的数量小于 <span class="math inline">\(\left\lfloor\frac n 3\right\rfloor\)</span> 个，与上一种情况基本一致。</li>
</ul>
<h2 id="accepted-cf1283f-diy-garland">[Accepted] CF1283F DIY Garland</h2>
<p>首先不难发现，给出的数列的第一个数一定是树的根。其次，给定的数列已经给出了原树中每一个点的儿子数，于是可以统计出哪些是叶子，然后考虑如何满足给定的边的大小的要求：可以从最小的边开始，将当前已经确定完子树的点中子树价值最小的与该点相连，得到一条边，如果一个点的儿子已经完全确定，那么就把他放到候选的序列中，「候选的序列」可以直接用 <code>priority_queue</code> 解决。显然这样构造一定可以满足要求的边权值大小顺序。</p>
<h2 id="acceptedpoi2011liz-lollipop">[Accepted]「POI2011」LIZ-Lollipop</h2>
<div style="width=10px;line_height: 1px;">
<a href=https://dfkuaid.github.io/2022/03/01/Luogu3514/ style="text-decoration:none;"> <font face="黑体" size=6> <b>「题解」Luogu3514 [POI2011]LIZ-Lollipop</b> </font> <font face="黑体" size=2> <br>  发表于 2022-03-01 Dfkuaid<br> </font> <font face="黑体" size=6> </font> <font face="FangSong" size=4> 摘要： Luogu3514 [POI2011]LIZ-Lollipop 题解 <br> </font>
<p align="right">
<font face="黑体" size=4> 阅读全文   <br> <u>   &gt;&gt;   </u>   <br> </font>
</p>
<p></a></p>
</div>
<hr />
<h2 id="accepted-luogu3599-koishi-loves-construction">[Accepted] Luogu3599 Koishi Loves Construction</h2>
<div style="width=10px;line_height: 1px;">
<a href=https://dfkuaid.github.io/2022/03/06/Luogu3599/ style="text-decoration:none;"> <font face="黑体" size=6> <b>「题解」Luogu3599 Koishi Loves Construction</b> </font> <font face="黑体" size=2> <br>  发表于 2022-03-06 Dfkuaid<br> </font> <font face="黑体" size=6> </font> <font face="FangSong" size=4> 摘要： Luogu3599 Koishi Loves Construction 题解 <br> </font>
<p align="right">
<font face="黑体" size=4> 阅读全文   <br> <u>   &gt;&gt;   </u>   <br> </font>
</p>
<p></a></p>
</div>
<hr />
<h2 id="accepted-cf1311e-construct-the-binary-tree">[Accepted] CF1311E Construct the Binary Tree</h2>
<blockquote>
<p><strong>最值分析</strong></p>
</blockquote>
<p>首先题目要求我们判断给出的数能否被构造，于是我们考虑找到一个节点数能构造的数的范围，即最大值与最小值。首先，比较显然的是最大值一定是一条链，而最小值一定是一棵完全二叉树。</p>
<p>找到了最值，接下来就考虑如何构造范围内的每一个值。</p>
<p>我们考虑从一棵完全二叉树逐渐向链进行过渡，于是不妨先建出一棵基础的完全二叉树：令 <span class="math inline">\(x\)</span> 的父节点为 <span class="math inline">\(\left\lfloor\frac n 2\right\rfloor\)</span>。然后选择一条最长的链，可以直接选择 <span class="math inline">\(1,2,2^2,2^3,\dots,2^t\)</span>，之后从大到小枚举每一个节点，显然我们将一个节点 <span class="math inline">\(x\)</span> 链到当前链底 <span class="math inline">\(y\)</span> 下面，可以使答案增大 <span class="math inline">\(d_y-d_x+1\)</span>（<span class="math inline">\(d_x\)</span> 表示 <span class="math inline">\(x\)</span> 的深度），假设当前剩余要补足的数 <span class="math inline">\(rest\)</span> 小于 <span class="math inline">\(d_y-d_x+1\)</span>，那么我们可以直接将这个节点挂在 <span class="math inline">\(y\)</span> 向上 <span class="math inline">\(|rest-(d_y-d_x+1)|\)</span> 层下，显然被挂的节点一定在链上，且仅有一个儿子，此时一定可以满足要求，时间复杂度为 <span class="math inline">\(O(n)\)</span>.</p>
<h2 id="accepted-arc103---distance-sums">[Accepted] ARC103 - Distance Sums</h2>
<blockquote>
<p><a href="https://atcoder.jp/contests/arc103/tasks/arc103_d">题目链接</a> | 明明就是 D 题却偏偏要标 F 的屑</p>
</blockquote>
<p>首先，不难注意到，给出的距离中的最小者一定是树的重心，最大者一定是树的某一个叶子。</p>
<p>同时，我们注意到，当选定此树的一个根之后，我们就可以由一个节点 <span class="math inline">\(u\)</span> 的 <span class="math inline">\(d\)</span> 推出他父亲 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(d\)</span>： <span class="math display">\[
d_v=d_u+size_u-(n-size_u)=d_u+2\cdot size_u-n,
\]</span> 从上式不难看出，一个节点的父亲的 <span class="math inline">\(d\)</span> 一定小于该节点，同样，根据上面这个式子，假如我们已经知道了一个节点的 <span class="math inline">\(size\)</span>，我们一定可以推出其父亲的 <span class="math inline">\(d\)</span>，由于题目规定了 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(d_i\)</span> 一一对应，于是我们可以尝试对此进行二分查找，假如不存在查询的 <span class="math inline">\(d\)</span>，那么显然不存在可行构造。这样，找到 <span class="math inline">\(x\)</span> 的父亲之后，就可以更新其父亲的 <span class="math inline">\(size\)</span>，逐步构建出整棵树。</p>
<p>在上面的过程中，我们只是得到了每一个节点到其父节点变化的 <span class="math inline">\(\Delta d\)</span>，并不知道构造出的树的节点的距离和是否满足要求，那么我们需要进行检查，同样根据递推式，只需要一个点满足，那么整棵树都满足。不妨直接选择重心，构建出的树到重心的距离和显然就是各子树大小的和。</p>
]]></content>
      <categories>
        <category>题单</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」Luogu3599 Koishi Loves Construction</title>
    <url>/2022/03/06/Luogu3599/</url>
    <content><![CDATA[<h2 id="题意简述">题意简述</h2>
<p>有两种询问：</p>
<ol type="1">
<li>对于正整数 <span class="math inline">\(n(n\leq10^5)\)</span>，判断是否存在一种 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的排列，使得 <span class="math inline">\(n\)</span> 个前缀和在模 <span class="math inline">\(n\)</span> 意义下各不相同；</li>
<li>对于正整数 <span class="math inline">\(n(n\leq10^5)\)</span>，判断是否存在一种 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的排列，使得 <span class="math inline">\(n\)</span> 个前缀积在模 <span class="math inline">\(n\)</span> 意义下各不相同；</li>
</ol>
<p>若不存在，输出 <code>0</code>，否则输出 <code>2</code>，并给出构造。</p>
<h2 id="思路">思路</h2>
<p>直接考虑如何何时存在及进行构造是没有头猪的，于是我们考虑先进行一个简单的暴力，尝试先找找可能的规律。</p>
<details class="note info no-icon"><summary><p>Brute-force Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, a[N], vis[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check_sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis); tmp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) &#123;</span><br><span class="line">        tmp[i] = tmp[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[tmp[i] % x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vis[tmp[i] % x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check_mul</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis); tmp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) &#123;</span><br><span class="line">        tmp[i] = tmp[i - <span class="number">1</span>] * a[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[tmp[i] % x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vis[tmp[i] % x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) a[i] = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOW: %d\n&quot;</span>, x); <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_sum</span>(x)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  SUM: YES\n    &quot;</span>); flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]); <span class="built_in">printf</span>(<span class="string">&quot;\n    &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tmp[i]); <span class="built_in">printf</span>(<span class="string">&quot;\n    &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tmp[i] % x); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a + <span class="number">1</span>, a + x + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="built_in">puts</span>(<span class="string">&quot;  SUM: NO&quot;</span>); flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) a[i] = i;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_mul</span>(x)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  MUL: YES\n    &quot;</span>); flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]); <span class="built_in">printf</span>(<span class="string">&quot;\n    &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tmp[i]); <span class="built_in">printf</span>(<span class="string">&quot;\n    &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tmp[i] % x); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a + <span class="number">1</span>, a + x + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="built_in">puts</span>(<span class="string">&quot;  MUL: NO&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;brute.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">read</span>(T); <span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">while</span> (++ i &lt;= T) <span class="built_in">solve</span>(i); <span class="keyword">return</span> (<span class="number">0</span> - <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>
<details class="note info no-icon"><summary><p>brute.txt</p>
</summary>
<p><code>...</code> 表示对于大量无用信息的省略。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">NOW: 1</span><br><span class="line"><span class="code">  SUM: YES</span></span><br><span class="line"><span class="code">    1 </span></span><br><span class="line"><span class="code">    1 </span></span><br><span class="line"><span class="code">    0 </span></span><br><span class="line"><span class="code">  MUL: YES</span></span><br><span class="line"><span class="code">    1 </span></span><br><span class="line"><span class="code">    1 </span></span><br><span class="line"><span class="section">    0 </span></span><br><span class="line"><span class="section">--------------------------</span></span><br><span class="line">NOW: 2</span><br><span class="line"><span class="code">  SUM: YES</span></span><br><span class="line"><span class="code">    2 1 </span></span><br><span class="line"><span class="code">    2 3 </span></span><br><span class="line"><span class="code">    0 1 </span></span><br><span class="line"><span class="code">  MUL: YES</span></span><br><span class="line"><span class="code">    1 2 </span></span><br><span class="line"><span class="code">    1 2 </span></span><br><span class="line"><span class="section">    1 0 </span></span><br><span class="line"><span class="section">--------------------------</span></span><br><span class="line">NOW: 3</span><br><span class="line"><span class="code">  SUM: NO</span></span><br><span class="line"><span class="code">  MUL: YES</span></span><br><span class="line"><span class="code">    1 2 3 </span></span><br><span class="line"><span class="code">    1 2 6 </span></span><br><span class="line"><span class="section">    1 2 0 </span></span><br><span class="line"><span class="section">--------------------------</span></span><br><span class="line">NOW: 4</span><br><span class="line"><span class="code">  SUM: YES</span></span><br><span class="line"><span class="code">    4 1 2 3 </span></span><br><span class="line"><span class="code">    4 5 7 10 </span></span><br><span class="line"><span class="code">    0 1 3 2 </span></span><br><span class="line"><span class="code">  SUM: YES</span></span><br><span class="line"><span class="code">    4 3 2 1 </span></span><br><span class="line"><span class="code">    4 7 9 10 </span></span><br><span class="line"><span class="code">    0 3 1 2 </span></span><br><span class="line"><span class="code">  MUL: YES</span></span><br><span class="line"><span class="code">    1 3 2 4 </span></span><br><span class="line"><span class="code">    1 3 6 24 </span></span><br><span class="line"><span class="section">    1 3 2 0 </span></span><br><span class="line"><span class="section">--------------------------</span></span><br><span class="line">NOW: 5</span><br><span class="line"><span class="code">  SUM: NO</span></span><br><span class="line"><span class="code">  MUL: YES</span></span><br><span class="line"><span class="code">    1 2 4 3 5 </span></span><br><span class="line"><span class="code">    1 2 8 24 120 </span></span><br><span class="line"><span class="code">    1 2 3 4 0 </span></span><br><span class="line"><span class="code">  MUL: YES</span></span><br><span class="line"><span class="code">    1 3 4 2 5 </span></span><br><span class="line"><span class="code">    1 3 12 24 120 </span></span><br><span class="line"><span class="section">    1 3 2 4 0 </span></span><br><span class="line"><span class="section">--------------------------</span></span><br><span class="line">NOW: 6</span><br><span class="line"><span class="code">  SUM: YES</span></span><br><span class="line"><span class="code">    6 1 4 3 2 5 </span></span><br><span class="line"><span class="code">    6 7 11 14 16 21 </span></span><br><span class="line"><span class="code">    0 1 5 2 4 3 </span></span><br><span class="line"><span class="code">  ...</span></span><br><span class="line"><span class="code">  SUM: YES</span></span><br><span class="line"><span class="code">    6 5 2 3 4 1 </span></span><br><span class="line"><span class="code">    6 11 13 16 20 21 </span></span><br><span class="line"><span class="code">    0 5 1 4 2 3 </span></span><br><span class="line"><span class="section">  MUL: NO</span></span><br><span class="line"><span class="section">--------------------------</span></span><br><span class="line">NOW: 7</span><br><span class="line"><span class="code">  SUM: NO</span></span><br><span class="line"><span class="code">  MUL: YES</span></span><br><span class="line"><span class="code">    1 2 5 6 3 4 7 </span></span><br><span class="line"><span class="code">    1 2 10 60 180 720 5040 </span></span><br><span class="line"><span class="code">    1 2 3 4 5 6 0 </span></span><br><span class="line"><span class="section">  ...</span></span><br><span class="line"><span class="section">--------------------------</span></span><br><span class="line">NOW: 8</span><br><span class="line"><span class="code">  SUM: YES</span></span><br><span class="line"><span class="code">    8 1 2 3 4 5 6 7 </span></span><br><span class="line"><span class="code">    8 9 11 14 18 23 29 36 </span></span><br><span class="line"><span class="code">    0 1 3 6 2 7 5 4 </span></span><br><span class="line"><span class="code">  ...</span></span><br><span class="line"><span class="code">  SUM: YES</span></span><br><span class="line"><span class="code">    8 7 2 5 4 3 6 1 </span></span><br><span class="line"><span class="code">    8 15 17 22 26 29 35 36 </span></span><br><span class="line"><span class="code">    0 7 1 6 2 5 3 4 </span></span><br><span class="line"><span class="code">  ...</span></span><br><span class="line"><span class="section">  MUL: NO</span></span><br><span class="line"><span class="section">--------------------------</span></span><br><span class="line">NOW: 9</span><br><span class="line"><span class="code">  SUM: NO</span></span><br><span class="line"><span class="section">  MUL: NO</span></span><br><span class="line"><span class="section">--------------------------</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>
<h3 id="task-1">Task 1</h3>
<p>通过上面的暴力枚举，我们似乎可以找到以下<strong>可能的</strong>性质：</p>
<ol type="1">
<li><p>奇数除了 <span class="math inline">\(1\)</span> 以外一定不存在合法的构造；</p></li>
<li><p>偶数一定存在合法的构造方案，为</p>
<p><span class="math display">\[
 a_1=n, a_2=n-1,a_{2i + 1}=2i,a_{2i+2}=n-1-2i,i\in[1,\frac n 2-1].
 \]</span></p></li>
</ol>
<p>再来看现在我们已经可以得到的结论：</p>
<ul>
<li>若 <span class="math inline">\(a_i=n\)</span>，则一定有 <span class="math inline">\(i=1\)</span>，否则有 <span class="math inline">\(sum_i\equiv sum_{i-1}(\bmod n).\)</span></li>
</ul>
<p>我们考虑对于发现的可能的性质进行证明，有</p>
<ol type="1">
<li><p>若 <span class="math inline">\(n\in odd\)</span> 且 <span class="math inline">\(n\ne 1\)</span>，那么 <span class="math display">\[
\sum_{i=1}^{n-1}i=\frac{(1+n-1)\cdot(n-1)}{2}=n\cdot\frac{n-1}{2}\equiv0(\bmod n)
\]</span> 此时 <span class="math inline">\(sum_n\equiv sum_1(\bmod n)\)</span>，不合法，于是 <span class="math inline">\(1\)</span> 以外的奇数一定不存在合法构造。</p></li>
<li><p>显然 <span class="math inline">\(\{a_i\}\)</span> 是一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的排列，于是我们关注在模意义下的前缀和，应当有 <span class="math display">\[
sum_{2i+1}\equiv i(\bmod n),sum_{2i+2}\equiv n-1-i(\bmod n),i\in[0,\frac n 2 -1].
\]</span> 证明：</p>
<p>采用归纳法进行证明。当 <span class="math inline">\(i=0\)</span> 时，显然成立。</p>
<p>当 <span class="math inline">\(i&gt;1\)</span> 时，有 <span class="math display">\[
\begin{aligned}
&amp;sum_{2i+1}=sum_{2(i-1)+2}+a_{2i+1}\equiv n-1-(i-1)+2i\equiv i(\bmod n),\\
&amp;sum_{2i+2}=sum_{2i+1}+a_{2i+2}\equiv i+n-1-2i\equiv n-1-i(\bmod n),
\end{aligned}
\]</span> 于是假设成立。且显然得到的前缀和在模意义下各不相同。</p></li>
</ol>
<p>综上，我们就得到了 task 1 的构造方案。</p>
<h3 id="task-2">Task 2</h3>
<p>首先来看我们已经掌握了哪些信息：</p>
<ul>
<li>一定有 <span class="math inline">\(a_1=1,a_n=n\)</span>，易证。</li>
<li>合法的序列一定不存在区间 <span class="math inline">\([\ell, r]\)</span>，使得 <span class="math inline">\(n|\prod_{i=\ell}^ra_i\)</span>.</li>
</ul>
<p>观察我们暴力得到的数据及样例，可以发现，似乎所有的质数都存在合法构造，非质数中 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(4\)</span> 存在合法构造，我们尝试证明大于 <span class="math inline">\(4\)</span> 的所有非质数不存在合法构造。</p>
<p>有 <span class="math inline">\(n=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}\)</span>，如果得到的排列合法，一定满足 <span class="math display">\[
\exists i\in[1,k],\left\lfloor\frac{n-1}{p_i}\right\rfloor&lt;\alpha_i.
\]</span> 即 <span class="math display">\[
\exists i\in[1,k],n-1&lt;\alpha_ip_i.
\]</span> 即 <span class="math display">\[
\exists i\in[1,k],t\cdot p_i^{\alpha_i}-1&lt;\alpha_ip_i,t\in\mathbb Z,t\geq1.
\]</span> 那么有 <span class="math display">\[
\begin{aligned}
t\cdot p_i^{\alpha_i}-1&lt;\alpha_ip_i\\
t&lt;\frac{\alpha_ip_i+1}{p_i^{\alpha_i}}
\end{aligned}
\]</span> 下图是 <span class="math inline">\(p_i=2\)</span> 时的 <span class="math inline">\(\frac{\alpha_ip_i+1}{p_i^{\alpha_i}}\)</span> 的图像，显然永远有 <span class="math inline">\(t&lt;2\)</span>.</p>
<figure>
<img src="https://s2.loli.net/2022/03/06/pr5IebK2nVGUEkP.png" alt="p_equal_2.png" /><figcaption aria-hidden="true">p_equal_2.png</figcaption>
</figure>
<p>那么，当 <span class="math inline">\(p_i\)</span> 变大时，有</p>
<iframe src="https://www.desmos.com/calculator/nrupmrclp9?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder="0">
</iframe>
<p>显然当 <span class="math inline">\(\alpha_i\geq1\)</span> 时，恒有 <span class="math inline">\(t&lt;2\)</span>，于是显然有 <span class="math inline">\(k=1\)</span>，即 <span class="math inline">\(n\)</span> 仅有一个质因数。</p>
<p>于是假设 <span class="math inline">\(n=p^{\alpha}\)</span>，如果排列合法，应当有 <span class="math display">\[
\frac{\alpha\cdot p+1}{p^{\alpha}}&gt;1
\]</span> 当 <span class="math inline">\(\alpha\geq 2\)</span> 时，当且仅当 <span class="math inline">\(p=2,\alpha=2\)</span> 时上式成立。于是显然只有质数与 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(4\)</span> 存在合法构造。</p>
<p>继续观察暴力所得的数据，注意到，似乎质数都存在一种构造方式，使得前缀积满足 <span class="math inline">\(mul_i\equiv i(\bmod n).\)</span></p>
<p>即满足 <span class="math display">\[
mul_i\cdot a_{i+1}\equiv mul_{i+1}(\bmod n),
\]</span> 换句话讲，如果我们将所求数列扩展到 <span class="math inline">\(\mathbb R\)</span>，那么构造的数列可以是 <span class="math inline">\(1,\frac 2 1,\frac 3 2,\dots,\frac n{n-1}\)</span>，那么，如果我们将上面的实数数列依次取逆元，那么就可以得到一个整数数列，下面证明这个整数数列两两不相同。</p>
<p>证明：</p>
<p>设存在 <span class="math inline">\(a_x=a_y=k(x&lt;y)\)</span>，根据该数列性质，有 <span class="math display">\[
\begin{aligned}
k\cdot(x-1)\equiv x(\bmod n),\\
k\cdot(y-1)\equiv y(\bmod n),\\
\end{aligned}
\]</span> 于是有 <span class="math display">\[
k\cdot(y - x)\equiv y-x(\bmod n),
\]</span> 于是有 <span class="math display">\[
k\equiv1(\bmod n),
\]</span> 那么就有 <span class="math display">\[
\begin{aligned}
x-1\equiv x(\bmod n),\\
y-1\equiv y(\bmod n),\\
\end{aligned}
\]</span> 显然不成立，于是假设不成立，故 <span class="math inline">\(\{a_i\}\)</span> 两两不同。</p>
<p>于是我们就得到了一个可行的构造方案。</p>
<details class="note info no-icon"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, t, n, prm[N], nprm[N], pcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nprm[i]) prm[++ pcnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= pcnt; ++ p)</span><br><span class="line">          <span class="keyword">if</span> (prm[p] * i &lt;= x) &#123;  </span><br><span class="line">              nprm[prm[p] * i] = <span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">if</span> (i &amp; prm[p] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * x % n;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>; x = <span class="number">1ll</span> * x * x % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;<span class="built_in">puts</span>(<span class="string">&quot;2 1&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 %d %d &quot;</span>, n, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span> - <span class="number">1</span>; ++ i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d %d &quot;</span>, i &lt;&lt; <span class="number">1</span>, n - <span class="number">1</span> - (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;<span class="built_in">puts</span>(<span class="string">&quot;2 1&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">4</span>) &#123;<span class="built_in">puts</span>(<span class="string">&quot;2 1 3 2 4&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (nprm[n]) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 &quot;</span>); <span class="keyword">int</span> now = <span class="number">1</span>, mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, now);</span><br><span class="line">        now = <span class="number">1ll</span> * (i + <span class="number">1</span>) * <span class="built_in">fpow</span>(mul, n - <span class="number">2</span>) % n;</span><br><span class="line">        mul = <span class="number">1ll</span> * mul * now % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x), <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">while</span> (t --) <span class="built_in">task1</span>();</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">euler</span>(<span class="number">1e5</span>); <span class="keyword">while</span> (t --) <span class="built_in">task2</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> - <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>
<h2 id="总结">总结</h2>
<p>乍一看没有思路的构造题，考虑先暴力找到可行解，再寻找可能存在的规律，然后尝试证明。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」Luogu3514 [POI2011]LIZ-Lollipop</title>
    <url>/2022/03/01/Luogu3514/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3514">Luogu3514 [POI2011]LIZ-Lollipop</a></p>
</blockquote>
<h2 id="题意简述">#题意简述</h2>
<p>给定一个长度为 <span class="math inline">\(n(n\leq10^6)\)</span> 的仅由 <span class="math inline">\(1,2\)</span> 组成的序列，<span class="math inline">\(q(q\leq10^6)\)</span> 次询问，每次询问是否存在一个子串使得子串和为 <span class="math inline">\(k\)</span>，不存在输出 <code>NIE</code>，否则输出任意一个可行的区间左右端点。</p>
<h2 id="大致思路">#大致思路</h2>
<p>首先，观察到询问次数较多，需要考虑将所有可能组成的值的区间全部处理出来，由于所有可能的值的数量较大，于是需要考虑通过寻找所有可能的值的区间之间的关系进行递推。</p>
<p>假设我们已知 <span class="math inline">\(k\)</span> 的表示区间，考虑将该区间进行微量的改动可能造成的影响。考虑到添加只是删除操作的逆操作，且需要考虑的边界问题较少，于是这里讨论删除操作。假设当前边界两端都是 <span class="math inline">\(1\)</span>，显然可以得到 <span class="math inline">\(k-1\)</span> 和 <span class="math inline">\(k-2\)</span> 的区间；假设当前边界的两端为 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(2\)</span>，那么可以得到 <span class="math inline">\(k-1\)</span> 和 <span class="math inline">\(k-2\)</span> 的区间；如果两边都是 <span class="math inline">\(2\)</span>，那么只能得到 <span class="math inline">\(k-2\)</span> 的区间。</p>
<p>综上，我们发现，如果 <span class="math inline">\(k(k&gt;2)\)</span> 能够被组成，那么 <span class="math inline">\(k - 2\)</span> 一定可以被组成，只需要删除至多两个位置即可。</p>
<p>于是，我们只需要找到最大的可表示的奇数与最大的可表示的偶数即可，显然是一个前缀或后缀的形式。</p>
<details class="note info no-icon"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, sum[N], a[N], mx[<span class="number">2</span>], l[N], r[N]; <span class="keyword">char</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lp, <span class="keyword">int</span> rp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mx[x &amp; <span class="number">1</span>] &lt; x) mx[x &amp; <span class="number">1</span>] = x, l[x] = lp, r[x] = rp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_pos</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[l[x + <span class="number">2</span>]] == <span class="number">1</span> &amp;&amp; a[r[x + <span class="number">2</span>]] == <span class="number">1</span>)</span><br><span class="line">      l[x] = l[x + <span class="number">2</span>] + <span class="number">1</span>, r[x] = r[x + <span class="number">2</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[l[x + <span class="number">2</span>]] == <span class="number">2</span>)</span><br><span class="line">      l[x] = l[x + <span class="number">2</span>] + <span class="number">1</span>, r[x] = r[x + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">else</span> l[x] = l[x + <span class="number">2</span>], r[x] = r[x + <span class="number">2</span>] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(q); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = c[i] == <span class="string">&#x27;T&#x27;</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; -- i) <span class="built_in">update</span>(sum[i], <span class="number">1</span>, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">update</span>(sum[n] - sum[i - <span class="number">1</span>], i, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mx[<span class="number">1</span>] - <span class="number">2</span>; i &gt; <span class="number">0</span>; i -= <span class="number">2</span>) <span class="built_in">get_pos</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mx[<span class="number">0</span>] - <span class="number">2</span>; i &gt; <span class="number">0</span>; i -= <span class="number">2</span>) <span class="built_in">get_pos</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>; <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; mx[x &amp; <span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">&quot;NIE\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, l[x], r[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> - <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>势能分析法</title>
    <url>/2022/02/07/potential-method/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<h3 id="大致思想">大致思想</h3>
<p>势能法摊借用了物理学中的概念，还分析将数据结构中的预付代价表示为“势能”，将积攒的势能释放可以支付未来操作的代价，将势能与整个数据结构相关联。</p>
<h3 id="定义">定义</h3>
<p>对于一个初始数据结构 <span class="math inline">\(D_0\)</span>，我们将执行 <span class="math inline">\(n\)</span> 个操作，<span class="math inline">\(\forall i\in[1,n]\)</span>，定义 <span class="math inline">\(c_i\)</span> 表示此次操作所花费的实际代价，<span class="math inline">\(D_i\)</span> 表示在 <span class="math inline">\(D_{i-1}\)</span> 的基础上执行第 <span class="math inline">\(i\)</span> 个操作后的结果数据结构。定义<strong>势函数</strong> <span class="math inline">\(\Phi\)</span> 将每个数据结构 <span class="math inline">\(D_i\)</span> 映射到一个实数 <span class="math inline">\(\Phi(D_i)\)</span>，表示数据结构 <span class="math inline">\(D_i\)</span> 的势能。第 <span class="math inline">\(i\)</span> 个操作的摊还代价 <span class="math inline">\(\hat c_i\)</span> 用势函数 <span class="math inline">\(\Phi\)</span> 定义为： <span class="math display">\[
\hat c_i=c_i+\Phi(D_i)-\Phi(D_{i-1}),
\]</span> 于是，<span class="math inline">\(n\)</span> 个操作的总摊还代价为 <span class="math display">\[
\sum\limits_{i=1}^n\hat c_i=\sum\limits_{i=1}^n(c_i+\Phi(D_i)-\Phi(D_{i-1}))=\sum\limits_{i=1}^nc_i+\Phi(D_n)-\Phi(D_0).
\]</span> 此时，如果能定义一个势函数 <span class="math inline">\(\Phi\)</span>，使得 <span class="math inline">\(\Phi(D_n)\geq\Phi(D_0)\)</span>，那么显然此时总摊还代价 <span class="math inline">\(\sum\limits_{i=1}^n\hat c_i\)</span> 就是总实际代价的一个上界。</p>
<h3 id="简单理解">简单理解</h3>
<p>可以有这样一种简单的理解方式：对于 <span class="math inline">\(\Phi(D_i)-\Phi(D_{i-1})&gt;0\)</span>，这时这个操作正在花费额外的代价积累势能，反之，若 <span class="math inline">\(\Phi(D_i)-\Phi(D_{i-1})&lt;0\)</span> 则意味着正在消耗之前积累的势能进行操作，免去了一些代价。</p>
<p>在算法、数据结构的实际使用过程中，我们并不总能知道我们要进行多少个操作，于是，如果我们能够保证有 <span class="math inline">\(\forall i,\Phi(D_i)\geq\Phi(D_0)\)</span>，就能保证不论多少个操作，最终得到的总摊还代价总是总实际代价的一个上界，也就是保证了所有消耗势能的操作所消耗的势能都已经在其之前通过某些操作被积累。</p>
<p>显然此时得到的摊还代价取决于我们定义的势函数，但是不论采用的势函数是怎样的，得到的摊还代价总是实际代价的一个上界。在选择势函数时，我们需要考虑我们需要怎样的时间界。</p>
<h2 id="例题">例题</h2>
<h3 id="栈问题">栈问题</h3>
<p>栈有 <span class="math inline">\(\text{POP}\)</span>、<span class="math inline">\(\text{PUSH}\)</span> 和 <span class="math inline">\(\text{MULTIPOP}\)</span> 三种操作，分别是弹出栈顶，压入栈，批量弹出。压入、弹出单个元素的单次时间复杂度为 <span class="math inline">\(O(1)\)</span>，我们假定其为 <span class="math inline">\(1\)</span>。我们将栈的势函数定义为在其中的元素数量，对于初始的空栈，有 <span class="math inline">\(\Phi(D_0)=0\)</span>，显然栈中元素的个数不会少于 <span class="math inline">\(0\)</span> 个，于是必然有 <span class="math display">\[
\Phi(D_i)\geq0=\Phi(D_0),
\]</span> 于是，我们此时用 <span class="math inline">\(\Phi\)</span> 定义的总摊还代价是总实际代价的一个上界。我们下面对栈的三个操作分别进行摊还代价分析。</p>
<p>假设第 <span class="math inline">\(i\)</span> 个操作是 <span class="math inline">\(\text{PUSH}\)</span>，有 <span class="math display">\[
\hat c_i=c_i+\Phi(D_i)-\Phi(D_{i-1})=1+1=2,
\]</span> 假设第 <span class="math inline">\(i\)</span> 个操作是 <span class="math inline">\(\text{POP}\)</span>，有 <span class="math display">\[
\hat c_i=c_i+\Phi(D_i)-\Phi(D_{i-1})=1-1=0,
\]</span> 假设第 <span class="math inline">\(i\)</span> 个操作是 <span class="math inline">\(\text{MULTIPOP}(k)\)</span>，此时栈中有 <span class="math inline">\(s\)</span> 个元素，那么将弹出 <span class="math inline">\(k&#39;=\min(k,s)\)</span> 个元素，于是有 <span class="math display">\[
\hat c_i=c_i+\Phi(D_i)-\Phi(D_{i-1})=k&#39;-k&#39;=0,
\]</span> 综上，每个操作的摊还代价都是 <span class="math inline">\(O(1)\)</span>，于是 <span class="math inline">\(n\)</span> 个操作的总摊还代价应当为 <span class="math inline">\(O(n)\)</span>，此时是总实际代价的上界，于是最坏情况下的总实际代价为 <span class="math inline">\(O(n)\)</span>.</p>
<h3 id="动态扩增数组问题">动态扩增数组问题</h3>
<blockquote>
<p>给定一个数组，其初始大小为 <span class="math inline">\(0\)</span>，支持在数组末尾加入一个元素；如果当前大小为 <span class="math inline">\(0\)</span>，则先开 <span class="math inline">\(1\)</span> 的空间，如果数组元素已满，则先将数组的大小翻倍再插入，开单个空间和插入一个元素的时间视为 <span class="math inline">\(1\)</span>。求操作的平摊复杂度。</p>
</blockquote>
<p>容易发现，造成复杂度分析困难的一步是开新空间时的时间复杂度，开新数组时的耗时巨大，但实际进行的操作次数并不多，于是我们希望这一步在分析时能够采用积累的势能进行，也就是说，我们希望这是一个消耗势能的操作。</p>
<p>于是我们希望定义的势函数能够使得当前处于已满状态的数组的势能最大，为数组的规模，在刚新开完空间后的势能为 <span class="math inline">\(0\)</span>，我们这样定义 <span class="math inline">\(\Phi\)</span>: <span class="math display">\[
\Phi(D_i)=2\cdot num_i-size_i,
\]</span> 其中 <span class="math inline">\(num_i\)</span> 当前数组存储的元素个数，而 <span class="math inline">\(size_i\)</span> 为当前数组的规模，显然，这样定义能够满足我们的要求。</p>
<p>在初始空数组时，其势能为 <span class="math inline">\(0\)</span>，而根据上面描述的数组扩增的算法，显然在任意时刻，数组内元素个数至少为表规模的一半，于是在任意时刻都有 <span class="math inline">\(\Phi(D_i)\geq 0=\Phi(D_0)\)</span>，也就意味着最终可以得到一个实际总代价的上界。</p>
<p>我们将所有的插入操作分为两种进行讨论：引起了数组扩张与未引起数组扩张。下面用 <span class="math inline">\(\varphi_i\)</span> 表示 <span class="math inline">\(\Phi(D_i)\)</span>.</p>
<p>未引起数组扩张时，有 <span class="math inline">\(num_{i-1}=num_i-1, size_i=size_{i-1}\)</span>，于是有： <span class="math display">\[
\begin{aligned}
\hat c_i&amp;=c_i+\varphi_i-\varphi_{i-1}\\
&amp;=1+(2\cdot num_i-size_i) - (2\cdot num_{i-1}-size_{i-1})\\
&amp;=1+2\cdot(num_i-num_{i-1})=1+2=3
\end{aligned}
\]</span> 当引起了数组扩张时，首先有一个特例：开始时的第一次插入引起了表扩张，此时是积累势能： <span class="math display">\[
\begin{aligned}
\hat c_1&amp;=c_1+\varphi_1-\varphi_{0}\\
&amp;=1+(2\cdot num_1-size_1) - (2\cdot num_{0}-size_{0})\\
&amp;=1+1-0=2
\end{aligned}
\]</span> 其余的引起表扩张的情况，一定有 <span class="math inline">\(num_i-1=num_{i-1}=size_{i-1}, size_i=2\cdot size_{i-1}\)</span>，于是有： <span class="math display">\[
\begin{aligned}
\hat c_i&amp;=c_i+\varphi_i-\varphi_{i-1}\\
&amp;=num_{i-1}+1+(2\cdot num_i-size_i) - (2\cdot num_{i-1}-size_{i-1})\\
&amp;=num_i+(2\cdot num_i-2\cdot (num_i - 1))-(2\cdot(num_i - 1)-(num_i-1))\\
&amp;=num_i+2-(num_i-1)=3
\end{aligned}
\]</span> 于是综上所述，每个操作的摊还代价是 <span class="math inline">\(O(1)\)</span>， <span class="math inline">\(n\)</span> 个操作的总摊还代价就是 <span class="math inline">\(O(n)\)</span>.</p>
<h3 id="伸展树splay的时间复杂度分析">伸展树(Splay)的时间复杂度分析</h3>
<p>Splay 的各种操作的核心就是 <code>splay()</code> 操作，其余的只是常数上的变化。</p>
<p>记 <span class="math inline">\(x\)</span> 表示一棵有 <span class="math inline">\(n\)</span> 个点的 Splay 上的一个节点，<span class="math inline">\(x&#39;\)</span> 表示操作后的对应节点，<span class="math inline">\(|x|\)</span> 表示 Splay 上 <span class="math inline">\(x\)</span> 的子树大小。一次旋转的时间复杂度为 <span class="math inline">\(O(1)\)</span>，这里视为 <span class="math inline">\(1\)</span>。我们希望用势能函数的变化量抵消掉 Splay 上节点的访问代价，定义整棵 Splay 的势函数为 <span class="math inline">\(\Phi(S)=\sum\limits_{x\in S}\varphi(x)\)</span>，其中 <span class="math inline">\(\varphi(x)=\log|x|\)</span>.</p>
<p>对于访问节点带来的时间开销，我们将其均摊到旋转操作中，可以轻易地调整势函数中的常数进行抵消。</p>
<ol type="1">
<li>三点一线</li>
</ol>
<figure>
<img src="https://s2.loli.net/2022/02/08/6i5q4mRDGH9zPMU.png" alt="Splay_1.png" /><figcaption aria-hidden="true">Splay_1.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/02/08/O3koQTDUwYjgnNv.png" alt="Splay_2.png" /><figcaption aria-hidden="true">Splay_2.png</figcaption>
</figure>
<p>势能变化量为 <span class="math display">\[
\begin{aligned}
\Phi_i-\Phi_{i-1}=&amp;\varphi_i(x)+\varphi_i(y)+\varphi_i(z)\\
&amp;-\varphi_{i-1}(x)-\varphi_{i-1}(y)-\varphi_{i-1}(z)\\
\leq&amp;\varphi_i(x)-\varphi_{i-1}(x)+\varphi_i(z)-\varphi_{i-1}(y)\\
\leq&amp;\varphi_i(x)+\varphi_i(z)-2\cdot\varphi_{i-1}(x)
\end{aligned}
\]</span> 观察上面的树，不难发现有 <span class="math display">\[
|x&#39;|\geq|x|+|z&#39;|,
\]</span> 于是我们可以得到（注意式子与上面不一样） <span class="math display">\[
\begin{aligned}
&amp;\varphi_{i-1}(x)+\varphi_{i-1}(z)-2\cdot\varphi_{i}(x)\\
=&amp;\log\dfrac{|x||z&#39;|}{|x&#39;|^2}=\log\dfrac{|x||z&#39;|}{(|x|+|z&#39;|)^2}\\
\leq&amp;\log\dfrac{|x||z&#39;|}{2|x||z&#39;|}=\log\dfrac1 2=-1
\end{aligned}
\]</span> 于是有 <span class="math display">\[
\hat c_i=c_i+\Phi_i-\Phi_{i-1}\leq1+3\cdot(\varphi_i(x)-\varphi_{i-1}(x))-1=3\cdot(\varphi_i(x)-\varphi_{i-1}(x)).
\]</span></p>
<ol start="2" type="1">
<li>三点不在同一直线</li>
</ol>
<figure>
<img src="https://s2.loli.net/2022/02/09/IMkL7cqUYjQmBwh.png" alt="Splay_3.png" /><figcaption aria-hidden="true">Splay_3.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/02/09/YebLyF3oD6C7ITl.png" alt="Splay_4.png" /><figcaption aria-hidden="true">Splay_4.png</figcaption>
</figure>
<p>势能变化量为 <span class="math display">\[
\begin{aligned}
\Phi_i-\Phi_{i-1}=&amp;\varphi_i(x)+\varphi_i(y)+\varphi_i(z)\\
&amp;-\varphi_{i-1}(x)-\varphi_{i-1}(y)-\varphi_{i-1}(z)\\
=&amp;\varphi_i(y)+\varphi_{i}(z)-\varphi_{i-1}(x)-\varphi_{i-1}(y)\\
\end{aligned}
\]</span> 观察上图，我们可以得到 <span class="math display">\[
|y&#39;|+|z&#39;|\leq|x&#39;|
\]</span> 同理可得 <span class="math display">\[
\varphi_i(y)+\varphi_i(z)-2\cdot\varphi_{i}(x)\leq-1
\]</span> 于是有 <span class="math display">\[
\begin{aligned}
\hat c_i=&amp;c_i+\Phi_i-\Phi_{i-1}\\
\leq&amp;\varphi_i(y)+\varphi_{i}(z)-\varphi_{i-1}(x)-\varphi_{i-1}(y)\\
&amp;-(\varphi_i(y)+\varphi_i(z)-2\cdot\varphi_{i}(x))\\
=&amp;2\cdot \varphi_i(x)-\varphi_{i-1}(x)-\varphi_{i-1}(y)\\
\leq&amp;2\cdot(\varphi_i(x)-\varphi_{i-1}(x))
\end{aligned}
\]</span></p>
<ol start="3" type="1">
<li>单次旋转到根</li>
</ol>
<p><span class="math display">\[
\hat c_i=c_i+\Phi_i-\Phi_{i-1}=1+\varphi_i(x)-\varphi_{i-1}(x)
\]</span></p>
<p>综上，1. 2. 两种情况的摊还代价就是 <span class="math inline">\(O(\varphi_i(x)-\varphi_{i-1}(x))\)</span>，3. 的摊还代价是 <span class="math inline">\(O(1+\varphi_i(x)-\varphi_{i-1}(x))\)</span>，一次 <code>splay()</code> 操作就是若干次 1. 2. 与至多一次 3. 的结合，于是单次 spaly 操作的总摊还代价应当是 <span class="math inline">\(O(1+\varphi_{k}(x)-\varphi_0(x))\leq O(1+\log n)=O(\log n)\)</span>.</p>
<p>由于其他操作都基于 <code>splay()</code> 操作，额外消耗的仅是常数复杂度，可以直接在势函数中用常数平衡，于是一棵 Splay 的各种操作的时间复杂度都可以看作 <span class="math inline">\(O(\log n)\)</span>，将文章开始定义中的式子稍作变形可以得到 <span class="math display">\[
\sum\limits_{i=1}^nc_i=\sum\limits_{i=1}^n\hat c_i+\Phi(D_0)-\Phi(D_n)
\]</span> 根据上面的分析，<span class="math inline">\(m\)</span> 次操作的总摊还复杂度为 <span class="math display">\[
\sum\limits_{i=1}^n\hat c_i=O(m\log n)
\]</span> 根据这里势函数的定义，有 <span class="math display">\[
-n\log n\leq \Phi(D_0)-\Phi(D_m)\leq n\log n
\]</span> 于是有 <span class="math display">\[
\begin{aligned}
\sum\limits_{i=1}^nc_i=&amp;\sum\limits_{i=1}^n\hat c_i+\Phi(D_0)-\Phi(D_m)\\
\leq&amp;O(m\log n) +n\log n\\
=&amp;O((m+n)\log n)
\end{aligned}
\]</span></p>
<h3 id="lctlink-cut-tree的时间复杂度分析">LCT(Link-Cut Tree)的时间复杂度分析</h3>
<p>LCT 的所有操作都以 <code>Access()</code> 为基础，同时这也是所有函数的核心，其他部分的复杂度都是常数。</p>
<p>这里将 <code>Access()</code> 操作分成两部分：在实链 Splay 上、转变实虚链。</p>
<ol type="1">
<li>在实链 Splay 上</li>
</ol>
<p>主要的复杂度只是 <code>splay()</code> 操作，与上文同样的分析方式，容易得到总的复杂度为 <span class="math inline">\(O((n+m)\log n)\)</span>.</p>
<ol start="2" type="1">
<li>转变实虚边</li>
</ol>
<p>采用轻重链剖分，将子树最大的儿子作为重儿子，将虚边分为重虚边与轻虚边，实边以此类推。定义势函数 <span class="math inline">\(\Phi\)</span> 为重虚边的数量。</p>
<p><code>Access()</code> 过程中有以下两种变化可能：</p>
<ul>
<li>势能增加 <span class="math inline">\(1\)</span>，当且仅当选择的实边由重边切换到了轻边，根据轻重链剖分重链的性质，一次 <code>Access()</code>过程中此过程不超过 <span class="math inline">\(\log n\)</span> 次；</li>
<li>势能减小 <span class="math inline">\(1\)</span>，当且仅当选择的实边由轻边切换到了重边；</li>
</ul>
<p>设 <span class="math inline">\(\sum\Delta\Phi^+\)</span> 表示所有正势能变化量的和，<span class="math inline">\(\sum\Delta\Phi^-\)</span> 表示所有负的势能变化量的和，显然有 <span class="math display">\[
\left|\sum\Delta\Phi^-\right|\leq\Phi(S_0)+\sum\Delta\Phi^+\leq n+m\log n\tag1
\]</span> 于是势能变化总量为 <span class="math display">\[
\Phi(S_{m})-\Phi(S_0)=\sum\Delta\Phi^-+\sum\Delta\Phi^+\leq n+m\log n
\]</span> 每次换边的时间复杂度为 <span class="math inline">\(O(1)\)</span>，视为 <span class="math inline">\(1\)</span>，根据定义有 <span class="math display">\[
\sum\limits_{\Phi_i&gt;0} c_i+\sum\limits_{\Phi_i&lt;0} c_i\leq m\log n+\left|\sum\Delta\Phi^-\right|\leq n+2\cdot m\log n
\]</span> 于是有 <span class="math display">\[
\begin{aligned}
\sum_{i=1}^m\hat c_i=&amp;\sum_{i=1}^m c_i+\Phi(S_{m})-\Phi(S_0)\\
\leq&amp;2\cdot n+3\cdot m\log n\\
=&amp;O(n+m\log n)
\end{aligned}
\]</span> 综上所述，LCT 的时间复杂度为 <span class="math inline">\(O((n+m)\log n)\)</span>.</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>[1] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein 著, 殷建平, 徐云, 王刚, 刘晓光, 苏明, 邹恒明, 王宏志译, <em>算法导论（原书第 3 版）</em>, 北京: 机械工业出版社, 2013.1.</li>
<li>[2] <a href="https://www.cnblogs.com/Go7338395/p/14771217.html">势能分析 - Achtoria</a></li>
<li>[3] <a href="https://www.cnblogs.com/klauralee/p/10926342.html">势能分析（splay分析）- KLLstudio</a></li>
<li>[4] <a href="http://ljt12138.github.io/2019/08/05/potential_analysis/">势能分析法 - ljt12138</a></li>
<li>[5] <a href="https://www.cnblogs.com/Mr-Spade/p/9715203.html">伸展树（Splay）复杂度证明 - Mr_Spade</a></li>
<li>[6] <a href="https://www.cnblogs.com/reverymoon/p/10086216.html">Splay和LCT的复杂度分析 - remoon</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」Link-Cut Tree(LCT)</title>
    <url>/2022/01/24/LCT/</url>
    <content><![CDATA[<h2 id="简述">#1.0 简述</h2>
<h3 id="动态树问题">#1.1 动态树问题</h3>
<p>维护一个森林，支持删除某条边，加入某条边，并保证加边、删边之后仍然是森林。我们需要维护这个森林的一些信息。</p>
<p>一般的操作有两点连通性，两点路径权值和等等。</p>
<h3 id="实链剖分">#1.2 实链剖分</h3>
<p>先来回顾一下树链剖分，我们可以按照子树大小进行剖分（重链剖分），也可以按照子树高度进行剖分（长链剖分），使得原本的一棵树被分为若干条链，然后可以在链上通过如线段树这样的数据结构维护信息。</p>
<p>那么，存不存在一种剖分方式能够使我们更加得心应手地处理动态树问题？显然剖出的可能会不停变换，于是我们希望我们剖出来的链能够是我们想要的，那么只要我们选择剖出我们想要的链不就行了？(～￣▽￣)～</p>
<p>看起来很随意是不是？但是这就是<strong>实链剖分</strong>：</p>
<ul>
<li>对于一个点连向儿子的所有边，我们自己选择一条作为<strong>实边</strong>，剩下的边作为<strong>虚边</strong>。</li>
<li>实边连向的儿子是<strong>实儿子</strong>，剩下的是<strong>虚儿子</strong>。</li>
<li>一条由实边组成的链，我们称之为<strong>实链</strong>。</li>
</ul>
<p>显然这种剖分方法是极为灵活的，灵活到一条实链上的点根本不是固定的 (lll￢ω￢)，那么驯服这种放荡不羁的树链，我们要任用一种更加灵活的数据结构进行管理——Splay（伸展树）。</p>
<div class="note info"><p>关于伸展树，可以参考笔者的博客 <a href="https://www.cnblogs.com/Dfkuaid-210/p/splay.html">[数据结构]伸展树(Splay)</a>。</p>
</div>
<h3 id="辅助树">#1.3 辅助树</h3>
<p>先来捋清各种名称之间的关系：</p>
<ul>
<li>树上的每个节点与 Splay 上的节点一一对应 ；</li>
<li>一棵 Splay 维护一棵树上一条深度递增的链，Splay 上按照深度排序；</li>
<li>若干颗 Splay 组成一棵辅助树(AuxTree)，一棵辅助树代表一棵原树；</li>
<li>所有辅助树组成 LCT；</li>
</ul>
<p>一个很重要的点：辅助树上的所有 Splay <strong>并不是相互独立的</strong>。原本一棵 Splay 的根节点是不应该有父节点的，但是在辅助树上，一棵 Splay 的根节点的父节点就是这棵 Splay 维护的树链在原树上的父亲。但是，这种父亲链接的特点是：<strong>子认父而父不认子</strong>，换句话讲，这种父亲链接中的父亲所存储的左右儿子都不是这个链接中的儿子，也就是说辅助树可能并不是一棵二叉树，同时，我们也可以利用这个性质快速判断一个节点是否是所在 Splay 的根节点。</p>
<p>同时，Splay 可以在满足辅助树、Splay 的性质的前提下任意变换。意味着原树中的根在辅助树中不一定是根。</p>
<p>如图，这是一棵原树：</p>
<figure>
<img src="https://s2.loli.net/2022/01/26/X5EHxDOaGeopNb6.png" alt="lct_1.png" /><figcaption aria-hidden="true">lct_1.png</figcaption>
</figure>
<p>其中实线代表的是实边，虚线代表是虚边。</p>
<p>那么相应的辅助树<strong>可能</strong>如下（Splay 是可以变换的哦 OvO）：</p>
<figure>
<img src="https://s2.loli.net/2022/01/26/nGgDc96EoreVauZ.png" alt="lct_2.png" /><figcaption aria-hidden="true">lct_2.png</figcaption>
</figure>
<h2 id="主要函数">#2.0 主要函数</h2>
<h3 id="一些变量及其含义">一些变量及其含义</h3>
<p>直接把代码丢在这里吧 (￣▽￣)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>], fa; <span class="comment">//左右儿子及父亲</span></span><br><span class="line">    <span class="keyword">int</span> rev_tag, lzy_tag; <span class="comment">//翻转标记及信息懒标记</span></span><br><span class="line">    <span class="keyword">int</span> val, siz, var; <span class="comment">//单点信息，子树大小，维护信息</span></span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) p[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) p[x].ch[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) p[x].ch[1]</span></span><br></pre></td></tr></table></figure>
<p>具体用途下文再说 &lt;(ˉ^ˉ)&gt;</p>
<h3 id="一些基础操作">一些基础操作</h3>
<p>首先是 <code>pushup()</code> 和 <code>pushdown()</code>，没什么好说的，根据题目有所不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    p[k].siz = p[p[k].ch[<span class="number">0</span>]].siz + p[p[k].ch[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*Other things that need to be maintained.*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[k].rev_tag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[k].ch[<span class="number">0</span>]) <span class="built_in">reverse</span>(p[k].ch[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (p[k].ch[<span class="number">1</span>]) <span class="built_in">reverse</span>(p[k].ch[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">/*reverse() 是个什么函数请见下文*/</span></span><br><span class="line">        p[k].rev_tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Other things that need to be maintained.*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是 <code>get_type()</code> 和 <code>isroot()</code>，前者获取当前节点是父亲的哪一种儿子，后者则是判断当前节点是不是所在 Splay 的根。</p>
<p><code>get_type()</code> 是 Splay 的经典操作了，不多展开；<code>isroot()</code> 需要用到辅助树上 Splay 的性质：根节点的父亲不认这个儿子，所以只需要判断当前节点的父亲记录的儿子中是否包含当前节点即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_type</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x == p[p[x].fa].ch[<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x != <span class="built_in">ls</span>(<span class="built_in">f</span>(x)) &amp;&amp; x != <span class="built_in">rs</span>(<span class="built_in">f</span>(x));&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-与-splay">rotate() 与 splay()</h3>
<p><code>rotate()</code> 还是将当前节点在 Splay 中上移一层，不过与经典 Splay 中的略有不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">f</span>(x), z = <span class="built_in">f</span>(y), op = <span class="built_in">get_type</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y)) p[z].ch[<span class="built_in">get_type</span>(y)] = x; <span class="comment">//Here.</span></span><br><span class="line">    p[y].ch[op] = p[x].ch[!op], p[p[x].ch[!op]].fa = y;</span><br><span class="line">    p[x].ch[!op] = y, p[y].fa = x, p[x].fa = z;</span><br><span class="line">    <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们一定要先判断当前节点的父节点是不是根节点，然后在进行变换。至于为什么不用判断 <code>x</code> 是不是根节点，因为 <code>rotate()</code> 只会在 <code>splay()</code> 中被调用，然鹅 <code>splay()</code> 中限定了此节点不是根节点。</p>
<p>现在我们来看 <code>splay()</code>；注意到一点，我们可能需要下放许多标记，由于 Splay 本身极其灵活，我们一定要考虑将所有的标记下放之后再调整其结构，也就需要在 <code>splay()</code> 之前先调用一个 <code>update()</code> 函数进行标记的下放。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (!<span class="built_in">isroot</span>(x)) <span class="built_in">update</span>(<span class="built_in">f</span>(x)); <span class="built_in">pushdown</span>(x);&#125;</span><br></pre></td></tr></table></figure>
<p><code>update()</code> 我们采用递归的形式实现，从要调整上去的节点开始，一层层向上深搜，直到到达根部，此时所有儿子可能发生变化的节点上的信息都已经下放完毕。然后我们就可以随心所欲的<del>调教</del>改变这棵 Splay 了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fa; fa = <span class="built_in">f</span>(x), !<span class="built_in">isroot</span>(x); <span class="built_in">rotate</span>(x))</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">isroot</span>(fa)) <span class="built_in">rotate</span>(<span class="built_in">get_type</span>(fa) == <span class="built_in">get_type</span>(x) ? fa : x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info"><p>这里并不会展开讲解 <code>rotate()</code> 与 <code>splay()</code>，因为他们都是 Splay 的基础函数，详细解释见 <a href="https://www.cnblogs.com/Dfkuaid-210/p/splay.html">[数据结构]伸展树(Splay)</a>。</p>
</div>
<h3 id="access">Access()</h3>
<p>首先来了解一下 <code>Access()</code> 的本质：将一个点 <span class="math inline">\(x\)</span> 到原树上的根之间的路径中的所有边选择为实边，组成实链。</p>
<p>于是我们考虑从底部开始，一层一层向上构建。</p>
<p>当我们把当前处理到的点 <span class="math inline">\(x\)</span> <code>splay()</code> 到所在 Splay 的根后，显然此时在他右子树中的点深度都要比 <span class="math inline">\(x\)</span> 的深度大，一定不被包含在所要构建的 Splay 中，于是直接将其断掉；</p>
<p>再考虑他的父亲（在另一棵 Splay 中），我们就同样将他 <code>splay()</code> 到根部，考虑当前右子树中的点一定要么与 <span class="math inline">\(x\)</span> 深度相同，要么比 <span class="math inline">\(x\)</span> 的还要深，这些点一定都不能出现在 Splay 中，于是断掉，接上 <span class="math inline">\(x\)</span>，那么在左子树中的点呢？他们的深度一定更浅，且根据辅助树上 Splay 的要求，这些点一定是在从 <span class="math inline">\(x\)</span> 到根的路径上的，于是不用管。重复这个过程，直到根也被处理完。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; x; t = x, x = <span class="built_in">f</span>(x))</span><br><span class="line">      <span class="built_in">splay</span>(x), p[x].ch[<span class="number">1</span>] = t, <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> t; <span class="comment">//这里返回的是所在 Splay 的根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉这样讲应该很清楚了吧 QwQ，但还是做了图帮助理解 &lt;(￣ˇ￣)/</p>
<details class="note info no-icon"><summary><p>帮助理解的图示过程</p>
</summary>
<p>（经典老图重置版了属于是）现在我们有如下的一棵树，实线是实边，虚线是虚边。</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/M8gUIJrvZhHBNGe.png" alt="lct_access_1.png" /><figcaption aria-hidden="true">lct_access_1.png</figcaption>
</figure>
<p>现在我们想要 <code>Access(N)</code>，也就是想将其变为</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/afvt8rOdYsPhibB.png" alt="lct_access_2.png" /><figcaption aria-hidden="true">lct_access_2.png</figcaption>
</figure>
<p>他的辅助树的一种可能的形态为</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/gPSO2nG3BaZEeh1.png" alt="lct_access_3.png" /><figcaption aria-hidden="true">lct_access_3.png</figcaption>
</figure>
<p>（图中实线连接的点存在于同一棵 Splay 中，红色线表示相对上一步做出了更改）</p>
<p>按照上面的步骤进行变换</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/8sNGA5vWd2Ztg6b.png" alt="lct_access_4.png" /><figcaption aria-hidden="true">lct_access_4.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/27/QYBopbuUPdlsRqr.png" alt="lct_access_5.png" /><figcaption aria-hidden="true">lct_access_5.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/27/fdapNCiV7smOKqA.png" alt="lct_access_6.png" /><figcaption aria-hidden="true">lct_access_6.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/27/hMCzkTKXu1wIr5c.png" alt="lct_access_7.png" /><figcaption aria-hidden="true">lct_access_7.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/27/kKVIeyCHovint9s.png" alt="lct_access_8.png" /><figcaption aria-hidden="true">lct_access_8.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/27/s5NdrMOvtX4yzCh.png" alt="lct_access_9.png" /><figcaption aria-hidden="true">lct_access_9.png</figcaption>
</figure>

</details>
<h3 id="make_root-与-find_root">make_root() 与 find_root()</h3>
<p>在实际运用中，我们需要维护的路径很有可能不是一条深度递增的链，但是这种链是不被允许组成一颗 Splay，由于 LCT 极为灵活，此时，如果题目性质允许，我们可以尝试将一端转换为原树的根节点。</p>
<p>比如这里有一棵以 <span class="math inline">\(A\)</span> 为根的树：</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/Y16e4ulNWGkpnHV.png" alt="lct_mr_1.png" /><figcaption aria-hidden="true">lct_mr_1.png</figcaption>
</figure>
<p>现在我们要将他变为以 <span class="math inline">\(I\)</span> 为根（红色边为父子关系变化的边）：</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/rsHXCdt3h8eTkNj.png" alt="lct_mr_2.png" /><figcaption aria-hidden="true">lct_mr_2.png</figcaption>
</figure>
<p>通过图片容易看出，从我们要变为根的 <span class="math inline">\(x\)</span> 到原根的路径上的所有父子关系都应该反转，但是不在该路径上的点并没有受到影响，他的父亲该是谁还是谁。注意到，在原树上的一条链的父子关系反转就是其深度关系完全反转，于是在 <code>Access(x)</code> 之后，我们需要做的就是将 <span class="math inline">\(x\)</span> 所在的 Splay 上的每个节点的左右儿子全部交换，一下做完的时间复杂度是很难被保证的，于是我们采用打标记的方式进行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="built_in">swap</span>(p[x].ch[<span class="number">0</span>], p[x].ch[<span class="number">1</span>]); p[x].rev_tag ^= <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;x = <span class="built_in">Access</span>(x); <span class="built_in">reverse</span>(x);&#125;</span><br></pre></td></tr></table></figure>
<p>既然我们很多时候修改了原树的根，那么又该如何确定当前原树的根是谁呢？这对于我们判断两者是否在同一棵树上很重要。</p>
<p>同样还是利用 Splay 的性质，我们是按照深度进行的排序，于是在 <code>Access()</code> 之后，根一定是深度最浅的那个，于是我们直接不断进入左子树，找到最左端的节点即可。注意，我们一定要将所有的标记全部下传，少传一个标记可能整个 Splay 的结构就被粉碎了 QwQ。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">Access</span>(x), <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ls</span>(x)) x = <span class="built_in">ls</span>(x), <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="built_in">splay</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="linkcutsplit">link()、cut()、split()!</h3>
<p>叫了这么久的 Link-Cut Tree，终于讲到 <code>link()</code> 与 <code>Cut()</code> 操作了 OvO。</p>
<p><code>link()</code> 操作很简单，显然我们只需要在确保要连接的两者不在同一棵树中，然后将一者变为所在树的根（原树与 Splay 双重意义）然后直接相连就是了。</p>
<p><code>cut()</code> 的时候，我们同样先将其中一点 <span class="math inline">\(x\)</span> 变为所在树的根，然后进行一波判断。</p>
<ul>
<li><p>判断 <span class="math inline">\(y\)</span> 与 <span class="math inline">\(x\)</span> 是否在同一棵树中；</p></li>
<li><p>判断 <span class="math inline">\(y\)</span> 是否是 <span class="math inline">\(x\)</span> 的直接儿子；</p>
<ol type="1">
<li>要求 <span class="math inline">\(y\)</span> 的父亲是 <span class="math inline">\(x\)</span>，这是一个必要不充分条件；</li>
<li>由于父亲存的是辅助树上的父亲，<span class="math inline">\(y\)</span> 可能是所在 Splay 的根，但是还有比他深度浅的节点（<span class="math inline">\(y\)</span> 的左儿子），由于 Splay 维护的是从上到下的一条链，于是如果 <span class="math inline">\(y\)</span> 有左儿子，那么一定意味着 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 之间还有其他的点。</li>
</ol></li>
</ul>
<p>都满足后，此时 <span class="math inline">\(y\)</span> 一定是 <span class="math inline">\(x\)</span> 的左儿子，于是我们就可以直接断开。</p>
<p><code>split()</code> 实际就是单独分出原树上 <span class="math inline">\(x\to y\)</span> 的路径，我们只需要将一者变为根，然后 <code>Access()</code> 另一者即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="built_in">make_root</span>(x); <span class="keyword">if</span> (<span class="built_in">find_root</span>(y) != x) <span class="built_in">splay</span>(x), p[x].fa = y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="built_in">make_root</span>(x); <span class="built_in">Access</span>(y); <span class="built_in">splay</span>(y);&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">make_root</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_root</span>(y) == x &amp;&amp; <span class="built_in">f</span>(y) == x &amp;&amp; !<span class="built_in">ls</span>(y))</span><br><span class="line">      p[y].fa = p[x].ch[<span class="number">1</span>] = <span class="number">0</span>, <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题">#3.0 例题</h2>
<h3 id="luogu3690-模板动态树link-cut-tree">#3.1 <a href="https://www.luogu.com.cn/problem/P3690">Luogu3690 【模板】动态树（Link Cut Tree）</a></h3>
<p>是真的模板呢 ( 0 - 0 )。</p>
<details class="note info no-icon"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> val, sum, rev_tag, ch[<span class="number">2</span>], fa;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) p[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) p[x].ch[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) p[x].ch[1]</span></span><br><span class="line"></span><br><span class="line">    Node p[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">LCT</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">get_type</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x == p[<span class="built_in">f</span>(x)].ch[<span class="number">1</span>];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ls</span>(<span class="built_in">f</span>(x)) != x &amp;&amp; <span class="built_in">rs</span>(<span class="built_in">f</span>(x)) != x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;p[k].sum = p[k].val ^ p[<span class="built_in">ls</span>(k)].sum ^ p[<span class="built_in">rs</span>(k)].sum;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="built_in">swap</span>(p[x].ch[<span class="number">0</span>], p[x].ch[<span class="number">1</span>]); p[x].rev_tag ^= <span class="number">1</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x].rev_tag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ls</span>(x)) <span class="built_in">reverse</span>(<span class="built_in">ls</span>(x));</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">rs</span>(x)) <span class="built_in">reverse</span>(<span class="built_in">rs</span>(x));</span><br><span class="line">            p[x].rev_tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (!<span class="built_in">isroot</span>(x)) <span class="built_in">update</span>(<span class="built_in">f</span>(x)); <span class="built_in">pushdown</span>(x);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">f</span>(x), z = <span class="built_in">f</span>(y), op = <span class="built_in">get_type</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y)) p[z].ch[<span class="built_in">get_type</span>(y)] = x;</span><br><span class="line">        p[y].ch[op] = p[x].ch[!op], p[p[x].ch[!op]].fa = y;</span><br><span class="line">        p[x].ch[!op] = y, p[y].fa = x, p[x].fa = z;</span><br><span class="line">        <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fa; fa = <span class="built_in">f</span>(x), !<span class="built_in">isroot</span>(x); <span class="built_in">rotate</span>(x))</span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">isroot</span>(fa)) <span class="built_in">rotate</span>(<span class="built_in">get_type</span>(fa) == <span class="built_in">get_type</span>(x) ? fa : x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (t = <span class="number">0</span>; x; t = x, x = <span class="built_in">f</span>(x))</span><br><span class="line">          <span class="built_in">splay</span>(x), p[x].ch[<span class="number">1</span>] = t, <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">Access</span>(x), <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">ls</span>(x)) x = <span class="built_in">ls</span>(x), <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="built_in">splay</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;x = <span class="built_in">Access</span>(x); <span class="built_in">reverse</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="built_in">make_root</span>(x); <span class="keyword">if</span> (<span class="built_in">find_root</span>(y) != x) <span class="built_in">splay</span>(x), p[x].fa = y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="built_in">make_root</span>(x); <span class="built_in">Access</span>(y); <span class="built_in">splay</span>(y);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">make_root</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find_root</span>(y) == x &amp;&amp; <span class="built_in">f</span>(y) == x &amp;&amp; !<span class="built_in">ls</span>(y))</span><br><span class="line">          p[y].fa = p[x].ch[<span class="number">1</span>] = <span class="number">0</span>, <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; lct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(lct.p[i].val);</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">read</span>(op), <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) lct.<span class="built_in">split</span>(x, y), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lct.p[y].sum);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) lct.<span class="built_in">link</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) lct.<span class="built_in">cut</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> lct.<span class="built_in">splay</span>(x), lct.p[x].val = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>
<h3 id="hnoi2010弹飞绵羊">#3.2 <a href="https://www.luogu.com.cn/problem/P3203">「HNOI2010」弹飞绵羊</a></h3>
<p>我们将 <span class="math inline">\(i+k_i\)</span> 作为 <span class="math inline">\(i\)</span> 的父亲节点，显然每个点最多只有一个出边，并且至少有一个点没有出边，显然这会构成一个森林，每次修改弹簧劲度时，实际就是断边然后重连，于是显然可以 LCT.</p>
<p>注意到，我们每次询问时要查询的东西就是从 <span class="math inline">\(x\)</span> 到所在树的根构成的链上一共有多少个节点，于是我们的树根是不方便改变的，于是就没有办法使用 <code>make_root()</code>，对于 <code>link()</code> 的影响不大，因为连接时一定是刚断开这个位置的边，如果我们不能改变原树的根，那么此时这个点一定是所在树的根，于是只需要把他拉到所在 Splay 的根部即可。同时，由于 <code>cut()</code> 的操作完全由我们操作，任一时刻一定是合法的，于是便不需要使用 <code>make_root()</code> 来辅助判断合法性。假如我们要断开 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 之间的边，我们只需要先 <code>Access(x)</code>，由于 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(x\)</span> 的父亲，于是这样 <span class="math inline">\(y\)</span> 与 <span class="math inline">\(x\)</span> 一定在同一棵 Splay 上，然后 <code>splay(y)</code>，由于在原树中 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(x\)</span> 的直接父亲，此时 <span class="math inline">\(x\)</span> 一定是 <span class="math inline">\(y\)</span> 的右儿子，直接断开即可。</p>
<p>查询时直接 <code>Access()</code> 然后返回所在 Splay 上的节点数即可。</p>
<p>剩下的都是 LCT 的板子了，这道题我们充分运用了 LCT 的灵活性。</p>
<details class="note info no-icon"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> siz, ch[<span class="number">2</span>], fa;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) p[x].ch[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) p[x].ch[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) p[x].fa</span></span><br><span class="line"></span><br><span class="line">    Node p[N]; <span class="keyword">int</span> siz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">LCT</span><span class="params">()</span> </span>&#123;siz = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _siz)</span> </span>&#123;siz = _siz; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= siz; ++ i) p[i].siz = <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;p[k].siz = p[<span class="built_in">ls</span>(k)].siz + p[<span class="built_in">rs</span>(k)].siz + <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_type</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">rs</span>(<span class="built_in">f</span>(k)) == k;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ls</span>(<span class="built_in">f</span>(k)) != k &amp;&amp; <span class="built_in">rs</span>(<span class="built_in">f</span>(k)) != k;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">f</span>(x), z = <span class="built_in">f</span>(y), op = <span class="built_in">get_type</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y)) p[z].ch[<span class="built_in">get_type</span>(y)] = x;</span><br><span class="line">        p[y].ch[op] = p[x].ch[!op], p[p[x].ch[!op]].fa = y;</span><br><span class="line">        p[x].ch[!op] = y, p[y].fa = x, p[x].fa = z;</span><br><span class="line">        <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fa; fa = <span class="built_in">f</span>(x), !<span class="built_in">isroot</span>(x); <span class="built_in">rotate</span>(x))</span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">isroot</span>(fa)) <span class="built_in">rotate</span>(<span class="built_in">get_type</span>(fa) == <span class="built_in">get_type</span>(x) ? fa : x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (t = <span class="number">0</span>; x; t = x, x = <span class="built_in">f</span>(x))</span><br><span class="line">          <span class="built_in">splay</span>(x), p[x].ch[<span class="number">1</span>] = t, <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="built_in">splay</span>(x), p[x].fa = y;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Access</span>(x); <span class="built_in">splay</span>(y); p[y].ch[<span class="number">1</span>] = p[x].fa = <span class="number">0</span>; <span class="built_in">pushup</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="built_in">Access</span>(x); <span class="built_in">splay</span>(x); <span class="keyword">return</span> p[x].siz;&#125;</span><br><span class="line">&#125; lct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, to[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + to[x] &lt;= n) lct.<span class="built_in">cut</span>(x, x + to[x]);</span><br><span class="line">    <span class="keyword">if</span> (x + y &lt;= n) lct.<span class="built_in">link</span>(x, x + (to[x] = y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); lct.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(to[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (i + to[i] &lt;= n) lct.<span class="built_in">link</span>(i, i + to[i]);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="built_in">read</span>(op), <span class="built_in">read</span>(x); ++ x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lct.<span class="built_in">query</span>(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">read</span>(y), <span class="built_in">modify</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>
<h2 id="时间复杂度分析">#4.0 时间复杂度分析</h2>
<p>对于 LCT 的时间复杂度分析我们采用<strong>势能法</strong>，详情见笔者博客<a href="https://dfkuaid.github.io/2022/02/07/potential-method/#lctlink-cut-tree的时间复杂度分析">势能分析法 - #2.4 LCT 的时间复杂度分析</a>.</p>
<div id="refer">

</div>
<h2 id="参考文章">参考文章</h2>
<ul>
<li>[1] <a href="https://oi-wiki.org/ds/lct/">Link Cur Tree - OI Wiki</a></li>
<li>[2] <a href="https://www.cnblogs.com/flashhu/p/8324551.html">LCT总结——概念篇+洛谷P3690[模板]Link Cut Tree(动态树)（LCT，Splay）- FlashHu</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>数据结构</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」李超线段树</title>
    <url>/2022/01/22/LiChao-Tree/</url>
    <content><![CDATA[<h2 id="屑在前面">#0.0 屑在前面</h2>
<p><strong>李超线段树</strong> 由学军中学队爷李超在<a href="https://wenku.baidu.com/view/6735b8e29b89680203d825b7.html">省选讲课</a>中提出。</p>
<p>事实上，整体来看并没有什么特别特别的，只是线段树维护的信息特殊化了。</p>
<h2 id="概述">#1.0 概述</h2>
<h3 id="适用问题">#1.1 适用问题</h3>
<p>支持动态维护一个平面直角坐标系，支持插入直线/线段，查询与直线 <span class="math inline">\(x=x_0\)</span> 的直线/线段交点纵坐标最大/最小的直线。</p>
<h3 id="大致思想">#1.2 大致思想</h3>
<p>维护每个区间中，完全通过该区间，且位于最上层长度最长的直线，利用标记永久化思想。</p>
<p>考虑插入一条直线，且处理到了某个区间，那么可能有以下几种情况：</p>
<ul>
<li>当前区间没有被任何一条线段覆盖，直接修改；</li>
<li>根据端点值判断新的线段是否完全被原本线段覆盖，直接返回；</li>
<li>根据端点值判断新的线段是否完全覆盖原本线段，直接修改，然后返回；</li>
<li>通过交点位置与端点值的大小关系判断长度关系，将长的记录，短的递归进入相应子树；</li>
</ul>
<p>查询时就是标记永久化的思想，将所经过的每一条被记录的线段都拿出来比较即可。</p>
<p>综上，查询的时间复杂度是 <span class="math inline">\(O(\log n)\)</span>.</p>
<p>事实上，对于要插入的线段，我们先将其能覆盖的区间通过线段树划分为 <span class="math inline">\(O(\log n)\)</span> 个，每个完全覆盖的区间再单独进行上面的操作，上面单独操作时，每次线段长度至少减半，于是最多向下递归 <span class="math inline">\(O(\log n)\)</span> 层，于是修改总体时间复杂度为 <span class="math inline">\(O(\log^2n)\)</span>.</p>
<h2 id="应用">#2.0 应用</h2>
<h3 id="板子">#2.1 板子</h3>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P4254">P4254 [JSOI2008]Blue Mary开公司</a></p>
</blockquote>
<p>由于插入的是直线而不是线段，于是不需要先分段，可以直接进行修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LMT = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T x, T y)</span> </span>&#123;<span class="keyword">return</span> x &gt; y ? x : y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T x, T y)</span> </span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ls, rs, val;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> k, b;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Line</span><span class="params">()</span> </span>&#123;k = b = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Line</span><span class="params">(<span class="keyword">double</span> _k, <span class="keyword">double</span> _b)</span> </span>&#123;k = _k, b = _b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">val</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> k * x + b;&#125;</span><br><span class="line">&#125; s[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCTree</span> &#123;</span></span><br><span class="line">    Node p[N]; <span class="keyword">int</span> cnt, rt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">LCTree</span><span class="params">()</span> </span>&#123;cnt = rt = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) k = ++ cnt; <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; p[k].val = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">build</span>(p[k].ls, l, mid); <span class="built_in">build</span>(p[k].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p[k].val) &#123;p[k].val = id; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        db l2 = s[p[k].val].<span class="built_in">val</span>(l), r2 = s[p[k].val].<span class="built_in">val</span>(r);</span><br><span class="line">        db l1 = s[id].<span class="built_in">val</span>(l), r1 = s[id].<span class="built_in">val</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (l1 &lt;= l2 &amp;&amp; r1 &lt;= r2) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; l2 &amp;&amp; r1 &gt; r2) &#123;p[k].val = id; <span class="keyword">return</span>;&#125;</span><br><span class="line">        db x = (s[id].b - s[p[k].val].b) / (s[p[k].val].k - s[id].k);</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; mid) <span class="built_in">insert</span>(p[k].rs, mid + <span class="number">1</span>, r, p[k].val), p[k].val = id;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">insert</span>(p[k].ls, l, mid, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; mid) <span class="built_in">insert</span>(p[k].rs, mid + <span class="number">1</span>, r, id);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">insert</span>(p[k].ls, l, mid, p[k].val), p[k].val = id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> s[p[k].val].<span class="built_in">val</span>(x);</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="keyword">double</span> res = s[p[k].val].<span class="built_in">val</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">query</span>(p[k].ls, l, mid, x), res);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">query</span>(p[k].rs, mid + <span class="number">1</span>, r, x), res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, lcnt, T; <span class="keyword">char</span> op[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">    <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;P&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> k = <span class="number">0</span>, b = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;b, &amp;k);</span><br><span class="line">        s[++ lcnt] = <span class="built_in">Line</span>(k, b - k); t.<span class="built_in">insert</span>(t.rt, <span class="number">1</span>, LMT, lcnt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>; <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (ll)(t.<span class="built_in">query</span>(t.rt, <span class="number">1</span>, LMT, x) / <span class="number">100.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;t.<span class="built_in">build</span>(t.rt, <span class="number">1</span>, LMT); <span class="built_in">read</span>(T); <span class="keyword">while</span> (T --) <span class="built_in">Main</span>(); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斜率优化">#2.2 斜率优化</h3>
<blockquote>
<p><a href="https://loj.ac/p/2353">「NOI2007」货币兑换</a></p>
</blockquote>
<p>设 <span class="math inline">\(f_i\)</span> 表示到第 <span class="math inline">\(i\)</span> 天可以拥有的最大钱数，先写出一个大概的转移方程 <span class="math display">\[
f_i=\max\limits_{0&lt;j&lt;i}\{num_A\cdot a_i+num_B\cdot b_i\},
\]</span> 其中 <span class="math inline">\(num_A\)</span> 与 <span class="math inline">\(num_B\)</span> 分别表示持有的 <span class="math inline">\(A\)</span> 金卷的数量与 <span class="math inline">\(B\)</span> 金卷的数量，这两个数由 <span class="math inline">\(j\)</span> 决定。显然，第 <span class="math inline">\(j\)</span> 天买入时，能得到的金卷比例是一定的，于是当天买入时拥有的钱数越大越好，也就是 <span class="math inline">\(f_j\)</span>，应当有 <span class="math display">\[
\begin{aligned}
f_j&amp;=num_A\cdot a_j+num_B\cdot b_j\\
f_j&amp;=num_B\cdot R_j\cdot a_j+num_B\cdot b_j\\
num_B&amp;=\dfrac{f_j}{R_j\cdot a_j+b_j},
\end{aligned}
\]</span> 同理可得 <span class="math display">\[
num_A=\dfrac{f_j\cdot R_j}{R_j\cdot a_j+b_j},
\]</span> 于是我们可以写出完整的状态转移方程 <span class="math display">\[
f_i=\max\limits_{0&lt;j&lt;i}\left\{\dfrac{f_j\cdot R_j}{R_j\cdot a_j+b_j}\cdot a_i+\dfrac{f_j}{R_j\cdot a_j+b_j}\cdot b_i\right\},\\
\frac{f_i}{b_i}=\max\limits_{0&lt;j&lt;i}\left\{\dfrac{f_j\cdot R_j}{R_j\cdot a_j+b_j}\cdot \frac{a_i}{b_i}+\dfrac{f_j}{R_j\cdot a_j+b_j}\right\},
\]</span> 于是我们就可以直接将一个决策看作一条斜率为 <span class="math inline">\(\frac{f_j\cdot R_j}{R_j\cdot a_j+b_j}\)</span>、纵轴截距为 <span class="math inline">\(\frac{f_j}{R_j\cdot a_j+b_j}\)</span> 的直线，对于 <span class="math inline">\(i\)</span>，我们要求的就是已有的所有决策直线与 <span class="math inline">\(x=\frac{a_i}{b_i}\)</span> 交点纵坐标的最大值。于是就可以直接用李超线段树进行维护。</p>
<div id="refer">

</div>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><p>[1] <a href="https://www.cnblogs.com/cjyyb/p/10560973.html">李超线段树 - 小蒟蒻yyb</a></p></li>
<li><p>[2] <a href="https://oi-wiki.org/ds/li-chao-tree/">李超线段树 - OI Wiki</a></p></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>「DP 浅析」斜率优化</title>
    <url>/2022/01/03/slope-optimization/</url>
    <content><![CDATA[<h2 id="屑在前面">#0.0 屑在前面</h2>
<p>将结合经典例题 <a href="https://www.luogu.com.cn/problem/P3195">「HNOI2008」玩具装箱</a> 以及 <a href="https://loj.ac/p/2353">「NOI2007」货币兑换</a> 进行讲解。</p>
<div id="sketch">

</div>
<h2 id="简述">#1.0 简述</h2>
<h3 id="适用情况">#1.1 适用情况</h3>
<p>斜率优化一般适用于状态转移方程如下的 DP <span class="math display">\[
f_i=\mathop{\min/\max}\limits_{0\leq j&lt;i}\{a_i\cdot b_j + c_i + d_j\},
\]</span> 其中 <span class="math inline">\(a_i,b_j,c_i, d_j\)</span> 在计算 <span class="math inline">\(f_i\)</span> 时都是常数（已知量）。</p>
<h3 id="大致思想">#1.2 大致思想</h3>
<blockquote>
<p>为了方便叙述，下文中的方程都采用 <span class="math inline">\(f_i=\min\limits_{0\leq j&lt;i}\{a_i\cdot b_j + c_i + d_j\}\)</span> 的形式。</p>
</blockquote>
<p>假设我们从决策点 <span class="math inline">\(j\)</span> 处转移到 <span class="math inline">\(i\)</span>，那么应当有转移式 <span class="math display">\[
f_i=a_i\cdot b_j+c_i+d_j,
\]</span> 此时，对于众多可能的决策点 <span class="math inline">\((b_j,d_j)\)</span>，将上式化作一个直线斜截式方程，于是有 <span class="math display">\[
d_j=-a_i\cdot b_j+f_i-c_i,
\]</span> &gt; 换句话讲，其实这里的形式转换就是将只与 <span class="math inline">\(j\)</span> 有关的项放到一边，剩下的放到另一边。</p>
<p>又因为 <span class="math inline">\(c_i\)</span> 是一个已知的常数，于是我们的目的就变为了对于斜率 <span class="math inline">\(-a_i\)</span>，在所有的决策点中，我们选择需要令直线的截距 <span class="math inline">\(f_i-c_i\)</span> 尽可能小那一个。</p>
<p>此时，我们还不能仅利用上面的结论对 DP 的时间复杂度进行优化，我们还需要研究决策点的性质。首先，不难看出，仅有所有下凸包上的点是可能的决策点，如下图：</p>
<p><img src="https://pic.imgdb.cn/item/61d414c42ab3f51d9158e521.jpg" /></p>
<p>显然（相对较严谨的证明见 <a href="#extra-prove-1">#1.3 关于决策一定在凸包上的证明</a>）不在下凸包上的点，无论在哪种斜率下，在下凸包上都具有更好的替代品。</p>
<p>一个经典的结论是：<strong>对于指定斜率 <span class="math inline">\(k\)</span> 的直线，与上/下凸包上相切确定的一条纵轴截距最大/最小</strong>。而由于下凸壳上的线段直线的斜率单调递增，于是一个点是切点当且仅当其左边的线段斜率 <span class="math inline">\(&lt;k\)</span> 而右边的 <span class="math inline">\(&gt;k\)</span>。</p>
<p>综上，我们在寻找最优决策点的时候就可以通过 <span class="math inline">\(O(n\log n)\)</span> 维护整个下凸包，单次 <span class="math inline">\(O(\log n)\)</span> 二分查询寻找最优决策点的位置，另一种写起来更加简洁的方式是采用 CDQ 分治。同时，如果决策点本身具有一定的特殊性质（如单调性），我们甚至可以不保存整个下凸包，对时间复杂度可能又有进一步的优化。这些在下文都会提到。</p>
<blockquote>
<p>事实上，我们也可以用 <a href="https://dfkuaid.github.io/2022/01/22/LiChao-Tree/">李超线段树</a> 维护斜率优化<sup><a href="#refer">[7]</a></sup>。</p>
</blockquote>
<div id="extra-prove-1">

</div>
<h3 id="关于决策一定在凸包上的证明">#1.3 关于决策一定在凸包上的证明</h3>
<blockquote>
<p>这里状态转移方程依旧都采用 <span class="math inline">\(f_i=\min\limits_{0\leq j&lt;i}\{a_i\cdot b_j + c_i + d_j\}\)</span> 的形式。</p>
</blockquote>
<p>设 <span class="math inline">\(0\leq j_1&lt;j_2&lt;i\)</span> 为 <span class="math inline">\(i\)</span> 的两个决策点，且满足决策点 <span class="math inline">\(j_2\)</span> 优于 <span class="math inline">\(j_1\)</span>，那么有 <span class="math display">\[
a_i\cdot b_{j_1}+c_i+d_{j_1}\geq a_i\cdot b_{j_2}+c_i+d_{j_2},
\]</span> 接下来的一步是进行<strong>参变分离</strong>，将含有 <span class="math inline">\(j\)</span> 的项视为常数，将含有 <span class="math inline">\(i\)</span> 的项视为变量（即使它本身应当是常数），然后进行移项，尝试用含 <span class="math inline">\(j\)</span> 的项表示出含 <span class="math inline">\(i\)</span> 的项。 <span class="math display">\[
a_i\cdot b_{j_1}+c_i+d_{j_1}\geq a_i\cdot b_{j_2}+c_i+d_{j_2},\\
a_i\cdot (b_{j_2}-b_{j_1})\leq d_{j_1}-d_{j_2},
\]</span></p>
<p>那么此时对于 <span class="math inline">\(b_{j_1},b_{j_2}\)</span> 的大小分类讨论（不考虑 <span class="math inline">\(b_{j_1}=b_{j_2}\)</span> 的情况）有 <span class="math display">\[
\begin{cases}
-a_i\geq\dfrac{d_{j_2}-d_{j_1}}{b_{j_2}-b_{j_1}},\qquad b_{j_2}&gt;b_{j_1},\\
-a_i\leq\dfrac{d_{j_2}-d_{j_1}}{b_{j_2}-b_{j_1}},\qquad b_{j_2}&lt;b_{j_1},\\\tag1\label{tag1}
\end{cases}
\]</span> 如果我们将决策点表示为 <span class="math inline">\((b_j,d_j)\)</span>，那么此时不等号右边是斜率式的形式。</p>
<p>考虑位置关系如下的三个决策点：</p>
<p><img src="https://pic.imgdb.cn/item/61d567bb2ab3f51d9151452a.jpg" /></p>
<p>设此时 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 两点之间的线段的斜率为 <span class="math inline">\(k_0\)</span>，我们对 <span class="math inline">\(-a_i\)</span> 进行分类讨论。</p>
<p>第一种情况是 <span class="math inline">\(k_0&gt;-a_i\)</span>，此时显然有 <span class="math inline">\(\overline {BC}\)</span> 的斜率 <span class="math inline">\(k_1&gt;k_0&gt;-a_i\)</span>，而根据 <span class="math inline">\(\eqref{tag1}\)</span>，如果 <span class="math inline">\(C\)</span> 比 <span class="math inline">\(B\)</span> 更优，应当有 <span class="math inline">\(k_1\leq-a_i\)</span>，矛盾，于是此时应当点 <span class="math inline">\(B\)</span> 更优。</p>
<p>第二种情况是 <span class="math inline">\(-a_i&gt;k_0\)</span>，此时显然有 <span class="math inline">\(\overline{AC}\)</span> 的斜率 <span class="math inline">\(k_2&lt;k_0&lt;-a_i\)</span>，根据 <span class="math inline">\(\eqref{tag1}\)</span>，如果 <span class="math inline">\(C\)</span> 比 <span class="math inline">\(A\)</span> 更优，应当有 <span class="math inline">\(k_1\geq-a_i\)</span>，矛盾产生，于是此时必然有点 <span class="math inline">\(A\)</span> 更优。</p>
<p>最后一种情况是 <span class="math inline">\(-a_i=k_0\)</span>，设此时有 <span class="math inline">\(k_2&lt;k_0=-a_i&lt;k_1\)</span>，于是 <span class="math inline">\(A,B\)</span> 两点都要比 <span class="math inline">\(C\)</span> 更优。</p>
<p>综上，我们可以知道，如果 <span class="math inline">\(C\)</span> 不在凸包上，那么在凸包上一定存在两点可以替代 <span class="math inline">\(C\)</span>。</p>
<p>同理，我们可以对于状态转移方程为 <span class="math inline">\(f_i=\max\limits_{0\leq j&lt;i}\{a_i\cdot b_j + c_i + d_j\}\)</span> 的决策进行证明。</p>
<h2 id="决策具有单调性">#2.0 决策具有单调性</h2>
<blockquote>
<p>这里以 <a href="https://www.luogu.com.cn/problem/P3195">「HNOI2008」玩具装箱</a> 作为例题。</p>
</blockquote>
<h3 id="转移方程及转化">#2.1 转移方程及转化</h3>
<p>设 <span class="math inline">\(f_i\)</span> 表示前 <span class="math inline">\(i\)</span> 个物品的最小代价，不难写出状态转移方程： <span class="math display">\[
f_{i}=\min\limits_{0\leq j&lt;i}\left\{f_j+\left(\sum\limits_{k=j+1}^{i}C_k+i-j-1-L\right)^2\right\},
\]</span> 设 <span class="math inline">\(S_i=i+\sum_{k=1}^iC_i,T=L+1\)</span>，将上式简写为 <span class="math display">\[
f_i=\min\limits_{0\leq j&lt;i}\{f_j+(S_i-S_j-T)^2\},
\]</span> 假设从决策点 <span class="math inline">\(j\)</span> 处转移，应当有 <span class="math display">\[
\begin{aligned}
f_i&amp;=f_j+(S_i-S_j-T)^2\\
&amp;=f_j+(S_i-T)^2-2S_j(S_i-T)+S_j^2\\
&amp;=f_j+(S_i-T)^2-2S_i\cdot S_j+2S_j\cdot T+S_j^2
\end{aligned}
\]</span> 我们将上面的式子转化为如下形式 <span class="math display">\[
f_j+2S_j\cdot T+S_j^2=2S_i\cdot S_j+f_i-(S_i-T)^2,
\]</span> 这正与 <a href="#sketch">#1.0 简述</a> 中的形式相对应，于是我们的目的是对于斜率 <span class="math inline">\(2S_i\)</span> 找到一个决策点 <span class="math inline">\((S_j,f_j+2S_j\cdot T+S_j^2)\)</span> 使得截距 <span class="math inline">\(f_i-(S_i-T)^2\)</span> 尽可能小。此时已经可以做到 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="决策单调性">#2.2 决策单调性</h3>
<p>我们注意到，<span class="math inline">\(C_i\)</span> 一定是一个正数，于是 <span class="math inline">\(2S_i\)</span> 一定单调递增，也意味着我们所需要的斜率一定是单调递增的，且对于所有决策点 <span class="math inline">\(j\)</span>，其在坐标系上的位置一定是从左到右依次排布的；由上文我们可以知道，可行的决策点一定在凸包上，而下凸包上的线段斜率一定是单调递增的，于是最优决策点应当具有单调性。</p>
<p>同样，这一点我们也可以采用 <a href="https://dfkuaid.github.io/2021/12/26/quadrangle/">四边形不等式</a> 进行证明。</p>
<p>我们将 <span class="math inline">\((S_i-S_j-T)^2\)</span> 作为 <span class="math inline">\(w(j,i)\)</span>，下面证明 <span class="math inline">\(w(j,i)\)</span> 满足四边形不等式：</p>
<p>要证明 <span class="math inline">\(w(j,i)\)</span> 满足四边形不等式，我们只需证明<sup><a href="#refer">[4]</a></sup> <span class="math inline">\(w(j,i)\)</span> 满足 <span class="math inline">\(\forall \ell&lt;r\)</span>，有 <span class="math display">\[
w(\ell, r)+w(\ell+1,r+1)\leq w(\ell,r+1)+w(\ell+1,r),\tag2\label{tag2}
\]</span> <strong>证明</strong>：</p>
<p>设 <span class="math inline">\(\ell&lt;r\)</span>，有 <span class="math display">\[
\begin{aligned}
w(\ell,r)=&amp;(S_r-S_{\ell}-T)^2,\\
w(\ell+1,r+1)=&amp;(S_{r+1}-S_{\ell+1}-T)^2=(S_r-S_\ell-T+C_{r+1}+r+1-C_{\ell+1}-\ell-1)\\
=&amp;(S_r-S_\ell-T)^2+(C_{r+1}+r+1-C_{\ell+1}-\ell-1)^2\\
&amp;+2(S_r-S_\ell-T)(C_{r+1}+r+1-C_{\ell+1}-\ell-1)\\
=&amp;(S_r-S_\ell-T)^2+(C_{r+1}+r+1-C_{\ell+1}-\ell-1)^2\\
&amp;+2(S_r-S_\ell-T)(C_{r+1}+r+1)-2(S_r-S_\ell-T)(C_{\ell+1}+\ell+1),\\
w(\ell,r+1)=&amp;(S_{r+1}-S_\ell-T)^2=(S_r-S_\ell+T+C_{r+1}+r+1)^2\\
=&amp;(S_r-S_\ell-T)^2+(C_{r+1}+r+1)^2+2(S_r-S_\ell-T)(C_{r+1}+r+1),\\
w(\ell+1,r)=&amp;(S_r-S_{\ell+1}-T)^2=(S_r-S_\ell+T-(C_{\ell+1}+\ell+1))^2\\
=&amp;(S_r-S_\ell-T)^2+(C_{\ell+1}+\ell+1)^2-2(S_r-S_\ell-T)(C_{\ell+1}+\ell+1),\\
\end{aligned}
\]</span> 于是，如果要证明 <span class="math inline">\(w(\ell, r)+w(\ell+1,r+1)\leq w(\ell,r+1)+w(\ell+1,r)\)</span>，只需证明 <span class="math display">\[
(C_{r+1}+r+1-C_{\ell+1}-\ell-1)^2\leq(C_{r+1}+r+1)^2+(C_{\ell+1}+\ell+1)^2,\tag3\label{tag3}
\]</span> 而又有 <span class="math display">\[
\begin{aligned}
(C_{r+1}+r+1-C_{\ell+1}-\ell-1)^2=&amp;(C_{r+1}+r+1)^2+(C_{\ell+1}+\ell+1)^2\\
&amp;-2(C_{r+1}+r+1)(C_{\ell+1}+\ell+1),
\end{aligned}
\]</span> 又因为 <span class="math inline">\(C_{r+1},C_{\ell+1},r,\ell\in\mathbb Z^*\)</span>，于是有 <span class="math display">\[
-2(C_{r+1}+r+1)(C_{\ell+1}+\ell+1)&lt;0,
\]</span> 于是有 <span class="math inline">\(\eqref{tag3}\)</span> 成立，便可得 <span class="math inline">\(\eqref{tag2}\)</span> 成立，于是 <span class="math inline">\(w(j,i)\)</span> 满足四边形不等式。</p>
<p align="right">
证毕.
</p>
<p>于是，我们已知 <span class="math inline">\(w(j,i)\)</span> 满足四边形不等式，便可以知道 <span class="math inline">\(f_i\)</span> 具有决策单调性<sup><a href="#refer">[5]</a></sup>。</p>
<p>我们便可以利用二分 + 类似单调队列的方式通过维护所有位置的可能最优决策点做到 <span class="math inline">\(O(n\log n)\)</span><sup><a href="#refer">[6]</a></sup>.</p>
<h3 id="最终实现">#2.3 最终实现</h3>
<p>事实上， 这道题目不仅具有决策单调性，上面利用决策单调性的时间复杂度中的 <span class="math inline">\(\log n\)</span> 是因为需要二分查找新的决策从什么时候开始作为可能的最优决策。</p>
<p>实际上， 本题不需要维护所有的最优决策点，我们还是回到斜率优化最富有内涵的图像上来，由于具有决策单调性，于是我们对于 <span class="math inline">\(i_1&lt;i_2\)</span>，所有在 <span class="math inline">\(i_1\)</span> 的最优决策点前的决策点对于 <span class="math inline">\(i_2\)</span> 都不是最优的，可以直接丢掉，这样将不合法的决策点删掉后，在最左边位置的决策点一定是最优决策点；而将 <span class="math inline">\(i_1\)</span> 作为新决策点加入图像时，该决策点一定只会在右端加入且一定会加入，直接根据凸包的性质将右端不合法的决策点删去就可以了，于是我们可以直接有单调队列进行维护可能还有用的部分凸包，由于每个决策点最多只会入队、出队各一次，转移的时间复杂度为 <span class="math inline">\(O(1)\)</span>，于是整体的均摊时间复杂度为 <span class="math inline">\(O(n)\)</span>.</p>
<div class="tabs" id="code---1"><ul class="nav-tabs"><li class="tab"><a href="#code---1-1">参考代码</a></li></ul><div class="tab-content"><div class="tab-pane" id="code---1-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q[N], frt = <span class="number">0</span>, tal =  <span class="number">-1</span>; ll L, c[N], s[N], f[N], val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (val[y] - val[x]) / (s[y] - s[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(L); L += <span class="number">1</span>, q[++ tal] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] = s[i - <span class="number">1</span>] + c[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] += i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (frt &lt; tal &amp;&amp; <span class="built_in">slope</span>(q[frt], q[frt + <span class="number">1</span>]) &lt; <span class="number">2</span> * s[i]) ++ frt;</span><br><span class="line">        f[i] = val[q[frt]] - <span class="number">2</span> * s[i] * s[q[frt]] + (s[i] - L) * (s[i] - L);</span><br><span class="line">        val[i] = f[i] + <span class="number">2</span> * s[i] * L + s[i] * s[i];</span><br><span class="line">        <span class="keyword">while</span> (frt &lt; tal &amp;&amp; <span class="built_in">slope</span>(q[tal - <span class="number">1</span>], q[tal]) &gt;= <span class="built_in">slope</span>(q[tal - <span class="number">1</span>], i)) -- tal;</span><br><span class="line">        q[++ tal] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="决策无特殊性质">#3.0 决策无特殊性质</h2>
<blockquote>
<p>这里以 <a href="https://loj.ac/p/2353">「 NOI2007」货币兑换</a> 作为例题。</p>
</blockquote>
<h3 id="转移方程及转化-1">#3.1 转移方程及转化</h3>
<blockquote>
<p><strong>题目提示</strong>：必然存在一种最优的买卖方案满足：每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券。</p>
</blockquote>
<p>设 <span class="math inline">\(f_i\)</span> 表示到第 <span class="math inline">\(i\)</span> 天可以拥有的最大钱数，先写出一个大概的转移方程 <span class="math display">\[
f_i=\max\limits_{0&lt;j&lt;i}\{num_A\cdot a_i+num_B\cdot b_i\},
\]</span> 其中 <span class="math inline">\(num_A\)</span> 与 <span class="math inline">\(num_B\)</span> 分别表示持有的 <span class="math inline">\(A\)</span> 金卷的数量与 <span class="math inline">\(B\)</span> 金卷的数量，这两个数由 <span class="math inline">\(j\)</span> 决定。显然，第 <span class="math inline">\(j\)</span> 天买入时，能得到的金卷比例是一定的，于是当天买入时拥有的钱数越大越好，也就是 <span class="math inline">\(f_j\)</span>，应当有 <span class="math display">\[
\begin{aligned}
f_j&amp;=num_A\cdot a_j+num_B\cdot b_j\\
f_j&amp;=num_B\cdot R_j\cdot a_j+num_B\cdot b_j\\
num_B&amp;=\dfrac{f_j}{R_j\cdot a_j+b_j},
\end{aligned}
\]</span> 同理可得 <span class="math display">\[
num_A=\dfrac{f_j\cdot R_j}{R_j\cdot a_j+b_j},
\]</span> 于是我们可以写出完整的状态转移方程 <span class="math display">\[
f_i=\max\limits_{0&lt;j&lt;i}\left\{\dfrac{f_j\cdot R_j}{R_j\cdot a_j+b_j}\cdot a_i+\dfrac{f_j}{R_j\cdot a_j+b_j}\cdot b_i\right\},
\]</span> 注意到，转移方程中包含与 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 同时相关的项，优先考虑斜率优化，考虑从决策点 <span class="math inline">\(j\)</span> 转移，有 <span class="math display">\[
f_i=\dfrac{f_j\cdot R_j}{R_j\cdot a_j+b_j}\cdot a_i+\dfrac{f_j}{R_j\cdot a_j+b_j}\cdot b_i,
\]</span> 即 <span class="math display">\[
\begin{aligned}
\dfrac{f_i}{b_i}&amp;=\dfrac{f_j\cdot R_j}{R_j\cdot a_j+b_j}\cdot \dfrac{a_i}{b_i}+\dfrac{f_j}{R_j\cdot a_j+b_j}\\
\dfrac{f_j}{R_j\cdot a_j+b_j}&amp;=-\dfrac{a_i}{b_i}\cdot\dfrac{f_j\cdot R_j}{R_j\cdot a_j+b_j}+\dfrac{f_i}{b_i},
\end{aligned}
\]</span> 此时，这个柿子就与我们上面的形式相吻合了，决策点在坐标系上的表示为 <span class="math inline">\(\left(\frac{f_j\cdot R_j}{R_j\cdot a_j+b_j},\frac{f_j}{R_j\cdot a_j+b_j}\right)\)</span>.</p>
<p>一个悲哀的事情出现了，这个式子并没有什么优美的性质，于是实现的恶心程度就上了天。</p>
<h3 id="直接维护凸包">#3.2 直接维护凸包</h3>
<p>首先是最朴素的方式，即采用平衡树维护整个凸包。</p>
<p>查找时，我们可以使用 <a href="#sketch">#1.0 简述</a> 提到的结论，利用二分查找找到以 <span class="math inline">\(-\frac{a_i}{b_i}\)</span> 为斜率的直线在凸包上的切点。</p>
<p>至于修改时，我们可以先找到它应该插入的位置（凸包上横坐标在其左右的两个紧邻的决策点），然后利用<strong>向量叉积</strong>来确定当前点是否在当前维护的上凸包以下，如果是，那么直接返回即可；否则从找到的相邻决策点开始删掉不合法的点即可。</p>
<p>这种做法虽然比较好理解，但是实现较为繁琐，且难以直接套用 STL 的 <code>set</code>。</p>
<h3 id="cdq-分治">#3.3 CDQ 分治</h3>
<p><span class="math inline">\(\text{CDQ}(\ell, r)\)</span> 表示计算 <span class="math inline">\(f_i,i\in[\ell, r]\)</span>，设 <span class="math inline">\(mid= \left\lfloor\frac{1+ n}2\right\rfloor\)</span>，那么考虑 <span class="math inline">\(\text{CDQ}(1,n)\)</span>，有</p>
<p>对于 <span class="math inline">\(i\in[1, mid]\)</span>，我们直接调用 <span class="math inline">\(\text{CDQ}(1, mid)\)</span> 进行计算，得到这一部分的答案，然后显然 <span class="math inline">\(i\in [1,mid]\)</span> 这一部分的所有转移点组成的凸壳已经被计算出来了，于是我们考虑 <span class="math inline">\([1,mid]\)</span> 对于 <span class="math inline">\([mid+1,n]\)</span> 中的贡献，可以直接建出凸包，然后挨个二分，但是这样实现复杂度又上了一个台阶，于是我们可以先对所有决策点的横坐标排序，再利用栈进行凸包的建立（只需要考虑最右边斜率），注意到凸包上的斜率是单调的，于是然后将 <span class="math inline">\([mid+1,r]\)</span> 中的所有目标斜率进行排序，利用单调队列进行求解。</p>
<p>再来考虑 <span class="math inline">\(i\in[mid +1,n]\)</span>，显然最优决策点在 <span class="math inline">\([1,mid]\)</span> 中的点都已经被更新过了，于是 <span class="math inline">\([1,mid]\)</span> 这一部分的斜率都已经没用了，可以直接被扔掉；然后直接调用 <span class="math inline">\(\text{CDQ}(mid + 1,n)\)</span> 即可。</p>
<div class="tabs" id="code---2"><ul class="nav-tabs"><li class="tab"><a href="#code---2-1">参考代码</a></li></ul><div class="tab-content"><div class="tab-pane" id="code---2-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T x, T y)</span> </span>&#123;<span class="keyword">return</span> x &gt; y ? x : y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    ld x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Point</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Point</span><span class="params">(ld _x, ld _y)</span> </span>&#123;x = _x, y = _y;&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x == b.x ? y &lt; b.y : x &lt; b.x;&#125;</span><br><span class="line">    <span class="keyword">inline</span> ld <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Point b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125;</span><br><span class="line">    <span class="keyword">inline</span> Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x - b.x, y - b.y);&#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s, tmp[N], q[N], slp[N], slp_cp[N]; ld f[N], slope[N], a[N], b[N], r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> f[x] / (r[x] * a[x] + b[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Y</span>(x) * r[x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> p[x].x == p[y].x ? p[x].y &lt; p[y].y : p[x].x &lt; p[y].x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> slope[x] &gt; slope[y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="title">get_slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (p[x].y - p[y].y) / (p[x].x - p[y].x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> p[y].x * a[x] + p[y].y * b[x];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">illegal</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> ((p[y] - p[x2]) ^ (p[x1] - p[x2])) &gt;= <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y) &#123;f[x] = <span class="built_in">Max</span>(f[x], f[x - <span class="number">1</span>]), p[x] = <span class="built_in">Point</span>(<span class="built_in">X</span>(x), <span class="built_in">Y</span>(x)); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = x + y &gt;&gt; <span class="number">1</span>, frt = <span class="number">0</span>, tal = <span class="number">-1</span>; <span class="built_in">cdq</span>(x, mid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= y; ++ i) slp_cp[i] = slp[i];</span><br><span class="line">    <span class="built_in">sort</span>(tmp + x, tmp + mid + <span class="number">1</span>, cmp1);</span><br><span class="line">    <span class="built_in">sort</span>(slp_cp + mid + <span class="number">1</span>, slp_cp + y + <span class="number">1</span>, cmp2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= mid; ++ i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (frt &lt; tal &amp;&amp; <span class="built_in">illegal</span>(q[tal - <span class="number">1</span>], q[tal], tmp[i])) -- tal;</span><br><span class="line">        q[++ tal] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= y; ++ i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (frt &lt; tal &amp;&amp; <span class="built_in">get_slope</span>(q[frt], q[frt + <span class="number">1</span>]) &gt; slope[slp_cp[i]]) ++ frt;</span><br><span class="line">        f[slp_cp[i]] = <span class="built_in">Max</span>(f[slp_cp[i]], <span class="built_in">calc</span>(slp_cp[i], q[frt]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(mid + <span class="number">1</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(s); f[<span class="number">1</span>] = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%Lf%Lf%Lf&quot;</span>, &amp;a[i], &amp;b[i], &amp;r[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) slope[i] = - a[i] / b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) slp[i] = i, tmp[i] = i;</span><br><span class="line">    <span class="built_in">cdq</span>(<span class="number">1</span>, n); <span class="built_in">printf</span>(<span class="string">&quot;%.3Lf&quot;</span>, f[n]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>
<div id="refer">

</div>
<h2 id="参考文章">参考文章</h2>
<ul>
<li>[1] <a href="https://oi-wiki.org/dp/opt/slope/">斜率优化 - OI Wiki</a></li>
<li>[2] <a href="https://www.cnblogs.com/Xing-Ling/p/11210179.html">【学习笔记】动态规划—斜率优化DP（超详细）- 辰星凌</a></li>
<li>[3] <a href="https://www.cnblogs.com/29taorz/p/15745276.html">斜率优化 - T_X蒻</a></li>
<li>[4] [5] [6] <a href="https://dfkuaid.github.io/2021/12/26/quadrangle/">「DP 浅析」四边形不等式优化 - Dfkuaid</a></li>
<li>[7] <a href="https://dfkuaid.github.io/2022/01/22/LiChao-Tree/">「数据结构」李超线段树 - Dfkuaid</a></li>
</ul>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>「算法相关」WQS 二分</title>
    <url>/2022/01/02/wqs-bisect/</url>
    <content><![CDATA[<h2 id="简述">简述</h2>
<h3 id="闲话">闲话</h3>
<p>wqs 二分最初由王钦石在他的 2012 年国家集训队论文中提出，而从 IOI 2016 的 <a href="https://ioinformatics.org/files/ioi2016problem6.pdf">Aliens</a> 题目开始，这种方法开始逐步在竞赛圈中有了一定的地位。在国内我们一般称为「wqs 二分」，而在国外一般称为「Alien Trick」。</p>
<h3 id="常见适用范围">常见适用范围</h3>
<p>应用 wqs 二分的一种常见的问题形式为：给定一些带有价值的物品，价值可以为负，对于物品的选择具有一定限制，求选定物品总价值最大/最小值。</p>
<h2 id="大致思想">大致思想</h2>
<h3 id="屑在前面">屑在前面</h3>
<p>为了方便下面的讲解，这里结合例题 <a href="https://www.luogu.com.cn/problem/P2619">Tree I</a> 来进行讲解。</p>
<blockquote>
<p>题目大意：有一张无向带权连通图，每条边要么是黑色要么是白色，现指定要找到一棵恰有 <span class="math inline">\(N\)</span> 条白边的最小生成树，输出最小边权和。</p>
</blockquote>
<p>首先，我们将这个题面与上面的适用范围进行对号入座，“带权边”是“有价值的物品”，“恰有 <span class="math inline">\(N\)</span> 条白边”和“生成树”都是“限制”，“最小生成树”意味着求最小值。</p>
<h3 id="设计函数">设计函数</h3>
<p>我们首先设计函数 <span class="math inline">\(f(x)\)</span> 表示当恰选择 <span class="math inline">\(x\)</span> 条白边时的最小生成树权值和，容易发现在一个定值 <span class="math inline">\(x=c\)</span> 前 <span class="math inline">\(f(x)\)</span> 一定是单调递减的，因为此时存在一条白边的权值小于选定边集中的黑边最大边权，于是此时随着需要的白边的数量增长，一定可以用边权更小的白边换掉边权较大的黑边，使得总边权变小；达到 <span class="math inline">\(c\)</span> 后，每次用白边替换黑边一定会使得总的边权和变大，于是之后函数应当是单调递增的，可以看出函数图像应当是一个下凸壳，于是函数图像应当大致如下：</p>
<p><img src="https://pic.imgdb.cn/item/61d23d092ab3f51d91ff3499.png" /></p>
<p>而且显然有 <span class="math display">\[
\forall x_1&lt;x_2&lt;x_3,\quad \dfrac{f(x_1)-f(x_2)}{x_1-x_2}&lt;\dfrac{f(x_2)-f(x_3)}{x_2-x_3}
\]</span> 这一点考虑 <span class="math inline">\(f(x)\)</span> 的定义并采用反证法证明不难。也就意味着图像雀雀食食是下凸壳。</p>
<h3 id="利用图像">利用图像</h3>
<p>现在我们得到了一个下凸壳，那么我们该如何利用呢？我们知道，对于任意一个斜率，一定最多有一条为该斜率的直线与凸壳相切与某一点；而且可以发现，对于本题的凸壳，斜率越小，对应的切点的横坐标一定越小，因而我们可以尝试二分这个斜率，来尝试得到这个切点，假设我们能够求得对应的 <span class="math inline">\(x\)</span> 及 <span class="math inline">\(f(x)\)</span>，我们就可以确定下一步二分的斜率应该更大还是更小，并得到对应的最小值。</p>
<p>那么，我们就需要知道如何计算 <span class="math inline">\(x\)</span> 及 <span class="math inline">\(f(x)\)</span>。首先，我们知道一个下凸壳的性质：对于同一斜率 <span class="math inline">\(k\)</span> 的直线过凸壳上一点，过切点的直线的纵轴截距最小，如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/61d2465d2ab3f51d9103ad04.jpg" /></p>
<p>根据直线方程，不难得到该截距为 <span class="math display">\[
g(x)=f(x)-k\cdot x,
\]</span> 意味着 <span class="math inline">\(g(x)\)</span> 为选取 <span class="math inline">\(x\)</span> 条白边时，每条白边价值减 <span class="math inline">\(k\)</span> 后，此时能拿到的最优解。</p>
<p>这里给出一个性质：切点上的 <span class="math inline">\(g(x)\)</span> 为每一条白边价值减去 <span class="math inline">\(k\)</span> 后，没有额外限制（即不限制白边数量）选取得到的全局最优解。</p>
<p>这个结论看起来总觉得怪怪的，给人一种想推翻它的冲动，但是我们来看：对于任意一点 <span class="math inline">\((x,f(x))\)</span>，对应的是选取恰好 <span class="math inline">\(x\)</span> 个白边时对应的最优解，加入我们将所有边的边权都减少 <span class="math inline">\(k\)</span>，显然任意两条边之间的相对大小关系是不变的，那么选择的边集并不会改变，于是这个最优解就变为了 <span class="math inline">\(f(x)-k\cdot x\)</span>，也就是 <span class="math inline">\(g(x)\)</span>，也就是直线的纵轴截距；而根据我们上面提到的下凸壳的性质，我们可以知道，过切点 <span class="math inline">\((a,f(a))\)</span> 的直线的纵轴截距一定是所有截距中最小的，也就是所有 <span class="math inline">\(g(x)\)</span> 中最小的，于是也就是不加限制选择白边的最优解，注意得到该最优解需要选出的白边数量一定是 <span class="math inline">\(a\)</span>，而加上 <span class="math inline">\(k\cdot a\)</span> 得到的就是 <span class="math inline">\(f(a)\)</span>.</p>
<p>于是我们就可以在每一次二分斜率 <span class="math inline">\(k\)</span> 后，直接求出当前每个白边边权减小 <span class="math inline">\(k\)</span> 后任意选的最优解，同时记录最优解需要的白边数量 <span class="math inline">\(x\)</span>，再把价值加上 <span class="math inline">\(k\cdot x\)</span> 就得到了所需的数据。</p>
<h3 id="细节处理">细节处理</h3>
<p>事实上，真实的图像有可能是这样的：</p>
<p><img src="https://pic.imgdb.cn/item/61d24f6e2ab3f51d9108b9d5.jpg" /></p>
<p>注意到，图中的点 <span class="math inline">\(I\)</span> 是无法被直线恰好切到的，因为它两边的直线的斜率相等，那么该如何处理？</p>
<p>我们可以使每次选取边时，对于权值相同的边，优先选白边，这样，我们得到的“切点”就是点 <span class="math inline">\(F\)</span>，在二分时我们保存的直线的斜率应当是满足需要的白边数大于等于 <span class="math inline">\(N\)</span> 中的最小斜率，这样我们可以保证得到的斜率 <span class="math inline">\(k\)</span> 正确，一定可以得到正确的纵轴截距，最后单独加上 <span class="math inline">\(k\cdot N\)</span> 即可。</p>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, w, col;&#125; e[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N], siz[N], cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">UnionSet</span><span class="params">()</span> </span>&#123;cnt = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;cnt = <span class="number">0</span>; <span class="keyword">while</span> (cnt &lt;= x) fa[cnt] = cnt, siz[cnt ++] = <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span> (x != fa[x]) x = fa[x] = fa[fa[x]]; <span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (siz[x] &gt; siz[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        fa[x] = y, siz[y] += siz[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; us;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ned, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge x, Edge y)</span> </span>&#123;<span class="keyword">return</span> x.w == y.w ? x.col &lt; y.col : x.w &lt; y.w;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kruscal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wcnt = <span class="number">0</span>; us.<span class="built_in">init</span>(n); ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (us.<span class="built_in">connected</span>(e[i].u, e[i].v)) <span class="keyword">continue</span>;</span><br><span class="line">        us.<span class="built_in">unify</span>(e[i].u, e[i].v);</span><br><span class="line">        wcnt += !e[i].col, ans += e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wcnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">      e[i].w -= e[i].col ? <span class="number">0</span> : x;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">kruscal</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">      e[i].w += e[i].col ? <span class="number">0</span> : x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(ned);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">      <span class="built_in">read</span>(e[i].u), <span class="built_in">read</span>(e[i].v), <span class="built_in">read</span>(e[i].w), <span class="built_in">read</span>(e[i].col);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">-100</span>, r = <span class="number">100</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid) &lt; ned) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> res = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">check</span>(res); <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans + res * ned); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单总结">简单总结</h2>
<p>从上面的过程不难看出， wqs 二分适用于价值函数为上/下凸壳的情况，可以巧妙地将原本选择的部分限制去掉，从而优化算法。</p>
<p>同时如果遇到了图像上的一些特殊情况，可以对 <code>check()</code> 与二分函数进行简单的修改，从而达到所要的效果。</p>
<div id="refer">

</div>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/340514421">wqs 二分学习笔记 - 菠萝头</a></li>
<li><a href="https://www.cnblogs.com/TianMeng-hyl/p/14972355.html">wqs 二分浅谈 - hyl天梦</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
        <tag>二分</tag>
        <tag>WQS 二分</tag>
      </tags>
  </entry>
  <entry>
    <title>「DP 浅析」四边形不等式优化</title>
    <url>/2021/12/26/quadrangle/</url>
    <content><![CDATA[<blockquote>
<p>下面的证明的思想多数为<strong>数学归纳</strong>、<strong>分类讨论</strong>或<strong>反证法</strong>。</p>
</blockquote>
<h2 id="简述">简述</h2>
<p>定义 <span class="math inline">\(w(i,j)\)</span> 为一个定义在 <span class="math inline">\(\mathbb{Z}\)</span> 上的二元函数，有如下定义：</p>
<p><strong>定义 1</strong>：如果对于任意 <span class="math inline">\(\ell_1\leq \ell_2\leq r_1\leq r_2\)</span>，都有 <span class="math display">\[
w(\ell_1,r_1)+w(\ell_2,r_2)\leq w(\ell_1,r_2)+w(\ell_2,r_1)
\]</span> 成立，那么称 <span class="math inline">\(w\)</span> 满足<strong>四边形不等式</strong>（即“交叉小于包含”），如果等号始终成立，那么称 <span class="math inline">\(w\)</span> 满足<strong>四边形恒等式</strong>。</p>
<p><strong>定义 2</strong>：如果对于任意 <span class="math inline">\(\ell\leq\ell&#39;\leq r&#39;\leq r\)</span>，都有 <span class="math inline">\(w(\ell,r)\geq w(\ell&#39;,r&#39;)\)</span> 成立，那么则称 <span class="math inline">\(w\)</span> <strong>对于区间包含关系具有单调性</strong>。</p>
<p><strong>定理 1</strong>：如果对于定义域上任意 <span class="math inline">\(\ell&lt;r\)</span>，都有 <span class="math display">\[
w(\ell, r)+w(\ell+1,r+1)\leq w(\ell,r+1) + w(\ell+1,r)
\]</span> 成立，那么 <span class="math inline">\(w(\ell,r)\)</span> 满足四边形不等式。</p>
<p><strong>证明</strong>：先来证明对于任意 <span class="math inline">\(\ell_1\leq\ell_2\leq r_1\)</span>，都有 <span class="math display">\[
w(\ell_1,r_1)+w(\ell_2,r_1+1)\leq w(\ell_1,r_1+1)+w(\ell_2,r_1).\tag1
\]</span> 对于 <span class="math inline">\(i=\ell_2-\ell_1\)</span> 进行归纳，显然当 <span class="math inline">\(i=0\)</span> 时上式成立，下面证明对 <span class="math inline">\(i\in[1,r_1-\ell_1]\)</span> 成立。</p>
<p>首先根据归纳假设，有 <span class="math display">\[
w(\ell_1,r_1)+w(\ell_1+i-1,r_1+1)\leq w(\ell_1,r_1+1)+w(\ell_1+i-1,r_1),\tag2
\]</span> 因为 <span class="math inline">\(i\leq r_1-\ell_1\)</span>，于是有 <span class="math inline">\(\ell_1+i-1&lt;r_1\)</span>，应当有 <span class="math display">\[
w(\ell_1+i-1,r_1)+w(\ell_1+i,r_1+1)\leq w(\ell_i+i,r_1)+w(\ell_1+i-1,r_1+1),\tag3
\]</span> 将 <span class="math inline">\((2)\)</span> 与 <span class="math inline">\((3)\)</span> 左右两边分别相加，于是有 <span class="math display">\[
w(\ell_1,r_1)+w(\ell_1+i,r_1+1)\leq w(\ell_1+1,r_1+1)+w(\ell_1+i,r_1),
\]</span> 于是对于 <span class="math inline">\(\forall\ell_1,\ell_2,r_1\in\mathbb Z,\ell_1\leq\ell_2\leq r_1\)</span>，<span class="math inline">\((1)\)</span> 都成立。</p>
<p>在上面的基础上，我们再来证明对于 <span class="math inline">\(\forall\ell_1,\ell_2,r_1,r_2\in\mathbb Z,\ell_1\leq\ell_2\leq r_1\leq r_2\)</span>，都有四边形不等式成立。同理，对 <span class="math inline">\(j=r_2-r_1\)</span> 进行归纳，显然当 <span class="math inline">\(j=0\)</span> 时四边形不等式成立，下面对于 <span class="math inline">\(j&gt;0\)</span> 的情况进行证明。</p>
<p>首先根据归纳假设，有 <span class="math display">\[
w(\ell_1,r_1)+w(\ell_2,r_1+j-1)\leq w(\ell_1,r_1+j-1)+w(\ell_2,r_1),\tag4
\]</span> 因为 <span class="math inline">\(r_1+j-1\geq\ell_2\geq\ell_1\)</span>，根据 <span class="math inline">\((1)\)</span>，应当有 <span class="math display">\[
w(\ell_1,r_1+j-1)+w(\ell_2,r_1+j)\leq w(\ell_1,r_1+j)+w(\ell_2,r_1+j-1)\tag5
\]</span> 将 <span class="math inline">\((4)\)</span> 与 <span class="math inline">\((5)\)</span> 左右两边分别相加可得 <span class="math display">\[
w(\ell_1,r_1)+w(\ell_2,r_1+j)\leq w(\ell_1,r_1+j)+w(\ell_2,r_1),
\]</span> 于是假设成立，即四边形不等式成立。</p>
<div data-align="right">
证毕.
</div>
<h2 id="应用">应用</h2>
<h3 id="优化-2d1d-动态规划">优化 2D1D 动态规划</h3>
<h4 id="区间型-dp">区间型 DP</h4>
<p>常见的一种动态规划的状态转移方程为 <span class="math display">\[
f_{\ell,r}=\min\limits_{\ell\leq k&lt;r}\{f_{\ell,k}+f_{k+1,r}\}+w(\ell, r), \qquad(1\leq\ell&lt;r\leq n)
\]</span> 直接简单实现上面的转移，那么时间复杂度为 <span class="math inline">\(O(n^3)\)</span>，如果 <span class="math inline">\(w(l,r)\)</span> 满足一些特殊性质，那么我们可以用四边形不等式对其进行优化。</p>
<p><strong>定理 2</strong>：如果 <span class="math inline">\(w(\ell, r)\)</span> 满足四边形不等式且对于区间包含关系具有单调性，那么状态 <span class="math inline">\(f_{l,r}\)</span> 满足四边形不等式。</p>
<p><strong>证明</strong>：定义 <span class="math inline">\(g_{k,\ell,r}=f_{\ell,k}+f_{k+1,r}+w(\ell, r)\)</span>，表示决策点为 <span class="math inline">\(k\)</span> 时的状态值，任取 <span class="math inline">\(\ell_1\leq\ell_2\leq r_1\leq r_2\)</span>，记 <span class="math inline">\(u=\mathop{\arg\min}\limits_{\ell_1\leq k&lt;r_2}\ g_{k,\ell_1,r_2},v=\mathop{\arg\min}\limits_{\ell_2\leq k&lt;r_1}\ g_{k,\ell_2,r_1}\)</span>，分别表示 <span class="math inline">\(f_{\ell_1,r_2}\)</span> 和 <span class="math inline">\(f_{\ell_2,r_1}\)</span> 的最小最优决策点。</p>
<p>首先，如果 <span class="math inline">\(\ell_1=\ell_2\)</span>，那么显然成立，然后考虑对于 <span class="math inline">\(r_2-r_1\)</span> 进行归纳，显然当 <span class="math inline">\(r_2-r_1=0\)</span> 时成立。</p>
<ul>
<li><p><span class="math inline">\(\ell_1&lt;\ell_2=r_1&lt;r_2\)</span> （<span class="math inline">\(w\)</span> 需要对于区间包含关系具有单调性）</p>
<ul>
<li><p>若 <span class="math inline">\(u&lt;r_1\)</span>，则 <span class="math inline">\(f_{\ell_1,r_1}\leq f_{\ell_1,u}+f_{u+1,r_1}+w(\ell_1,r_1)\)</span>，根据归纳假设，有 <span class="math inline">\(f_{u+1,r_1}+f_{\ell_2,r_2}\leq f_{u+1,r_2}+f_{\ell_2,r_1}\)</span>，两式相加即得 <span class="math display">\[
f_{\ell_1,r_1}+f_{\ell_2,r_2}\leq f_{u+1,r_2}+f_{\ell_2,r_1}+f_{\ell_1,u}+w(\ell_1,r_1)\leq f_{\ell_2,r_1}+f_{\ell_1,r_2}
\]</span></p></li>
<li><p>若 <span class="math inline">\(u\geq r_1\)</span>，则 <span class="math inline">\(f_{\ell_2,r_2}\leq f_{\ell_2,u}+f_{u+1,r_2}+w(\ell_2,r_2)\)</span>，根据归纳假设，有 <span class="math inline">\(f_{\ell_1,r_1}+f_{\ell_2,u}\leq f_{\ell_1,u}+f_{\ell_2,r_1}\)</span>，两式相加即得 <span class="math display">\[
f_{\ell_1,r_1}+f_{\ell_2,u}\leq f_{\ell_1,u}+f_{\ell_2,r_1}+f_{u+1,r_2}+w(\ell_2,r_2)\leq f_{\ell_2,r_1}+f_{\ell_1,r_2}
\]</span></p></li>
</ul></li>
<li><p><span class="math inline">\(\ell_1&lt;\ell_2&lt;r_1&lt;r_2\)</span>（<span class="math inline">\(w\)</span> 仅需满足四边形不等式）</p>
<ul>
<li><p>若 <span class="math inline">\(u\leq v\)</span>，则 <span class="math inline">\(l_1\leq u&lt; r_1,\ l_2\leq v&lt; r_2\)</span>，因此</p>
<p><span class="math display">\[
    \begin{aligned}
        f_{l_1,r_1} \leq g_{u,l_1,r_1} &amp;= f_{l_1,u} + f_{u+1,r_1} + w(l_1,r_1) \\
        f_{l_2,r_2} \leq g_{v,l_2,r_2} &amp;= f_{l_2,v} + f_{v+1,r_2} + w(l_2,r_2)
    \end{aligned}
\]</span></p>
<p>再由 <span class="math inline">\(u+1 \leq v+1 \leq r_1 \leq r_2\)</span> 和归纳假设知</p>
<p><span class="math display">\[
f_{u+1,r_1} + f_{v+1,r_2} \leq f_{u+1,r_2} + f_{v+1,r_1}
\]</span></p>
<p>将前两个不等式累加，并将第三个不等式代入，可得</p>
<p><span class="math display">\[
\begin{aligned}
    f_{l_1,r_1} + f_{l_2,r_2} &amp; \leq f_{l_1,u} + f_{l_2,v} + f_{u+1,r_1} + f_{v+1,r_2} + w(l_1,r_1) + w(l_2,r_2) \\
    &amp; \leq g_{u,l_1,r_2} + g_{v,l_2,r_1} = f_{l_1,r_2} + f_{l_2,r_1}
\end{aligned}
\]</span></p></li>
<li><p>若 <span class="math inline">\(v&lt; u\)</span>，则 <span class="math inline">\(l_1\leq v&lt;r_1,l_2\leq u&lt;r_2\)</span>，因此 <span class="math display">\[
\begin{aligned}
f_{l_1,r_1} \leq g_{v,l_1,r_1} &amp;= f_{l_1,v} + f_{v+1,r_1} + w(l_1,r_1) \\
f_{l_2,r_2} \leq g_{u,l_2,r_2} &amp;= f_{l_2,u} + f_{u+1,r_2} + w(l_2,r_2)
\end{aligned}
\]</span></p>
<p>再由 <span class="math inline">\(l_1 \leq l_2 \leq v \leq u\)</span> 和归纳假设知</p>
<p><span class="math display">\[
f_{l_1,v} + f_{l_2,u} \leq f_{l_1,u} + f_{l_2,v}
\]</span></p>
<p>将前两个不等式累加，并将第三个不等式代入，可得</p>
<p><span class="math display">\[
\begin{aligned}
f_{l_1,r_1} + f_{l_2,r_2} &amp; \leq f_{l_1,u} + f_{l_2,v} + f_{v+1,r_1} + f_{u+1,r_2} + w(l_1,r_2) + w(l_2,r_1) \\
&amp; \leq g_{u,l_1,r_2} + g_{v,l_2,r_1} = f_{l_1,r_2} + f_{l_2,r_1}
\end{aligned}
\]</span></p></li>
</ul></li>
</ul>
<p>综上所述，两种情形均有 <span class="math inline">\(f_{l_1,r_1} + f_{l_2,r_2} \leq f_{l_1,r_2} + f_{l_2,r_1}\)</span>，即四边形不等式成立。</p>
<div data-align="right">
证毕.
</div>
<p><strong>定理 3</strong>：若状态 <span class="math inline">\(f\)</span> 满足四边形不等式，记 <span class="math inline">\(m_{l,r}=\min\{k:f_{l,r} = g_{k,l,r}\}\)</span> 表示最优决策点，则有 <span class="math display">\[
m_{l,r-1} \leq m_{l,r} \leq m_{l+1,r} \qquad (l + 1 &lt; r)
\]</span></p>
<p><strong>证明</strong>：记 <span class="math inline">\(u = m_{l,r},\ k_1=m_{l,r-1},\ k_2=m_{l+1,r}\)</span>，分情况讨论：</p>
<ul>
<li><p>若 <span class="math inline">\(k_1&gt;u\)</span>，则 <span class="math inline">\(u+1 \leq k_1+1 \leq r-1 \leq r\)</span>，因此根据四边形不等式有</p>
<p><span class="math display">\[
f_{u+1,r-1} + f_{k_1+1,r} \leq f_{u+1,r} + f_{k_1+1,r-1}
\]</span></p>
<p>再根据 <span class="math inline">\(u\)</span> 是状态 <span class="math inline">\(f_{l,r}\)</span> 的最优决策点可知</p>
<p><span class="math display">\[
f_{l,u} + f_{u+1,r} \leq f_{l,k_1} + f_{k_1+1, r}
\]</span></p>
<p>将以上两个不等式相加，得</p>
<p><span class="math display">\[
f_{l,u} + f_{u+1,r-1} \leq f_{l,k_1}+f_{k_1+1,r-1}
\]</span></p>
<p>即 <span class="math inline">\(g_{u,l,r-1} \leq g_{k_1,l,r-1}\)</span>，但这与 <span class="math inline">\(k_1\)</span> 是最小的最优决策点矛盾，因此 <span class="math inline">\(k_1\leq u\)</span>。</p></li>
<li><p>若 <span class="math inline">\(u&gt;k_2\)</span>，则 <span class="math inline">\(l\leq l+1 \leq k_2\leq u\)</span>，根据四边形不等式可得</p>
<p><span class="math display">\[
f_{l,k_2} + f_{l+1,u} \leq f_{l,u} + f_{l+1, k_2}
\]</span></p>
<p>再根据 <span class="math inline">\(k_2\)</span> 是状态 <span class="math inline">\(f_{l+1, r}\)</span> 的最优决策点可知</p>
<p><span class="math display">\[
f_{l+1,k_2} + f_{k_2+1, r} \leq f_{l+1,u} + f_{u+1,r}
\]</span></p>
<p>将以上两个不等式相加，得</p>
<p><span class="math display">\[
f_{l,k_2}+f_{k_2+1,r} \leq f_{l,u} + f_{u+1,r}
\]</span></p>
<p>即 <span class="math inline">\(g_{k_2,l,r} \leq g_{u,l,r}\)</span>，但这与 <span class="math inline">\(u\)</span> 是最小的最优决策点矛盾，因此 <span class="math inline">\(u \leq k_2\)</span>。</p></li>
</ul>
<div data-align="right">
证毕.
</div>
<p>因此，如果在计算状态 <span class="math inline">\(f_{l,r}\)</span> 的同时将其最优决策点 <span class="math inline">\(m_{l,r}\)</span> 记录下来，那么我们对决策点 <span class="math inline">\(k\)</span> 的总枚举量将降为 <span class="math display">\[
\sum_{1\leq l&lt;r\leq n} (m_{l+1,r} - m_{l,r-1}) = \sum_{i=1}^n (m_{i,n} - m_{1,i})\leq n^2
\]</span></p>
<p>上式的第一个等号可以通过将两个 <span class="math inline">\(\Sigma\)</span> 分别展开合并同类项得证。</p>
<h4 id="另一形式">另一形式</h4>
<p>另一种常见的状态转移方程为 <span class="math display">\[
f_{i,j}=\min\limits_{k\leq j}\{f_{i-1,k}+w(k,j)\},\qquad(1\leq i\leq n,1\leq j\leq m)
\]</span> 具有与上面同样的结论与性质。</p>
<h3 id="优化-1d1d-动态规划">优化 1D1D 动态规划</h3>
<h4 id="定理及证明">定理及证明</h4>
<p>一种常见的状态转移方程为 <span class="math display">\[
f_i=\min\limits_{0\leq j&lt;i}\{f_j+w(i,j)\}
\]</span> <strong>定理 4</strong>：若 <span class="math inline">\(w\)</span> 满足四边形不等式，那么 <span class="math inline">\(f\)</span> 具有决策单调性。</p>
<p><strong>证明</strong>：设 <span class="math inline">\(p_i\)</span> 为 <span class="math inline">\(f_i\)</span> 的最优决策点，对于 <span class="math inline">\(\forall i\in[1,n],\forall j\in[0,p_i-1]\)</span>，有 <span class="math display">\[
f_{p_i}+w(p_i,i)\leq f_j+w(j,i),\tag6
\]</span> <span class="math inline">\(\forall i&#39;\in[i+1,n]\)</span>，由于 <span class="math inline">\(w\)</span> 满足四边形不等式，于是有 <span class="math display">\[
w(j,i)+w(p_i,i&#39;)\leq w(j,i&#39;)+w(p_i,i),\tag7
\]</span> 将 <span class="math inline">\((6)\)</span> 和 <span class="math inline">\((7)\)</span> 左右两部分分别相加即得 <span class="math display">\[
f_{p_i}+w(p_i,i&#39;)\leq f_j+w(j,i&#39;),
\]</span> 也就说明了应有 <span class="math inline">\(p_{i&#39;}\geq p_i\)</span>，即决策单调性。</p>
<div data-align="right">
证毕.
</div>
<h4 id="实现">实现</h4>
<p>由于决策单调性，<span class="math inline">\(p\)</span> 一定是一个非严格递增的序列，我们对 <span class="math inline">\(p\)</span> 进行维护，即对于当前转移完的 <span class="math inline">\(i\)</span>，我们考虑从哪里开始 <span class="math inline">\(i\)</span> 开始作为最优的决策点。</p>
<p>显然一种朴素的做法是直接在 <span class="math inline">\(p\)</span> 上进行二分，找到对应位置 <span class="math inline">\(pos\)</span>，然后 <span class="math inline">\(\forall j\in[pos,n]\)</span>，将 <span class="math inline">\(p_j\)</span> 修改为 <span class="math inline">\(i\)</span>。</p>
<p>一种更为简洁的做法是，用一个队列维护 <span class="math inline">\(p\)</span>，利用 <span class="math inline">\(p\)</span> 是一个非严格递增的序列的性质，每一段相同的用一个三元组 <span class="math inline">\((t_k,l_k,r_k)\)</span>，表示当前 <span class="math inline">\(\forall i\in[l_k,r_k],p_i=t_k\)</span>.</p>
<p>同时，如果一个三元组的右边界已经小于当前处理的位置，它一定不再有贡献，可以直接丢掉，于是就类似与单调队列，此时第一个合法的队头就是该位置的最优决策点。</p>
<p>考虑用 <span class="math inline">\(i\)</span> 更新决策点的过程，我们按照以下步骤进行：</p>
<ol type="1">
<li>取出队尾的三元组 <span class="math inline">\((t_k,l_k,r_k)\)</span>；</li>
<li>若 <span class="math inline">\(f_i+w(i,l_k)&lt;f_{t_k}+w(t_k,l_k)\)</span>，令 <span class="math inline">\(pos=l_k\)</span>，删掉该三元组，回到 1.</li>
<li>若 <span class="math inline">\(f_i+w(i,r_k)&gt;f_{t_k}+w(t_k,r_k)\)</span>，直接到 5.</li>
<li>在 <span class="math inline">\([l_k,r_k]\)</span> 上二分，找到第一个可行位置，更新为 <span class="math inline">\(pos\)</span>；</li>
<li>在队尾加入 <span class="math inline">\((i,pos,n)\)</span>；</li>
</ol>
<p>整体时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<div id="refer">

</div>
<h2 id="参考资料">参考资料</h2>
<p>[1] <a href="https://oi-wiki.org/dp/opt/quadrangle/">四边形不等式优化 - OI Wiki</a></p>
<p>[2] <a href="https://www.cnblogs.com/Pedesis/p/11148801.html">四边形不等式 - Pedesis</a></p>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>动态规划</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>「不务正业」正则表达式</title>
    <url>/2021/12/14/regular-expression/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="唔，暗号错了！你不是自己人 OnO" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="26e815750e70919ac30e14981fe25807b3b8b8386d831c91676c82e7eb857167">b6d1e56d81a230ce2763e9fd702bab908229bf30000e22fb35c42c85010f79f99c6572a94dff6f13284a5f0749d7ab54f0c8f1b7af7bfced79c1881b3c1f4d1ae16f257fcc0c602da7d0e930cc4527f05e1e375b96c582c52491edc7755d8fa17dc4ba84fcc5cdd175f8f22aa37aef721650fbbc612b2e95e05cebe14fa742b19b608f2034240a4c17f540507cd4f3eed0ebf4cef2fae647a2b68c64d2bc169110293ad8e793122e0789ca165611da84c4ec84a57d0a097127e14aac4ac4d0fabe868132c9d82d04311e268bfbe7c9910dfa5eb44f8d13692d0c8783910defb4</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">嘿，请说出接头暗号 OvO</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」DP 练习 - 1</title>
    <url>/2021/12/10/DP-Practice-1205/</url>
    <content><![CDATA[<blockquote>
<p>讲真的，题有点氵</p>
</blockquote>
<h2 id="poj1717-dominoes">POJ1717 Dominoes</h2>
<p>设 <span class="math inline">\(f_{i,x}\)</span> 为前 <span class="math inline">\(i\)</span> 个，得到的差为 <span class="math inline">\(x\)</span> 时的最小次数。</p>
<h2 id="poj1732-phone-numbers">POJ1732 Phone numbers</h2>
<p>显然每个串对应唯一的一串数字。</p>
<p>设 <span class="math inline">\(f_{i}\)</span> 表示前 <span class="math inline">\(i\)</span> 个字符对应的最小字符串数，直接 Hash 硬判转移即可。</p>
<h2 id="poj1458-common-subsequence">POJ1458 Common Subsequence</h2>
<p>经典问题了属于是。可以转化为 LIS，然后用 <code>lower_bound()</code> 做到 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h2 id="poj3093-margaritas-on-the-river-walk">POJ3093 Margaritas on the River Walk</h2>
<p>暴力可以做到 <span class="math inline">\(O(2^n)\)</span>.</p>
<p>考虑用什么不同的特点来区分所有的状态，使得可以完整表示所有状态并且得到的状态数可以接受。注意到选的物品的顺序是不被关注的，于是我们只需要关注哪些没选，判断一个状态不合法时只需要知道所有没选的物品中最小价格是否大于剩余空间，于是不妨按照最小的没选的物品最作为划分状态的依据。</p>
<p>于是我们先将所有的物品按照权值从小到大排序，然后 <span class="math inline">\(O(n)\)</span> 枚举最小的没选的物品，之前的物品一定都要选，然后对于剩下的物品做背包，找到所有剩余空间小于枚举的物品的情况即可。</p>
<h2 id="poj1694-an-old-stone-game">POJ1694 An Old Stone Game</h2>
<p>树上问题，考虑状态 <span class="math inline">\(f_i\)</span> 表示将石子放在 <span class="math inline">\(i\)</span> 上所需的最小石子数。</p>
<p>不难发现，对于同一个父亲的多个子树，我们一定是先处理所需石子数最多的，因为多出的石子不可替代，一定要购买，且提前购买可以再次利用。于是对于每个子树的根，依次考虑每个儿子，直接记录当前剩余的石子数贪心地添加即可。</p>
<h2 id="poj2385-apple-catching">POJ2385 Apple Catching</h2>
<p>考虑一个完整的状态需要记录哪些信息：当前时间、已移动了多少次、当前在哪棵树。于是得到状态 <span class="math inline">\(f_{i,j,0/1}\)</span>，<span class="math inline">\(i,j,0/1\)</span> 与上面的信息意义对应。</p>
<p>有转移：</p>
<p><span class="math display">\[
f_{i,j,x}=\max(f_{i-1,j,x},f_{i-1,j-1,\neg x})+v_{i,x},
\]</span></p>
<h2 id="poj2181-jumping-cows">POJ2181 Jumping Cows</h2>
<p>注意到一种药对于答案的贡献只与所在时间的奇偶性有关，于是设 <span class="math inline">\(f_{i,0/1}\)</span> 为 <span class="math inline">\(i\)</span> 在偶数/奇数时间服下可得到的最大价值，转移只需要找到前面最大的与当前奇偶性不同的位置即可，显然这个可以在每次转移后 <span class="math inline">\(O(1)\)</span> 维护，于是最终时间复杂度为 <span class="math inline">\(O(n)\)</span>.</p>
<h2 id="poj2182-lost-cows">POJ2182 Lost Cows</h2>
<p>不难发现一定是从后向前确定，然后直接考虑用标记找到前面未被标记的数量符合要求的位置，即为这一位的答案，然后直接标记。<span class="math inline">\(O(n^2)\)</span> 可过。用二分进行查找配合线段树/树状数组修改标记数组前缀和可做到 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h2 id="poj3140-contestants-division">POJ3140 Contestants Division</h2>
<p><del>百度翻译杀我</del></p>
<p>显然分成两个分别连通的部分只能是断边，而断掉某条边的答案就是下面子树大小和剩下的节点总数之差，于是直接求得每个子树的大小然后直接更新答案即可。</p>
<h2 id="poj2593-max-sequence">POJ2593 Max Sequence</h2>
<p>设 <span class="math inline">\(h_i\)</span> 表示第二段以 <span class="math inline">\(i\)</span> 结尾可得到的最大答案。</p>
<p>考虑一个数作为第二段最后一个数时的最优选择，有且仅有两种：自己作为第二段，自己第一、第二段的选择与 <span class="math inline">\(i-1\)</span> 的选择仅有自己不同。</p>
<p>简单的证明一下第二种选择：假如 <span class="math inline">\(i\)</span> 前面选择的是与 <span class="math inline">\(i-1\)</span> 的选择不同的段，其贡献为 <span class="math inline">\(h_{i-1}&#39;\)</span>，此时对于 <span class="math inline">\(i\)</span> 得到最大值，那么根据假设应有 <span class="math inline">\(h_{i-1}&#39;+a_i\geq h_{i-1}+a_i\)</span>，即 <span class="math inline">\(h_{i-1}&#39;\geq h_{i-1}\)</span>，注意到 <span class="math inline">\(h_{i-1}&#39;\)</span> 的选择一定包含 <span class="math inline">\(i-1\)</span>，所以一定已 <span class="math inline">\(i-1\)</span> 结尾，这与 <span class="math inline">\(h_{i-1}\)</span> 是以 <span class="math inline">\(i-1\)</span> 结尾的最大答案矛盾，于是假设不成立。</p>
<p>于是我们设 <span class="math inline">\(g_i\)</span> 为前 <span class="math inline">\(i\)</span> 个数中最大的子段和，<span class="math inline">\(f_i\)</span> 为以 <span class="math inline">\(i\)</span> 结尾的最大子段和，显然应有</p>
<p><span class="math display">\[
\begin{aligned}
h_i&amp;=\max(a_i+g_{i-1},a_i+h_{i-1}),\\
g_i&amp;=\max_{1\leq j\leq i}\{f_j\},\\
\end{aligned}
\]</span></p>
<p>对于 <span class="math inline">\(f\)</span>，我们有与上面同样的策略，即</p>
<p><span class="math display">\[
f_i=\max(a_i,a_i+f_{i-1}).
\]</span></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」平衡树 - 替罪羊树</title>
    <url>/2021/12/02/scapegoat/</url>
    <content><![CDATA[<h2 id="主体思想">#主体思想</h2>
<p>与 Treap 采用随机化、Splay 采用统计学<del>玄学</del>原理不同，替罪羊的主题思想就是直接将不平衡的子树树暴力重建为一棵尽可能平衡的子树。这样，我们就需要一个<strong>平衡因子</strong> <span class="math inline">\(\alpha\in[0.5,1]\)</span> 来判定这颗子树是否平衡，设 <span class="math inline">\(s_x\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树大小，定义以 <span class="math inline">\(x\)</span> 为根的子树平衡当且仅当该子树的两个儿子子树的大小都不超过 <span class="math inline">\(\alpha \cdot s_x\)</span>，当一个子树不平衡时就直接将它重建，可以证明（见下文 <a href="#prove">#复杂度证明</a>），各种插入删除等影响平衡性的操作的复杂度都是 <span class="math inline">\(O(\log n)\)</span>.</p>
<h2 id="基础实现">#基础实现</h2>
<h3 id="结构基础">#结构基础</h3>
<p>先把结构基础及基础操作摆在这里，不多讲。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> w, cnt, ls, rs, siz_single, siz_all, siz_without_del;&#125;;</span><br><span class="line"><span class="comment">/*w 为该点权值, cnt 为重复权值的个数, ls, rs 分别是左右儿子编号*/</span></span><br><span class="line"><span class="comment">/*siz_single 为该子树内所有节点个数（每个节点只计算一次）*/</span></span><br><span class="line"><span class="comment">/*siz_all 为子树内的元素的个数，包含重复元素的次数*/</span></span><br><span class="line"><span class="comment">/*siz_without_del 为子树内不包含已经删除的点的个数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScapeGoat</span> &#123;</span></span><br><span class="line">    Node p[N]; <span class="keyword">int</span> rt, cnt, rub[N], rcnt, q[N], qcnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_ind</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> rcnt ? rub[rcnt --] : ++ cnt;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del_node</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;rub[++ rcnt] = k;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">new_ind</span>(); p[k].w = w, p[k].ls = p[k].rs = <span class="number">0</span>;</span><br><span class="line">        p[k].cnt = p[k].siz_single = <span class="number">1</span>;</span><br><span class="line">        p[k].siz_all = p[k].siz_without_del = <span class="number">1</span>; <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = p[k].ls, rs = p[k].rs;</span><br><span class="line">        p[k].siz_single = p[ls].siz_single + p[rs].siz_single + <span class="number">1</span>;</span><br><span class="line">        p[k].siz_all = p[ls].siz_all + p[rs].siz_all + p[k].cnt;</span><br><span class="line">        p[k].siz_without_del = p[ls].siz_without_del + p[rs].siz_without_del + (p[k].cnt ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...something others...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到我们用 <code>siz_without_del</code> 记录子树内已不包含经被删除的节点的个数，这是因为替罪羊树采用惰性删除，也就是在删除时只减对应节点的个数。不难发现，如果一个子树内的已删除节点占比过高，会严重影响操作效率，所以如果我们发现一个子树内未被删除的节点占比达不到 <span class="math inline">\(\alpha\)</span>，那么我们就需要考虑重构。</p>
<h3 id="重建">#重建</h3>
<p>我们首先来考虑一个子树什么时候需要重建：</p>
<ul>
<li><p>刚经历过可能影响平衡性的操作；</p></li>
<li><p>满足上文中的两个条件（不平衡或空节点过多）任意一个；</p></li>
</ul>
<p>考虑到各种影响平衡性的操作一定是递归到某个点，于是我们可以直接在回溯时调用以下函数判断是否需要重构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">return</span> p[k].w &amp;&amp; (alpha * p[k].siz_single </span><br><span class="line">                                  &lt;= <span class="number">1.0</span> * <span class="built_in">Max</span>(p[p[k].ls].siz_single, p[p[k].rs].siz_single)</span><br><span class="line">                                 || <span class="number">1.0</span> * p[k].siz_without_del &lt;= p[k].siz_single * alpha);&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来思考这样一个问题：如何 <span class="math inline">\(O(x)\)</span> 地重建一棵树（<span class="math inline">\(x\)</span> 为子树大小）？怎样建树最优？</p>
<p>首先，显然<strong>二分地</strong>建树得到的树是最平衡的，即将原本的树转化为<strong>中序遍历</strong>，这样不会破坏平衡树的顺序性，然后每次选择中点作为当前区间的根，然后两侧递归，正确性显然；至于时间复杂度，注意到递归树上最多有 <span class="math inline">\(\log n\)</span> 层，整体形态与线段树接近，显然相同深度时一棵满二叉树的节点最多，此时节点个数为</p>
<p><span class="math display">\[
\sum_{i=0}^{\log n}2^i=2\cdot n-1,
\]</span></p>
<p>于是总的建树复杂度为 <span class="math inline">\(O(子树大小)\)</span>，具体实现分两部分：展开和重建。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unfold</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">unfold</span>(p[k].ls);</span><br><span class="line">    <span class="keyword">if</span> (p[k].cnt) q[++ qcnt] = k;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">del_node</span>(k);</span><br><span class="line">    <span class="built_in">unfold</span>(p[k].rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    p[q[mid]].ls = <span class="built_in">build</span>(l, mid - <span class="number">1</span>);</span><br><span class="line">    p[q[mid]].rs = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(q[mid]); <span class="keyword">return</span> q[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> &amp;k)</span> </span>&#123;qcnt = <span class="number">0</span>; <span class="built_in">unfold</span>(k); k = <span class="built_in">build</span>(<span class="number">1</span>, qcnt);&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用操作">#常用操作</h3>
<p>其实也没什么好说的，还是插入、删除、前趋、后继那些东西，只简单地提两点：</p>
<ul>
<li><p>插入删除回溯时记得检查重建；</p></li>
<li><p>新增几个操作：</p>
<ul>
<li><p>严格大于 <span class="math inline">\(x\)</span> 的最小的数的最小排名；</p></li>
<li><p>严格小于 <span class="math inline">\(x\)</span> 的最大的数的最大排名；以上两个操作</p></li>
</ul>
<p>以上两个操作都需要注意节点为空时的特殊贡献；</p></li>
<li><p>查找排名为 <span class="math inline">\(k\)</span> 的值时需要注意一个节点上相同权值的重复次数；</p></li>
<li><p>前趋、后继可用上面的操作组合得到；</p></li>
</ul>
<p>上面的所有代码实现见 <a href="#code">#Code</a></p>
<div id="prove">

</div>
<h2 id="复杂度证明">#复杂度证明</h2>
<p>这里我们取 <span class="math inline">\(\alpha=0.75\)</span>，使用时可以根据组题情况进行调节。</p>
<h3 id="插入">#插入</h3>
<p>假设当前已经有了一个大小为 <span class="math inline">\(x\)</span> 的已平衡的子树，那么为了让其尽快达到不平衡状态，我们一定是一直向一边插入节点，不妨设插入 <span class="math inline">\(k\)</span> 次后，当前这颗树不再平衡，那么应当有</p>
<p><span class="math display">\[
\left\lfloor\dfrac x 2\right\rfloor+k\geq\alpha\cdot(x + k),
\]</span></p>
<p>可以解得此时有</p>
<p><span class="math display">\[
k\geq\dfrac{\alpha-\frac 1 2}{1-\alpha}\cdot x,
\]</span></p>
<p>于是应当是每插入 <span class="math inline">\(\frac{\alpha-\frac 1 2}{1-\alpha}\cdot x\)</span> 次后，进行一次重构，重构一次的时间复杂度为 <span class="math inline">\(\Theta(x)\)</span>，我们将这一次重构的时间复杂度均摊到导致这次重构的所有插入操作中，时间复杂度为</p>
<p><span class="math display">\[
\dfrac{\Theta(x)}{\frac{\alpha-\frac 1 2}{1-\alpha}\cdot x}=\Omega(1),(\alpha=0.75)
\]</span></p>
<p>于是我们可以将重构操作均摊为 <span class="math inline">\(\Omega(1)\)</span> 的时间复杂度，由于树平衡，每次插入时查询的时间复杂度为 <span class="math inline">\(O(\log n)\)</span>，于是插入操作的总体时间复杂度为 <span class="math inline">\(O(\log n)\)</span>.</p>
<h3 id="删除">#删除</h3>
<p>与证明插入时间复杂度同样的思路，设删除 <span class="math inline">\(k\)</span> 个数据，每次恰使一个节点变为空节点后，当前这颗大小为 <span class="math inline">\(x\)</span> 的平衡树中的空节点数量过大，也就是有</p>
<p><span class="math display">\[
x-k\leq\alpha\cdot x,
\]</span></p>
<p>于是可以解得</p>
<p><span class="math display">\[
k\geq(1-\alpha)\cdot x,
\]</span></p>
<p>于是每 <span class="math inline">\((1-\alpha)\cdot x\)</span> 次删除（每次删除恰好使一个节点为空），那么均摊的复杂度为</p>
<p><span class="math display">\[
\dfrac{\Theta(x)}{(1-\alpha)\cdot x}=\Omega(1),(\alpha=0.75)
\]</span></p>
<p>于是总的删除复杂度为 <span class="math inline">\(O(\log n)\)</span>，常数略大。</p>
<p>看起来 <span class="math inline">\(\alpha\)</span> 越小，删除时的重建效率就越高，那为什么不能单独给删除定一个 <span class="math inline">\(\beta\)</span>，让这个 <span class="math inline">\(\beta\)</span> 尽可能小呢？注意到，单独定一个 <span class="math inline">\(\beta\)</span> 是可以的，但是我们删除重建的目的是去掉冗余的节点，让每次访问时的复杂度降低，如果直接把 <span class="math inline">\(\beta\)</span> 定为 <span class="math inline">\(0\)</span>，那么冗余节点会一直存在，影响查找的复杂度。当然可以适当的将 <span class="math inline">\(\beta\)</span> 调小到 <span class="math inline">\(0.5\)</span> 左右。</p>
<h3 id="更多操作">#更多操作</h3>
<p>由于替罪羊树维护平衡并没有用到太多特殊的性质，就是暴力重建，所以很多其他操作都可以用熟悉的套路实现，时间复杂度也多为 <span class="math inline">\(O(\log n)\)</span>.</p>
<div id="code">

</div>
<h2 id="code">#Code</h2>
<blockquote>
<p>题目为 <a href="https://www.luogu.com.cn/problem/P3369">Luogu3369 【模板】普通平衡树</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> alpha = <span class="number">0.75</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> del_alpha = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T x, T y)</span> </span>&#123;<span class="keyword">return</span> x &gt; y ? x : y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> w, cnt, ls, rs, siz_single, siz_all, siz_without_del;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScapeGoat</span> &#123;</span></span><br><span class="line">    Node p[N]; <span class="keyword">int</span> rt, cnt, rub[N], rcnt, q[N], qcnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_ind</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> rcnt ? rub[rcnt --] : ++ cnt;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del_node</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;rub[++ rcnt] = k;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">new_ind</span>(); p[k].w = w, p[k].ls = p[k].rs = <span class="number">0</span>;</span><br><span class="line">        p[k].cnt = p[k].siz_single = <span class="number">1</span>;</span><br><span class="line">        p[k].siz_all = p[k].siz_without_del = <span class="number">1</span>; <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = p[k].ls, rs = p[k].rs;</span><br><span class="line">        p[k].siz_single = p[ls].siz_single + p[rs].siz_single + <span class="number">1</span>;</span><br><span class="line">        p[k].siz_all = p[ls].siz_all + p[rs].siz_all + p[k].cnt;</span><br><span class="line">        p[k].siz_without_del = p[ls].siz_without_del + p[rs].siz_without_del + (p[k].cnt ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">return</span> p[k].w &amp;&amp; (alpha * p[k].siz_single </span><br><span class="line">                                                  &lt;= <span class="number">1.0</span> * <span class="built_in">Max</span>(p[p[k].ls].siz_single, p[p[k].rs].siz_single)</span><br><span class="line">                                                || <span class="number">1.0</span> * p[k].siz_without_del &lt;= p[k].siz_single * alpha);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfold</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">unfold</span>(p[k].ls);</span><br><span class="line">        <span class="keyword">if</span> (p[k].cnt) q[++ qcnt] = k;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">del_node</span>(k);</span><br><span class="line">        <span class="built_in">unfold</span>(p[k].rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        p[q[mid]].ls = <span class="built_in">build</span>(l, mid - <span class="number">1</span>);</span><br><span class="line">        p[q[mid]].rs = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(q[mid]); <span class="keyword">return</span> q[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> &amp;k)</span> </span>&#123;qcnt = <span class="number">0</span>; <span class="built_in">unfold</span>(k); k = <span class="built_in">build</span>(<span class="number">1</span>, qcnt);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) &#123;k = <span class="built_in">new_node</span>(x); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (p[k].w == x) ++ p[k].cnt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[k].w &lt; x) <span class="built_in">insert</span>(p[k].rs, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(p[k].ls, x);</span><br><span class="line">        <span class="built_in">pushup</span>(k); <span class="keyword">if</span> (<span class="built_in">check</span>(k)) <span class="built_in">rebuild</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (p[k].w == x &amp;&amp; p[k].cnt) -- p[k].cnt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[k].w &lt; x) <span class="built_in">del</span>(p[k].rs, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[k].w &gt; x) <span class="built_in">del</span>(p[k].ls, x);</span><br><span class="line">        <span class="built_in">pushup</span>(k); <span class="keyword">if</span> (<span class="built_in">check</span>(k)) <span class="built_in">rebuild</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">upper_grade</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p[k].w == x &amp;&amp; p[k].cnt) <span class="keyword">return</span> p[p[k].ls].siz_all + p[k].cnt + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p[k].w &gt; x) <span class="keyword">return</span> <span class="built_in">upper_grade</span>(p[k].ls, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p[p[k].ls].siz_all + p[k].cnt + <span class="built_in">upper_grade</span>(p[k].rs, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">lower_grade</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p[k].w == x &amp;&amp; p[k].cnt) <span class="keyword">return</span> p[p[k].ls].siz_all;</span><br><span class="line">        <span class="keyword">if</span> (p[k].w &gt; x) <span class="keyword">return</span> <span class="built_in">lower_grade</span>(p[k].ls, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p[p[k].ls].siz_all + p[k].cnt + <span class="built_in">lower_grade</span>(p[k].rs, x);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">kth_value</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p[p[k].ls].siz_all &lt; x &amp;&amp; x &lt;= p[p[k].ls].siz_all + p[k].cnt) <span class="keyword">return</span> p[k].w;</span><br><span class="line">        <span class="keyword">if</span> (p[p[k].ls].siz_all &gt;= x) <span class="keyword">return</span> <span class="built_in">kth_value</span>(p[k].ls, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth_value</span>(p[k].rs, x - p[k].cnt - p[p[k].ls].siz_all);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pre_value</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">kth_value</span>(rt, <span class="built_in">lower_grade</span>(rt, x));&#125;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nxt_value</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">kth_value</span>(rt, <span class="built_in">upper_grade</span>(rt, x));&#125;</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_grade</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">lower_grade</span>(rt, x) + <span class="number">1</span>;&#125;</span><br><span class="line">&#125; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">0</span>, x = <span class="number">0</span>; <span class="built_in">read</span>(opt), <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) t.<span class="built_in">insert</span>(t.rt, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) t.<span class="built_in">del</span>(t.rt, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t.<span class="built_in">get_grade</span>(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t.<span class="built_in">kth_value</span>(t.rt, x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t.<span class="built_in">pre_value</span>(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t.<span class="built_in">nxt_value</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><p><a href="https://riteme.site/blog/2016-4-6/scapegoat.html">替罪羊树(Scapegoat Tree) - riteme</a></p></li>
<li><p><a href="https://oi-wiki.org/ds/sgt/">替罪羊树 - OI Wiki</a></p></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>「游记」NOIP2021 梦游记</title>
    <url>/2021/11/21/NOIP-2021/</url>
    <content><![CDATA[<h2 id="day--1">DAY -1</h2>
<p>很早就知道这次 NOIP 考点改到了自己学校，前一天（<span class="math inline">\(2021.11.18\)</span>）因为太困了，强行请假回去休息了一晚，早上起来就吃午饭的感觉有些奇妙，感觉自己还有好多东西没复习，属实要完大蛋了 QnQ</p>
<p>本来是要 15:00 前回学校的，但是学校里奇妙的核酸抽测那么奇妙地抽到了我，被迫 13:30 到校，下午就简单过了过板子，晚上又看了看去年的真题，2h 也就只能有 174 分的样子，T3, T4 属实一点也不会/kk</p>
<p>好像明天可以晚起，好耶 OvO</p>
<h2 id="day-1">DAY 1</h2>
<p>同宿舍数学的同学依旧是 5:30 起，但是听到哨声醒过来后也就只能闭目养神了，硬是熬到 6:30 起床，直接去食堂来了碗羊汤。感觉自己好像还挺精神的（后面证明其实并不），7:00 来到平常学习的机房，大家似乎都很兴奋，甚至放起了好运来（md 我考场上脑中一直在循环），又简单看了看板子，就去考场了。</p>
<p>进考场进的挺早的，左边好像是 dyx dalao，在心里暗暗膜拜了一番。不过距离考试开始雀食还有好久，又打了几个字符串的板子。</p>
<p>压缩包密码是：IronHeart@413A，彳亍口巴，面对成绩确实需要 IronHeart.</p>
<p>开场看了一遍题，发现除了 T4 题面太长没看懂以外，别的都没什么思路，登时就慌了，想来想去还是 T1 最可做，不难想到直接筛出所有满足的数，回答询问直接 <code>upper_bound</code>，怀疑筛的复杂度，如果每个数还要一位一位的判，感觉有点危，然后发现好像可以类似数位 DP 提前一遍 <code>dfs</code> 把所有含有 <code>7</code> 的数全都标记出来，然后筛的时候可以只将被标记的质数向后筛，时间复杂度应该是线性（一个数被筛的次数取决于他有几个含 <span class="math inline">\(7\)</span> 的质因数，<span class="math inline">\(1e7\)</span> 中的数不会有很多），然后就切了，无 O2 大样例本机 1.4 s，考虑到考前测得机子的速度大概是 Luogu 评测机的四分之一，应该是没问题，又检查了一遍变量，免得重蹈 CSP 的覆辙，然后就丢到一边吃灰了。</p>
<p>此时还剩下 3 h 50 min，然鹅之后一直在罚坐，死活就是不知道 T2,T3 怎么做，T3 只发现对一个数操作就是交换它和它后面的数的差分数组，除此之外一无所获，结果只有 20pts 的暴力分。</p>
<p>T2 就硬打了一个暴力，小聪明优化了一下，以为样例二很大，于是只测了样例一（埋下伏笔），距离考试还剩 30 min 时去想到了一个 50pts 的类似背包的 DP，可能是假了，总之没调出来，直到距离考试结束还有 5 min 时发现样例二也很小，就测了一下，发现小聪明的暴力挂了，此时还剩 3 min，（以为）补正确的暴力来不及了，其实也就一个 DFS 5 行的事，直到最后一分钟发现一分钟原来这么长才后悔。</p>
<p>T4 从开始到结束看都没看，他们说 T4 不难？似乎是吧，但是题面雀食太长了。</p>
<p>于是乎 <span class="math inline">\(100+0+20+0=120\)</span> 遗憾离场。</p>
<p>老父亲接我回家，在车上一直跟我强调文化课，也和我吐槽 J 的无能，也在安慰我说题难都难。</p>
<p>“...这次之后就重点文化课吧...我是说以后也别学这个什么信息了...耽误上课了都...”</p>
<p>是啊，也许该 AFO 了罢。</p>
<p>“...原本还指望你靠这个（指 OI）进个清华北大呢，你让我失望了，让我绝望了...”</p>
<p>虽然知道他是在开玩笑，用的也是开玩笑的语气，但是听到“让我失望了”时，还是鼻头一酸，差点没绷住。</p>
<p>回家睡觉。</p>
<h2 id="day2">DAY2</h2>
<p>虽然比赛没有 DAY2，但考试雀食影响到了这一天，便也简单写写罢。</p>
<p>早晨睡到 10 点多才起，感觉心里还是怪难受的。发了一会呆，就接到了 hyl 的 QQ 电话，说是估分，Luogu 上和我想的一模一样，120pts，核老师好像 T3 骗分能有 70 多？强啊。好像 SD 一等线 132？雀食该 AFO 了。</p>
<p>从姥姥家吃完午饭回来的路上，老母亲在后面领着弟弟，问我为什么不开心，是不是因为考得差，登时眼泪就出来了（话说我还真不像个爷们，这就掉泪了），倒是没让人看见，但心里实在难受。但是在别人、家人面前还得装出一副不在乎的模样，或许是虚伪罢。</p>
<p>但说真的，停了两个月的课，就搞成这个样子，有点没脸见家长，有点怕被同学笑话。</p>
<p>悲伤就到这里吧，CCF 不会因为你悲伤就给你一等，清北也不会因为你悲伤就给你保送，时间的车轮不会因为你悲伤就停下脚步，菜就是原罪！现在的重点就是一个月后的月考，卷文化课吧，要补上这两个月实验班的进度可不容易，还得复习必修一的内容应对月考。</p>
<h2 id="the-end">The End</h2>
<blockquote>
<p>Update on 2021.11.29</p>
</blockquote>
<p>出成绩力，<span class="math inline">\(120pts\)</span>，SD 省一线大概是 <span class="math inline">\(130/128pts\)</span>，错过省一，该退役了。</p>
<blockquote>
<p>Update on 2021.12.5</p>
</blockquote>
<p>出线了，SD 居然只有 <span class="math inline">\(120pts\)</span>，好拉啊，让我蹭上了省一，不过蹭上省一完全是因为 SD 太菜吧。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>基础动态规划题单</title>
    <url>/2021/11/16/%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%8D%95/</url>
    <content><![CDATA[<h3 id="acceptedluogu4302.-scoi2003字符串折叠">[Accepted]Luogu4302. [SCOI2003]字符串折叠</h3>
<p><span class="math inline">\(f_{l,r}\)</span> 表示将 <span class="math inline">\([l,r]\)</span> 中的字符串折叠得到的最短长度，那么有两种情况：</p>
<ul>
<li><span class="math inline">\([l,r]\)</span> 由一个字符串重复多次得到，那么我们尝试枚举这个长度 <span class="math inline">\(x\)</span>，每次判断之间用哈希判断分成的 <span class="math inline">\(\frac n x\)</span> 个串，每个长度判断的时间复杂度是 <span class="math inline">\(O(\frac n x)\)</span>，取最终结果最小值，对于这一段的时间复杂度为 <span class="math inline">\(O(\sum_{d|n} \frac n d)=O(n\log n)\)</span>；</li>
<li>其他的字符串的折叠情况一定可以通过将原串分为两部分拼接而成，枚举断点合并即可，时间复杂度为 <span class="math inline">\(O(n)\)</span>；</li>
</ul>
<p>于是最终答案是 <span class="math inline">\(f_{1,n}\)</span>，总体时间复杂度为 <span class="math inline">\(O(n^3\log n)\)</span>。</p>
<h3 id="acceptedloj2124.-haoi2015树上染色">[Accepted]LOJ2124. [HAOI2015]树上染色</h3>
<p>由于涂黑的点数有限制，所以自然地设计状态为 <span class="math inline">\(f_{i,j}\)</span> 表示在以 <span class="math inline">\(i\)</span> 为根的子树中选了 <span class="math inline">\(j\)</span> 个为黑点，得到的子树中的最大价值，我们考虑一条边 <span class="math inline">\(i\)</span> 如何贡献，假设它所连向以 <span class="math inline">\(x\)</span> 为根的子树，<span class="math inline">\(x\)</span> 的子树中有 <span class="math inline">\(j\)</span> 个黑点，那么不论外面怎么选，<span class="math inline">\(i\)</span> 上面一定有 <span class="math inline">\(k-j\)</span> 个黑点，于是贡献就是 <span class="math inline">\(w_i\cdot(k-j)\cdot j\)</span>，白点经过这条边的代价类似，然后类似树上背包合并即可。</p>
<p>看起来时间复杂度是 <span class="math inline">\(O(n^3)\)</span> 的，其实不然。即设现在要计算 <span class="math inline">\(x\)</span> 的子树的价值，称 <span class="math inline">\(x\)</span> 的子树为大子树，当前考虑的 <span class="math inline">\(x\)</span> 的某个儿子 <span class="math inline">\(y\)</span> 的子树为小子树。由于计算贡献时，我们背包的大小是子树大小，相当于给小子树内的每个点一个编号，给小子树外、大子树的点一个编号，每次分别枚举一个子树内的点和一个子树外的点配对（将枚举的大小看作编号），于是每个点作为小子树内的点配对时，最多与其他 <span class="math inline">\(n-1\)</span> 个点各进行配对一次，于是总体时间复杂度为 <span class="math inline">\(O(n^2)\)</span>，注意这个时间复杂度成立的前提就是我们合并时枚举的背包大小必须是子树大小。</p>
<h3 id="acceptedloj2559-hnoi2003消防局的设立">[Accepted]LOJ2559 [HNOI2003]消防局的设立</h3>
<p>虽然说是 DP，但更容易想到的还是贪心，显然对于当前所有未被覆盖的点，我们一定是选择覆盖其中深度最深的节点，而且我们一定是将其放在他的祖父位置放置那么我们考虑如果要覆盖这个点，那么我们一定是在它的祖父位置（如果存在）安置最优（不存在就放在父亲），这样可以覆盖到的点一定最多。</p>
<p>考虑如何确定一个点是否被覆盖，最朴素的想法便是记录到达离它最近的消防站距离它的距离 <code>d[]</code>，考虑如何更新一个点的距离：</p>
<ul>
<li>将某个点的祖父选中时，修改其父亲和其祖父的 <code>d[]</code>；</li>
<li>处理到某个点时，用其父亲和祖父的 <code>d[]</code> 尝试更新自己（来自子孙的如果有一定已经被更新）；</li>
</ul>
<p>然后做就是了。</p>
<h3 id="acceptedluogu1131-zjoi2004时态同步">[Accepted]Luogu1131 [ZJOI2004]时态同步</h3>
<p>注意到 <span class="math inline">\(x\)</span> 的子树内的叶节点的时间一定被同步到其中最初到的最晚的时间，只需要在 <span class="math inline">\(x\)</span> 下面不满足的子树到 <span class="math inline">\(x\)</span> 的路径上进行对应的修改即可。</p>
<p>于是 <span class="math inline">\(f_{i}\)</span> 表示将 <span class="math inline">\(i\)</span> 的子树内的时态同步所需的最小操作次数，按照上面的想法进行转移即可。</p>
<h3 id="acceptedluogu1220-关路灯">[Accepted]Luogu1220 关路灯</h3>
<p>考虑在任意时刻关闭的灯一定是一段连续的区间，于是我们可以设状态 <span class="math inline">\(f_{l,r}\)</span> 表示将区间 <span class="math inline">\([l,r]\)</span> 内的灯全部关闭时已消耗的最少电功，发现每次关灯一定是从之前区间的 <span class="math inline">\([l,r]\)</span> 的边界中移动到 <span class="math inline">\(l-1\)</span> 或 <span class="math inline">\(r+1\)</span> 关灯，于是完善状态为：</p>
<p><span class="math inline">\(f_{l,r,0/1}\)</span> 表示将区间 <span class="math inline">\([l,r]\)</span> 内的灯全部关闭时，最后关闭的灯是 <span class="math inline">\(l\)</span> 或是 <span class="math inline">\(r\)</span>，已消耗的最少电功，</p>
<p>转移就考虑枚举一个区间 <span class="math inline">\([l,r]\)</span>，然后从 <span class="math inline">\([l+1,r]\)</span> 和 <span class="math inline">\([l,r-1]\)</span> 分别进行转移即可。</p>
<h3 id="acceptedluogu4766-cerc2014outer-space-invaders">[Accepted]Luogu4766 [CERC2014]Outer space invaders</h3>
<p>不难发现如果我们可以把每一个外星人看作一个时间轴上的区间，对于所有完全包含于某个区间 <span class="math inline">\([l,r]\)</span> 内的所有外星人，必然有一次的杀伤距离是其中距离最远的外星人所处的位置，然后再考虑消灭该外星人所选取的时间 <span class="math inline">\(t\)</span>，那么显然与 <span class="math inline">\(t\)</span> 有交集的所有外星人都会被消灭，那么剩下的一定是完全包含于 <span class="math inline">\([l,t-1]\)</span> 和 <span class="math inline">\([t+1, r]\)</span> 中的外星人。</p>
<p>根据上面的想法，我们可以设计如下的状态：<span class="math inline">\(f_{l, r}\)</span> 表示将被完全包含在 <span class="math inline">\([l,r]\)</span> 中的外星人全部消灭所需的最小代价，于是应当有转移：</p>
<p><span class="math display">\[
f_{l,r}=\min_{l_x\leq t\leq r_x}\{d_x+f_{l,t-1}+f_{t+1, r}\},
\]</span></p>
<p>其中 <span class="math inline">\(x\)</span> 为该区间内距离最远的外星人的编号。显然我们需要将时间序列离散化。</p>
<h3 id="acceptedluogu1864-noi2009二叉查找树">[Accepted]Luogu1864 [NOI2009]二叉查找树</h3>
<p>本题的一大难点就是观察出这棵二叉查找树是 Treap，改变权值会使得其旋转， 但中序遍历得到的数据值的序列不会变化，于是我们可以在这个序列上进行操作。</p>
<p>同时，虽然题目要求每个节点的权值不同，但是可以是实数，所以我们可以让某个点的权值无限逼近某个值，于是原题中权值不同的要求就消失了。</p>
<p>考虑对于一段中序遍历，它同时也是一个 dfn 序列，由于 Treap 的形态由各个节点的权值决定，我们可以考虑用这个 dfn 序列来还原出一棵子树，同样考虑到由于 Treap 的权值是满足堆性质，于是我们只需要确定出根节点的权值，剩下两棵子树的权值的下界也就确定了，而剩下的两棵子树怎样形成显然是另一个子问题，于是可以动态规划。</p>
<p>设 <span class="math inline">\(f_{l,r,x}\)</span> 表示将 dfn 序列中的 <span class="math inline">\([l,r]\)</span> 划分为一棵子树，子树中的点的权值不小于 <span class="math inline">\(x\)</span> 的最小代价，然后我们考虑要不要修改当前根的价值，如果不改（要求 <span class="math inline">\(v_i\geq x\)</span>），那么一定具有转移：</p>
<p><span class="math display">\[
\begin{aligned}
f_{l,r,x}&amp;=\min_{l\leq i\leq r}\left\{f_{l,i-1,v_i}+f_{i+1,r,v_i}+sum_{l,r}\right\},\\
\end{aligned}
\]</span></p>
<p>否则我们要改，那么一定是贪心地将该点的权值修改为 <span class="math inline">\(x\)</span>，这样剩下的子树的限制会更小，于是有转移：</p>
<p><span class="math display">\[
\begin{aligned}
f_{l,r,x}&amp;=\min_{l\leq i\leq r}\left\{f_{l,i-1,x}+f_{i+1,r,x}+sum_{l,r}+k\right\},\\
\end{aligned}
\]</span></p>
<p>其中，<span class="math inline">\(sum_{l,r}\)</span> 表示 <span class="math inline">\([l,r]\)</span> 的访问频度的和，这样做是将访问频度的代价拆分为了每层上的一部分一部分的代价和；</p>
<p>注意我们需要把所有的权值进行离散化到区间 <span class="math inline">\([1,n]\)</span> 中，这样我们最后的答案就是 <span class="math inline">\(f_{1,n,1}\)</span>.</p>
<h3 id="luogu6478-noi-online-2-提高组游戏">Luogu6478 [NOI Online #2 提高组]游戏</h3>
<h3 id="acceptedluogu2157-sdoi2009学校食堂">[Accepted]Luogu2157 [SDOI2009]学校食堂</h3>
<p>首先不难看出代价就是 <span class="math inline">\(a\text{ xor } b\)</span>。</p>
<p>对于状态，一个很自然的想法是 <span class="math inline">\(f_i\)</span> 表示 <span class="math inline">\(i\)</span> 及之前的完事了所花费的最小时间，但是注意到这样显然不能合理地区分状态，因为选择可以是不连续的，但是同样注意到对于 <span class="math inline">\(i\)</span> 来说向后的扩展不可能超过 <span class="math inline">\(7\)</span> 个人，于是我们考虑记录这 <span class="math inline">\(7\)</span> 个人的状态，也就是将状态补充为 <span class="math inline">\(f_{i,S}\)</span>，表示 <span class="math inline">\([1,i-1]\)</span> 中的人都已经打完了饭，第 <span class="math inline">\(i\)</span> 个人以及他后面的 <span class="math inline">\(7\)</span> 个人的状态是 <span class="math inline">\(S\)</span>，用一个 <span class="math inline">\(8\)</span> 位二进制数表示，再考虑到转移时同样需要上一个打饭的是谁，于是在状态中还需要增添一维，要表示上一个打饭的人的位置，由于第 <span class="math inline">\(i-1\)</span> 个人已经打了饭，显然上一个打饭的人不可能比 <span class="math inline">\(i-8\)</span> 还要考前，所以用 <span class="math inline">\([-8,7]\)</span> 表示上一个打饭的是 <span class="math inline">\(i\)</span> 向后第几个人（用数组存需要 <span class="math inline">\(+8\)</span>），于是，我们就能用 <span class="math inline">\(f_{i,S,j}\)</span> 完整地表示一个状态，即：<span class="math inline">\([1,i-1]\)</span> 中的所有人都已经打了饭，<span class="math inline">\([i,i+7]\)</span> 中是否已打饭的情况是 <span class="math inline">\(S\)</span>，上一个打饭的是第 <span class="math inline">\(i+j\)</span> 个人。</p>
<p>设计好了状态，下面来考虑如何转移。</p>
<p>注意到，对于状态 <span class="math inline">\(f_{i,S,j}\)</span> 如果 <span class="math inline">\(S\)</span> 代表 <span class="math inline">\(i\)</span> 的一位已经为 <span class="math inline">\(1\)</span>，那么它应当和状态 <span class="math inline">\(f_{i+1,S&#39;,j-1}\)</span> 等价，其中 <span class="math inline">\(S&#39;\)</span> 为将 <span class="math inline">\(S\)</span> 中代表 <span class="math inline">\(i\)</span> 的一位去掉，加上代表 <span class="math inline">\(i+8\)</span> 的状态（为 <span class="math inline">\(0\)</span>）的一位，这一点是显然的，这一步的转移是不需要代价的。</p>
<p>之后，我们应当尝试从 <span class="math inline">\([i,i+7]\)</span> 中寻找一位未打饭的给他打饭，转移到对应状态，注意给这个人打饭需要保证在其之前的所有未打饭的人都能接受他先打饭，为此我们需要维护一个位置为可行的能打饭的最远位置，这个位置是前面所有人可接受位置的最小值，我们只需要顺序枚举，在转移 <span class="math inline">\(f\)</span> 的同时维护即可，注意到如果一个人不能满足了，那么他后面的一定也不行。</p>
<p>粗略的估计整体的时间复杂度是 <span class="math inline">\(O(n\cdot2^8\cdot15\cdot7)\)</span>，其中包含了很多不可达的状态。</p>
<h3 id="acceptedluogu5005-中国象棋---摆上马">[Accepted]Luogu5005 中国象棋 - 摆上马</h3>
<p>考虑直接设计状态为 <span class="math inline">\(f_{i,S_1,S_2}\)</span>，表示考虑到第 <span class="math inline">\(i\)</span> 行，摆放状态为 <span class="math inline">\(S_i\)</span>，第 <span class="math inline">\(i-1\)</span> 行的摆放状态为 <span class="math inline">\(S_2\)</span>。直接预处理出对于单行，上一行不能存在的位置有哪些，然后再对于两行 <span class="math inline">\(S_1,S_2\)</span>（<span class="math inline">\(S_1\)</span> 在下，<span class="math inline">\(S_2\)</span> 在上），上面一行 <span class="math inline">\(S_3\)</span> 不能存在的位置有哪些，容易发现这恰好也即是 <span class="math inline">\(S_1\)</span> 在上，<span class="math inline">\(S_2\)</span> 在下时，下面一行 <span class="math inline">\(S_3\)</span> 不能存在的位置，然后可以直接做。</p>
<h3 id="acceptedluogu3977-tjoi2015棋盘">[Accepted]Luogu3977 [TJOI2015]棋盘</h3>
<p>容易发现关键点一定在中间的一行，于是可以直接处理出当前行每种状态上下的影响范围，设状态为 <span class="math inline">\(f_{i,S}\)</span>，为到第 <span class="math inline">\(i\)</span> 行的状态为 <span class="math inline">\(S\)</span>，可行的情况数，时间复杂度为 <span class="math inline">\(O(n2^{2m})\)</span>，显然不可过，于是考虑优化。</p>
<p>注意到对于一个状态 <span class="math inline">\(S\)</span>，可行的转移来源都是确定的，也就是</p>
<p><span class="math display">\[
f_{i,S}=\sum_{S&#39;}c_{S,S&#39;}\cdot f_{i-1,S&#39;},
\]</span></p>
<p>其中 <span class="math inline">\(c_{S,S&#39;}\)</span> 为当前行状态为 <span class="math inline">\(S\)</span>，上一行是否可以为 <span class="math inline">\(S&#39;\)</span>，<span class="math inline">\(c_{S,S&#39;}\)</span> 显然都是确定的，于是考虑用矩阵快速幂优化。显然状态数不会超过 <span class="math inline">\(2^6=64\)</span>，于是构建一个 <span class="math inline">\(64\times64\)</span> 的转移矩阵 <span class="math inline">\(T\)</span>，<span class="math inline">\(T_{i,j}\)</span> 为第 <span class="math inline">\(j\)</span> 个状态是否可以从（上一行状态为）状态 <span class="math inline">\(i\)</span> 转移，<span class="math inline">\(F_i\)</span> 为一个 <span class="math inline">\(64\)</span> 元行向量，表示第 <span class="math inline">\(i\)</span> 行每种状态的可行方案数，显然有</p>
<p><span class="math display">\[
F_i=F_{i-1}T\Rightarrow F_n=F_1(T)^{n-1},
\]</span></p>
<p>然后直接矩阵快速幂即可，时间复杂度为 <span class="math inline">\(O(2^{3m}\log n)\)</span>.</p>
<h3 id="acceptedloj2318-noip2017宝藏">[Accepted]LOJ2318 [NOIP2017]宝藏</h3>
<p>较为重要的一点是看出我们最终一定是得到一棵原图的生成树，然后对于一个树上的点，它的贡献就是它连向原本生成树的边权乘上它所在的深度，于是我们设计状态 <span class="math inline">\(F_{S,i}\)</span> 为当前已经加入生成树的点集为 <span class="math inline">\(S\)</span>，生成树的最大深度为 <span class="math inline">\(i\)</span> 时的最小代价。</p>
<p>那么考虑转移，我们枚举形成 <span class="math inline">\(S\)</span> 的子集 <span class="math inline">\(S&#39;\)</span>，<span class="math inline">\(S\)</span> 由 <span class="math inline">\(S&#39;\)</span> 向外连边得到，显然应当连接 <span class="math inline">\(\complement_SS&#39;\)</span> 中的点向 <span class="math inline">\(S&#39;\)</span> 中所花费最少的边，于是应当是这些边权求和乘上最大深度，显然这样算出的答案不一定是正确的，但是假设 <span class="math inline">\(\complement_SS&#39;\)</span> 中有的点不是连到 <span class="math inline">\(S&#39;\)</span> 中最大深度的点上，那么一定存在另一个集合 <span class="math inline">\(S&#39;&#39;\)</span> 包含这些点，且最大深度与 <span class="math inline">\(S&#39;\)</span> 相同，显然这个集合得到的答案不会比 <span class="math inline">\(S&#39;\)</span> 得到的更大，于是更新到 <span class="math inline">\(S\)</span> 上时得到的答案一定是正确的答案。</p>
<p>总体时间复杂度为 <span class="math inline">\(O(3^n\cdot n^2)\)</span>，考虑到不合法的状态，<span class="math inline">\(3^n\)</span> 和 <span class="math inline">\(n^2\)</span> 都不容易跑满，于是能过。</p>
<h3 id="acceptedluogu5933-清华集训2012串珠子">[Accepted]Luogu5933 [清华集训2012]串珠子</h3>
<p>我们首先直接考虑设 <span class="math inline">\(f_S\)</span> 为点集 <span class="math inline">\(S\)</span> 中的点全部连通的方案数，直接计算发现不好计算，正难则反，设 <span class="math inline">\(g_S\)</span> 为点集 <span class="math inline">\(S\)</span> 中的点所有的连边的方案数，<span class="math inline">\(h_S\)</span> 为点集 <span class="math inline">\(S\)</span> 中的点不连通的方案数，显然有</p>
<p><span class="math display">\[
f_S=g_S-h_S,
\]</span></p>
<p><span class="math inline">\(g_s\)</span> 的计算比较显然，就是存在的点两两之间连边的方案数的乘积，可以预处理。</p>
<p>再来考虑 <span class="math inline">\(h_S\)</span>，发现我们可以指定 <span class="math inline">\(S\)</span> 的一个子集 <span class="math inline">\(S&#39;\)</span> 连通，剩下的部分连通性随意，这两部分之间不相连，这样的不同的方案的数量就是 <span class="math inline">\(h_S\)</span>，我们考虑如何在不算重的情况下计算 <span class="math inline">\(h_S\)</span>，对于我们指定连通的子集 <span class="math inline">\(S&#39;\)</span>，我们可以强制要求其中包含点 <span class="math inline">\(x\)</span>（<span class="math inline">\(x\in S\)</span>），得到的 <span class="math inline">\(\complement_S S&#39;\)</span> 自然一定不含 <span class="math inline">\(x\)</span>，这样，将 <span class="math inline">\(S\)</span> 分为两个部分，<span class="math inline">\(x\)</span> 所处的部分一定都不同，于是得到的结果一定是不重复的。</p>
<h3 id="acceptedluogu4363-九省联考2018一双木棋chess">[Accepted]Luogu4363 [九省联考2018]一双木棋chess</h3>
<p>看到数据范围大致知道是状压，但是要考虑怎么记录屈居的状态，注意到所下的棋，自上至下每一行靠左边的棋子个数一定是非严格单调递减，同时发现我们不需要知道当前局面的每一个棋子都是谁下的，并且每个局面接下来该谁下都是固定的，于是我们可以直接记录左上角的连通块的轮廓线，将竖边记为 <span class="math inline">\(1\)</span>，横边记为 <span class="math inline">\(0\)</span>，从右上角到左下角一次记录，于是就可以得到一个长度为 <span class="math inline">\(n+m\)</span> 的 01 串，每个 01 串都唯一表示一个局面。</p>
<p>于是我们设计状态为 <span class="math inline">\(f_{S}\)</span> 表示 <span class="math inline">\(S\)</span> 局面时剩下的棋子还可以得到的得分。</p>
<p>转移时就可以依次考虑轮廓线边缘的每个位置是否可以放置，然后进行转移，为了方便，就可以直接用记忆化搜索解决。</p>
<h3 id="luogu3943-星空">Luogu3943 星空</h3>
<h3 id="luogu2150-noi2015-寿司晚宴">Luogu2150 [NOI2015] 寿司晚宴</h3>
<h3 id="agc016f-games-on-dag">AGC016F Games on DAG</h3>
<h3 id="cf1523f-favorite-game">CF1523F Favorite Game</h3>
]]></content>
      <categories>
        <category>题单</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>图的连通性题单</title>
    <url>/2021/11/16/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E9%A2%98%E5%8D%95/</url>
    <content><![CDATA[<blockquote>
<p>[Accepted] 表示已经提交并 AC，[Solved] 表示已会做但还没写</p>
</blockquote>
<h3 id="acceptedknights-of-the-round-table-poj-2942">[Accepted]Knights of the Round Table (POJ 2942)</h3>
<p>有 <span class="math inline">\(n\)</span> 个骑士，有 <span class="math inline">\(m\)</span> 对骑士相互憎恨。骑士可能召开圆桌会议，骑士们围绕着圆桌而坐，需要满足</p>
<ul>
<li>骑士的个数是大于 <span class="math inline">\(1\)</span> 的奇数。</li>
<li>任何相邻的一对骑士都不相互憎恨。</li>
</ul>
<p>求有多少骑士不可能参加任何圆桌会议。</p>
<p><span class="math inline">\(1\le n\le 1\,000\)</span> <span class="math inline">\(1\le m\le {n\choose 2}\)</span></p>
<p>直接从哪些不能坐在一起来入手不好直接做，于是考虑建出反图，统计出哪些可以参加某个会议，然后取补集即可。</p>
<p>注意到一个骑士可以参加某个会议当且仅当他被包含在某个简单奇环中，由于我们需要考虑一个简单环，于是我们考虑点双连通分量，注意到在一个点双连通分量中，只要含有一个奇环，那么显然其中的每个点都可以被包含在一个奇环中（考虑将两个环连接要么新加两条边，要么重合一条边，如果是一个奇环，一个偶环，那么一定可以拼成一个大的奇环），于是我们直接找到点双，然后用二分图染色（奇环一定不是二分图）来进行判断。</p>
<h3 id="solvedroad-construction-poj-3352">[Solved]Road Construction (POJ 3352)</h3>
<p>有一个岛上有 <span class="math inline">\(n\)</span> 个旅游景点，有 <span class="math inline">\(m\)</span> 条双向道路连接着它们。现在要修建一些额外的道路，使得任意一条道路封闭后游客都能从一个旅游景点到达任意的旅游景点。求最少需要修建的道路数量。</p>
<p><span class="math inline">\(3\le n\le 1\,000\)</span> <span class="math inline">\(2\le m\le 1\,000\)</span></p>
<p>边双连通分量缩点，得到 <span class="math inline">\(k\)</span> 棵树，将所有树连成环需要 <span class="math inline">\(k\)</span> 条边，每棵树少了两个叶子（不够就是清零），之后将剩下的叶子两两配对即可，若多出一个叶子还需要多补一条边。</p>
<h3 id="solvedmining-your-own-business-uva-1108">[Solved]Mining Your Own Business (UVA 1108)</h3>
<p>有一张无向图，选一些点涂黑，满足任意删除一个点后（可能是被涂黑的点），每个连通分量都有至少一个黑点。求最少涂黑的点数和方案数。</p>
<p><span class="math inline">\(1\le n\le 50\,000\)</span></p>
<p>因为是删点，考虑点双缩点，得到一棵圆方树，考虑每个方点下面需要一个黑点当且仅当其距离叶子的最远距离为 <span class="math inline">\(1\)</span>，特殊的，如果根的度为 <span class="math inline">\(1\)</span>，那么它也需要一个黑点；对于一个需要拥有黑点的方点，显然这个黑点可选的方案数是它下面的所有叶子数；于是直接在圆方树上树形 DP 即可。</p>
<h3 id="solvedequivalent-sets-hdu-3836">[Solved]Equivalent Sets (HDU 3836)</h3>
<p>给定一张有向图，求至少添加多少条边能使得其强连通。</p>
<p><span class="math inline">\(1\le n\le 20\,000\)</span> <span class="math inline">\(0\le m\le 50\,000\)</span></p>
<p>首先先强连通分量缩点，得到一张 DAG，然后考虑怎样连边是最优的。</p>
<p>把无入度点作为点集 <span class="math inline">\(S\)</span>，把无出度点作为点集 <span class="math inline">\(T\)</span>。</p>
<p>二分图连边表示 <span class="math inline">\(S\)</span> 点（入度为零）可以走到 <span class="math inline">\(T\)</span> 点（出度为零），</p>
<ul>
<li>先暴力匹配，表示每一个 <span class="math inline">\(S_i\)</span> 尽可能走一个互不相同的 <span class="math inline">\(T_i\)</span> 点，然后所有匹配边从 <span class="math inline">\(T_i\)</span> 向下一个匹配的 <span class="math inline">\(S_{i+1}\)</span> 连一条边，表示从 <span class="math inline">\(S_i\to T_i\to S_{i+1}\)</span>，如此往复，最终将最后一个 <span class="math inline">\(T_k\)</span> 连向开始时的 <span class="math inline">\(S_1\)</span>，此时形成一个环，是 SCC，然后剩下的没被选上的是不连通的。</li>
<li>如果是 <span class="math inline">\(S_i\)</span> 点表明他所有可以走到的 <span class="math inline">\(T\)</span> 都被其他 <span class="math inline">\(S\)</span> 走过去了，<span class="math inline">\(T\)</span> 也是一样，能走到他的 <span class="math inline">\(S\)</span> 都走到其他点 <span class="math inline">\(T\)</span> 了，于是上一步得到的 SCC 到剩下的 <span class="math inline">\(T\)</span> 一定有边，剩下的 <span class="math inline">\(S\)</span> 一定到 SCC 有边，就把每一对未匹配的 <span class="math inline">\(T\)</span> 向 <span class="math inline">\(S\)</span> 连一下边，这样匹配的 <span class="math inline">\(T\)</span> 和 <span class="math inline">\(S\)</span> 会形成环，这样可以尽可能多的匹配两边的点；</li>
<li>这样最后如果还剩下来就随便连了（SCC 连向剩 <span class="math inline">\(S\)</span>，剩 <span class="math inline">\(T\)</span> 连向 SCC ）。</li>
</ul>
<p>我们定义从 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边为反向边，这样，会发现前两步左右会将两侧的点一一配对，就都被连上了一条反向边，最后一步每个剩下的点只会有一条边，所以最少连边数量是 <span class="math inline">\(\max(|S|,|T|)\)</span>。</p>
<h3 id="solvedpursuit-for-artifacts-cf652e">[Solved]Pursuit For Artifacts (CF652E)</h3>
<p>给定一张简单无向连通图，边权为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>，求从 <span class="math inline">\(a\)</span> 到 <span class="math inline">\(b\)</span> 是否存在一条边权和非 <span class="math inline">\(0\)</span> 的且不经过重复边的路径（单次询问）。</p>
<p><span class="math inline">\(1\le n\le 300\,000\)</span> <span class="math inline">\(0\le m\le 300\,000\)</span></p>
<p>注意到一条边一定包含于一个点双，对于一个点双内的任意一条边和任意两个点，这两点间一定存在一条简单路径经过这条边，于是我们建出整张图的圆方树，将一个方点的权值定义为它代表的点双连通分量中的边是否存在权值为 <span class="math inline">\(1\)</span> 的边；考虑如何统计每条边在哪个 V-DCC，与点类似，我们只需要将遍历到的边压入栈中即可，每条边只入栈一次，找到 V-DCC 时同时将边弹出；最后将圆点的权值定义为 <span class="math inline">\(0\)</span>，然后爆搜查寻即可。</p>
<p>再来考虑边双怎么做，注意到一条边要么属于一个边双，要么是桥，且每条在边双中的边至少包含于一个简单环中，于是同样对于边双内的一条边和两个点，一定存在一条简单路径经过这条边，于是我们同样将一个缩完后的点的权值定义为这个点双中的所有边权的或，由于每个点一定只包含在同一个边双中于是我们可以直接判断一条边的两点是否在同一点双来得到这一点所在的点双，然后爆搜看路径上是否有边权或点权为 <span class="math inline">\(1\)</span>。</p>
<h3 id="solvedmuseums-tour-cf1137c">[Solved]Museums Tour (CF1137C)</h3>
<p>一个国家有 <span class="math inline">\(n\)</span> 个城市，和 <span class="math inline">\(m\)</span> 条单向道路，每周有 <span class="math inline">\(d\)</span> 天。每个城市都有一个博物馆，每天博物馆的开放情况只和是一周中的哪一天有关，即每 <span class="math inline">\(d\)</span> 天一个循环。</p>
<p>从一周中的第一天，城市 <span class="math inline">\(1\)</span> 开始，每天参观博物馆（如果开放），之后沿着一条边走到下一个城市。求无有个旅行团在城市 1 出发，当天是星期一。每天早上限的时间内最多能参观多少不同的博物馆。</p>
<p><span class="math inline">\(1\le n\le 100\,000\)</span> <span class="math inline">\(0\le m\le 100\,000\)</span> <span class="math inline">\(0\le d\le 50\)</span></p>
<p>由于 <span class="math inline">\(d\)</span> 的数量不大，考虑将每个点拆成 <span class="math inline">\(d\)</span> 个点，点 <span class="math inline">\((i,j)\)</span> 表示 <span class="math inline">\(i\)</span> 号点在星期 <span class="math inline">\(j\)</span>，于是将原图重新建图，假设原图中存在边 <span class="math inline">\(u\to v\)</span>，那么建新边 <span class="math inline">\((u,i)\to(v,i + 1)\)</span>，然后考虑得到的新图，显然在同一个强连通分量中的所有可行的博物馆一定可以在访问这个强连通分量时参观完，于是将每个强连通分量缩点，每个缩完的点的点权为这个强连通分量中所有的可行的博物馆，这个权值可以在统计强连通分量时同时计算，之后我们就是要找一条从 <span class="math inline">\(1\)</span> 开始的最长路。</p>
<p>现在来考虑这样做会不会算重，即将一个点算多次贡献。</p>
<p>假如可以从 <span class="math inline">\((u,i)\)</span> 走到 <span class="math inline">\((u,j)\)</span>，那么意味着原图上从 <span class="math inline">\(u\)</span> 走一条长度为 <span class="math inline">\((j-i)\bmod d\)</span> 的路径可以从 <span class="math inline">\(u\)</span> 走回 <span class="math inline">\(u\)</span>，那么在 <span class="math inline">\((u,j)\)</span> 顺着这条路径走 <span class="math inline">\(d-1\)</span> 次就可以走到 <span class="math inline">\((u,i)\)</span>，所以两者一定在同一强连通分量中，我们可以在 Tarjan 时直接处理。</p>
<p>注意 Tarjan 时递归层数可能会很多，<code>inline</code> 或许可以优化？</p>
<h3 id="solvedleaders-cf97e">[Solved]Leaders (CF97E)</h3>
<p>给定一张简单无向图，多次询问两个点之间是否存在长度为奇数的简单路径。</p>
<p><span class="math inline">\(1\le n\le 100\,000\)</span> <span class="math inline">\(0\le m\le 100\,000\)</span> <span class="math inline">\(1\le q\le 100\,000\)</span></p>
<p>注意到如果两个点之间存在一条路径，路径上经过了一条在奇环中的边，那么就一定存在一条长度为奇数的简单路径；或者说，只要路径上存在一条在奇环中的边，那么原本这条路径长度的奇偶性就可以被改变；同时注意到图中两点间的任意一条路径，都可以由另一条路径通过用某些环的一部分替换这条路径的一部分得到，于是我们考虑先找到一条初始的路径，再来考虑这条路径是否可以通过经过奇环改变/不改变奇偶性，于是我们考虑先得到原图的一棵生成树。</p>
<p>考虑在生成树上，如果两个点如果对于 LCA 所处的深度的奇偶性不同，那么两者之间一定存在一条长度为奇数的路径（就是树上的路径），否则我们需要看两者的树上路径上是否存在在奇环中的边，于是我们需要确定每条边是否在奇环中。</p>
<p>注意到在一个点双连通分量中，只要存在一个奇环，那么这个点双连通分量中的任意一条边都都可以找到一个包含这条边的奇环，于是我们直接求点双连通分量，然后二分图染色判断奇环，然后就可以得到每条边所处的点双连通分量（同上面 CF652E SOL.1 压栈方法），以及每个点双连通分量是否包含奇环。</p>
<p>然后直接树上倍增即可。</p>
<h3 id="solvedsimple-cycles-edges-cf962f">[Solved]Simple Cycles Edges (CF962F)</h3>
<p>给定一张简单无向图，求哪些边在恰好一个简单环内。</p>
<p><span class="math inline">\(1\le n\le 100\,000\)</span> <span class="math inline">\(0\le m\le 100\,000\)</span></p>
<p>由于在同一个点双连通分量中的任意一条边都被包含在至少一个简单环中，且如果一个点双连通分量中包含不只一个简单环，由于点双的性质，于是这多个环中的任意两个环至少需要两条额外的边或至少一条重合的边，这样形成的点双中的任意一条边都会被包含在大于一个简单环中，所以一条边被恰好包含在一个简单环中当且仅当他所在的点双中恰有一个简单环，于是可以直接求出 V-DCC，然后判断每个 V-DCC 的边数和点数是否相等。</p>
<h3 id="solvedcaterpillar-cf51f">[Solved]Caterpillar (CF51F)</h3>
<p>定义毛毛虫是一张<strong>无环图</strong>，满足存在一条路径即可使得每个点离这条路径的距离不超过 <span class="math inline">\(1\)</span>。给定一张无向图，现在可以每次合并两个顶点使得图变成毛毛虫。求最少需要的操作数。</p>
<p><span class="math inline">\(1\le n\le 2000\)</span> <span class="math inline">\(0\le m\le 10^5\)</span></p>
<p>由于是一个无环图，所以只要两点间有两条边不相交的路径就一定需要合并，于是一个边双连通分量最后一定会被缩成一个点。</p>
<p>现在我们来考虑缩点之后得到了一棵树如何处理。对于一棵树，显然骨干必然是去掉叶子后剩下的部分中的一条链，显然这条链的长度越长越好，于是应当选直径，直径之外的点（除了叶子）就顺着树的结构合并到直径上，一定是最优的合并方案，总共合并的次数也就是除了直径和叶子之外的所有点的个数。</p>
<p>由于图可能不连通，所以还需要把多个毛毛虫拼接，合并的次数就是之前树的数量减一。</p>
]]></content>
      <categories>
        <category>题单</category>
      </categories>
      <tags>
        <tag>双连通分量</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」CF487E Tourists</title>
    <url>/2021/11/12/CF487E/</url>
    <content><![CDATA[<blockquote>
<p>Time Limit: 2s | Memory Limit: 256MB | <a href="http://codeforces.com/problemset/problem/487/E">题目链接</a></p>
</blockquote>
<h2 id="题意简述">#题意简述</h2>
<p>给定一张 <span class="math inline">\(n(n\leq10^5)\)</span> 个点 <span class="math inline">\(m(m\leq10^5)\)</span> 条边的无向图，每个点有权值 <span class="math inline">\(w_i(w_i\leq10^9)\)</span>，有 <span class="math inline">\(q(q\leq10^5)\)</span> 次操作，分为以下两种：</p>
<ul>
<li>修改一个点的点权；</li>
<li>询问 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的所有简单路径中可能经过的最小的点权；</li>
</ul>
<h2 id="大体思路">#大体思路</h2>
<p>显然所经过的路径中至少可以同时经过两个点的边双连通分量中的所有点都可以被经过，于是考虑用圆方树将原图转化为一棵树，根据圆方树的性质：没有相邻的两个圆点或两个方点，于是在圆方树上两个圆点之间的简单路径中的每一个方点都至少会有两个相邻的圆点被经过，于是这个方点所代表的双连通分量一定可以被包含进路径。</p>
<p>我们考虑将每个方点的点权定义为所代表的边双连通分量中的点权最小值，注意到由于一个点可能被包含于多个边双连通分量，这样修改时不好维护方点的点权，考虑退而求其次，将方点的点权定义为子树中相邻圆点的最小点权，于是每个圆点有恰好有一个指定的方点，可以用 <code>std::multiset</code> 维护每个方点的子树中的相邻圆点的权值，修改时直接取出修改即可。</p>
<p>考虑查询，在转化为圆方树上的问题后，我们所求的就是树上的一条链上的最小点权，是树链剖分的简单应用；不过需要注意，根据我们上面方点的点权定义，当两点的 LCA 为方点时，方点上方的圆点的点权未被考虑，需要特判。</p>
<h2 id="时间复杂度分析">#时间复杂度分析</h2>
<p>由于每条边最多被遍历一次，于是建立圆方树的时间复杂度为 <span class="math inline">\(O(m)\)</span>，同时每个圆点（建立时）最多被加入一次 <code>std::multiset</code>，这一步的总体时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>考虑建立的方点数量是 <span class="math inline">\(O(n)\)</span> 级别的，于是树剖的两次 DFS 都是 <span class="math inline">\(O(n)\)</span> 的时间复杂度，由于线段树的节点数为 <span class="math inline">\(O(n)\)</span> 级别，建立线段树时每个节点最多访问一次，于是时间复杂度可以做到 <span class="math inline">\(O(n)\)</span>，这里采用的是统一将所有点权插入线段树，于是时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<p>最后分析每次操作。修改时，<code>std::multiset</code> 的查询、删除、插入都是 <span class="math inline">\(O(\log n)\)</span>，线段树上修改也是 <span class="math inline">\(O(\log n)\)</span>；查询时，重链的数量为 <span class="math inline">\(O(\log n)\)</span> 级别，每次线段树区间查询为 <span class="math inline">\(O(\log n)\)</span>，于是总体最差时间复杂度为 <span class="math inline">\(O(q\log^2n)\)</span>.</p>
<p>综上所述，总体时间复杂度可以做到 <span class="math inline">\(O(m+n+q\log^2n)\)</span>，下面的代码的时间复杂度为 <span class="math inline">\(O(m+n\log n+q\log^2n)\)</span>，由于差距的部分不是复杂度瓶颈，所以无伤大雅。</p>
<h2 id="code">#Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; ge[N], te[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ls, rs, val;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    Node p[N]; <span class="keyword">int</span> cnt, rt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">SegmentTree</span><span class="params">()</span> </span>&#123;rt = cnt = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        p[k].val = <span class="built_in">Min</span>(p[p[k].ls].val, p[p[k].rs].val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) k = ++ cnt; <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;p[k].val = c; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">insert</span>(p[k].ls, l, mid, x, c);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(p[k].rs, mid + <span class="number">1</span>, r, x, c);</span><br><span class="line">        <span class="built_in">pushup</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> INF; <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> p[k].val;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, res = INF;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) res = <span class="built_in">Min</span>(res, <span class="built_in">query</span>(p[k].ls, l, mid, x, y));</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; y) res = <span class="built_in">Min</span>(res, <span class="built_in">query</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gecnt</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">tecnt</span><span class="params">(<span class="number">1</span>)</span>, ghead[N], thead[N], n, m, q, w[N]</span>;</span><br><span class="line"><span class="keyword">int</span> bel[N], low[N], dfn[N], top[N], id[N], bcnt, T, stk[N], stp;</span><br><span class="line"><span class="keyword">int</span> f[N], siz[N], d[N], rk[N], son[N];</span><br><span class="line"></span><br><span class="line">multiset &lt;<span class="keyword">int</span>&gt; s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge_g</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ge[gecnt].u = u, ge[gecnt].v = v;</span><br><span class="line">    ge[gecnt].nxt = ghead[u], ghead[u] = gecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge_t</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    te[tecnt].u = u, te[tecnt].v = v;</span><br><span class="line">    te[tecnt].nxt = thead[u], thead[u] = tecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biconnect</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++ T; stk[++ stp] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ghead[x]; i; i = ge[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (!dfn[ge[i].v]) &#123;</span><br><span class="line">          <span class="built_in">biconnect</span>(ge[i].v);</span><br><span class="line">          low[x] = <span class="built_in">Min</span>(low[x], low[ge[i].v]);</span><br><span class="line">          <span class="keyword">if</span> (low[ge[i].v] == dfn[x]) &#123;</span><br><span class="line">              <span class="keyword">int</span> y; ++ bcnt;</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  y = stk[stp --];</span><br><span class="line">                  bel[y] = bcnt;</span><br><span class="line">                  <span class="built_in">add_edge_t</span>(bcnt, y);</span><br><span class="line">                  s[bcnt].<span class="built_in">insert</span>(w[y]);</span><br><span class="line">              &#125; <span class="keyword">while</span> (y != ge[i].v);</span><br><span class="line">              <span class="built_in">add_edge_t</span>(x, bcnt);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> low[x] = <span class="built_in">Min</span>(low[x], dfn[ge[i].v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    f[x] = fa, siz[x] = <span class="number">1</span>, d[x] = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = thead[x]; i; i = te[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (te[i].v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(te[i].v, x, dep + <span class="number">1</span>);</span><br><span class="line">        siz[x] += siz[te[i].v];</span><br><span class="line">        <span class="keyword">if</span> (siz[te[i].v] &gt; siz[son[x]])</span><br><span class="line">          son[x] = te[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    top[x] = t; id[x] = ++ T, rk[T] = x;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>; <span class="keyword">else</span> <span class="built_in">dfs2</span>(son[x], t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = thead[x]; i; i = te[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (te[i].v != f[x] &amp;&amp; te[i].v != son[x])</span><br><span class="line">        <span class="built_in">dfs2</span>(te[i].v, te[i].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    t.<span class="built_in">insert</span>(t.rt, <span class="number">1</span>, bcnt, id[x], c);</span><br><span class="line">    <span class="keyword">if</span> (bel[x]) &#123;</span><br><span class="line">        s[bel[x]].<span class="built_in">erase</span>(s[bel[x]].<span class="built_in">find</span>(w[x]));</span><br><span class="line">        s[bel[x]].<span class="built_in">insert</span>(c);</span><br><span class="line">        t.<span class="built_in">insert</span>(t.rt, <span class="number">1</span>, bcnt, id[bel[x]], *s[bel[x]].<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    w[x] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[top[x]] &lt; d[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        res = <span class="built_in">Min</span>(res, t.<span class="built_in">query</span>(t.rt, <span class="number">1</span>, bcnt, id[top[x]], id[x]));</span><br><span class="line">        x = f[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (id[x] &lt; id[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    res = <span class="built_in">Min</span>(res, t.<span class="built_in">query</span>(t.rt, <span class="number">1</span>, bcnt, id[y], id[x]));</span><br><span class="line">    <span class="keyword">if</span> (y &gt; n) res = <span class="built_in">Min</span>(res, w[f[y]]); <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add_edge_g</span>(u, v); <span class="built_in">add_edge_g</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    bcnt = n; <span class="built_in">biconnect</span>(<span class="number">1</span>);</span><br><span class="line">    T = <span class="number">0</span>; <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      t.<span class="built_in">insert</span>(t.rt, <span class="number">1</span>, bcnt, id[i], w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= bcnt; ++ i)</span><br><span class="line">      t.<span class="built_in">insert</span>(t.rt, <span class="number">1</span>, bcnt, id[i], *s[i].<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="keyword">char</span> opt; <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; opt; <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;C&#x27;</span>) <span class="built_in">modify</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="总结">#总结</h2>
<p>本题可以看做边双连通分量/圆方树的板子题，思维难度不大，主要是线段树、树链剖分等部分的细节较多，但整体实现较为容易。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
        <tag>圆方树</tag>
        <tag>图论</tag>
        <tag>树链剖分</tag>
        <tag>双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>「图论相关」双连通、桥与割点</title>
    <url>/2021/11/12/EBC-and-PBC/</url>
    <content><![CDATA[<blockquote>
<p>本文仍有一些 typo 和错误，以及部分需要补充的东西。</p>
</blockquote>
<h2 id="边双连通">#1.0 边双连通</h2>
<h3 id="定义">#1.1 定义</h3>
<p>给定简单无向图 <span class="math inline">\(G=(V,E)\)</span>，对于 <span class="math inline">\(u,v\in V\)</span>，如果 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 之间有两条<strong>边不相交</strong>的路径，那么称 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 边双连通，另一个等价的定义是如果删除图中的任意一条边，<span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 依旧连通，那么 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 边双连通。</p>
<p>如果 <span class="math inline">\(\forall u,v\in V\)</span>，<span class="math inline">\(u,v\)</span> 边双连通，那么图 <span class="math inline">\(G(V,E)\)</span> 边双连通。</p>
<p>如果删除一条边后图的连通性改变，那么这条边是<strong>桥</strong>。</p>
<h3 id="性质">#1.2 性质</h3>
<ol type="1">
<li><p>边双连通是等价关系，即</p>
<ul>
<li><span class="math inline">\(u\)</span> 和 <span class="math inline">\(u\)</span> 本身边双连通；</li>
<li>若 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 边双连通，那么 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(u\)</span> 边双连通；</li>
<li>若 <span class="math inline">\(u,v\)</span> 边双连通且 <span class="math inline">\(v,w\)</span> 边双连通，那么 <span class="math inline">\(u,w\)</span> 边双连通；</li>
</ul></li>
</ol>
<p>前两点很显然，下面只证明第三点：</p>
<p>容易知道，<span class="math inline">\(u,v\)</span> 之间有两条边不相交的路径，等价与两者之间的最小割 <span class="math inline">\(C(u,v)\geq2\)</span>，于是有 <span class="math display">\[
C(u,w)\geq\min\{C(u,v),C(v,w)\}\geq2
\]</span> 于是得证。</p>
<ol start="2" type="1">
<li>将边双连通图的每一条边定向，可以得到一张强连通图。</li>
</ol>
<p>考虑如何构造。我们直接 DFS，将每条边定向为它第一次被访问时的方向，由于 DFS 树上的每一条非树边都是后向边，于是显然得到的图是强连通图。</p>
<h3 id="如何求得">#1.3 如何求得</h3>
<p>类似上面的第二条性质，我们同样可以对于边双连通分量定向成为强连通分量，然后直接在定向后的图上 Tarjan 求强连通分量即可，注意到 Tarjan 的过程本身就是 DFS，于是不需要单独定向，直接在原图上 Tarjan 即可，只需注意本身记录的是双向边，不应当再次反向经过刚进入的边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> frm)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++ T;</span><br><span class="line">    stk[++ stp] = x, instk[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ghead[x]; i; i = ge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == (frm ^ <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[ge[i].v]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ge[i].v, i);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[ge[i].v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instk[ge[i].v])</span><br><span class="line">          low[x] = <span class="built_in">min</span>(low[x], dfn[ge[i].v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y; ++ scnt;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk[stp --];</span><br><span class="line">            bel[y] = scnt;</span><br><span class="line">            instk[y] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="点双连通">#2.0 点双连通</h2>
<h3 id="定义-1">#2.1 定义</h3>
<p>给定简单无向图 <span class="math inline">\(G=(V,E)\)</span>，这里假设 <span class="math inline">\(|V|\geq2\)</span>，对于 <span class="math inline">\(u,v\in V\)</span>，如果 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 之间有两条<strong>点不相交</strong>的路径，那么称 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 边双连通，另一个等价的定义是如果删除图中除 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 的任意一个点，<span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 依旧连通，那么 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 边双连通。</p>
<p>如果 <span class="math inline">\(\forall u,v\in V\)</span>，<span class="math inline">\(u,v\)</span> 点双连通，那么图 <span class="math inline">\(G(V,E)\)</span> 点双连通。</p>
<p>如果删除一个点后图的连通性改变，那么这个点是<strong>割点</strong>。</p>
<h3 id="性质-1">#2.2 性质</h3>
<ol type="1">
<li>点双连通是等价关系么？不是。</li>
</ol>
<p>考虑 <span class="math inline">\(1\leftrightarrow2\leftrightarrow3\)</span> 这样一个图，容易看出 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(2\)</span> 点双连通，<span class="math inline">\(2\)</span> 和 <span class="math inline">\(3\)</span> 点双连通，但是 <span class="math inline">\(1\)</span> 与 <span class="math inline">\(3\)</span> 并不是点双连通。</p>
<ol start="2" type="1">
<li>注意到最简单的点双连通分量是环，考虑如果两个环有边相交，那么显然这两个环应当在同一个点双连通分量，于是有<strong>每条边恰好属于一个边双连通分量</strong>。</li>
</ol>
<h3 id="构建">#2.3 构建</h3>
<p>现在我们考虑如何求出一个图中的所有点双连通分量，这里直接采用构建<strong>圆方树</strong>来处理点双连通分量。</p>
<p>在圆方树上，我们令一个圆点表示原图上一个点，一个方点表示一个点双连通分量，方点与所有在这个点双连通分量中的圆点相连，一个圆点可能与多个方点相连，显然在圆方树上不会存在两个相邻的圆点或方点。</p>
<p>具体的构造方式与 Tarjan 求强连通分量类似，具体见代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; ge[N], te[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gecnt</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">tecnt</span><span class="params">(<span class="number">1</span>)</span>, ghead[N], thead[N], T, n, bcnt</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge_t</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    te[tecnt].u = u, te[tecnt].v = v;</span><br><span class="line">    te[tecnt].nxt = thead[u], thead[u] = tecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biconnect</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++ T; stk[++ stp] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ghead[x]; i; i = ge[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (!dfn[ge[i].v]) &#123; <span class="comment">/*未访问过*/</span></span><br><span class="line">          <span class="built_in">biconnect</span>(ge[i].v);</span><br><span class="line">          low[x] = <span class="built_in">Min</span>(low[x], low[ge[i].v]);</span><br><span class="line">          <span class="comment">/*找到了一个边双连通分量*/</span></span><br><span class="line">          <span class="keyword">if</span> (low[ge[i].v] == dfn[x]) &#123;</span><br><span class="line">              <span class="keyword">int</span> y; ++ bcnt;</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  y = stk[stp --];</span><br><span class="line">                  bel[y] = bcnt;</span><br><span class="line">                  <span class="built_in">add_edge_t</span>(bcnt, y);</span><br><span class="line">                  s[bcnt].<span class="built_in">insert</span>(w[y]);</span><br><span class="line">              &#125; <span class="keyword">while</span> (y != ge[i].v);</span><br><span class="line">              <span class="built_in">add_edge_t</span>(x, bcnt);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> low[x] = <span class="built_in">Min</span>(low[x], dfn[ge[i].v]);</span><br><span class="line">      <span class="comment">/*这里必须是 dfn[ge[i].v]，因为一定在栈里，*/</span></span><br><span class="line">      <span class="comment">/*low[ge[i].v] 有可能在其他边双连通分量中更新*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*连通图只需要从一点开始，我们令圆点为原编号，方点为 n+1 以上编号*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">()</span> </span>&#123;bcnt = n; <span class="built_in">biconnect</span>(<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论相关</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>图论</tag>
        <tag>双连通分量</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」AtCoder Beginner Contest 226 题解</title>
    <url>/2021/11/11/AtCoder-ABC-226/</url>
    <content><![CDATA[<h2 id="a---round-decimals">#A - Round decimals</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 1024MB | <a href="https://atcoder.jp/contests/abc226/tasks/abc226_a">题目连接</a></p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>给定正实数 <span class="math inline">\(X(0\leq X\leq 100)\)</span>，输出距离 <span class="math inline">\(X\)</span> 最近的整数。</p>
<h3 id="大体思路">#大体思路</h3>
<p>直接四舍五入即可。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">int</span>)(x + <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="b---counting-arrays">#B - Counting Arrays</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 1024MB | <a href="https://atcoder.jp/contests/abc226/tasks/abc226_b">题目连接</a></p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定 <span class="math inline">\(n(n\leq2\cdot10^5)\)</span> 个有序序列，序列 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(l_i(\sum l_i\leq2\times10^5)\)</span> 个正整数，问有多少不同的序列。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>直接当成字符串进行哈希即可，由于字符集较大，采用双模数哈希保证正确性。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BASE1 = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BASE2 = <span class="number">13331</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD1 = <span class="number">19270817</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, l[N], cnt;</span><br><span class="line"></span><br><span class="line">map &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">bool</span>&gt; m[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(l[i]); <span class="keyword">int</span> k1 = <span class="number">0</span>, k2 = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l[i]; ++ j) &#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            k1 = (<span class="number">1ll</span> * k1 * BASE1 + x) % MOD1;</span><br><span class="line">            k2 = (<span class="number">1ll</span> * k2 * BASE2 + x) % MOD2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!m[l[i]][<span class="built_in">mp</span>(k1, k2)])</span><br><span class="line">          ++ cnt, m[l[i]][(<span class="built_in">mp</span>(k1, k2))] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, cnt); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="c---martial-artist">#C - Martial artist</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 1024MB | <a href="https://atcoder.jp/contests/abc226/tasks/abc226_c">题目连接</a></p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p><span class="math inline">\(n(n\leq2\cdot10^5)\)</span> 个节点，节点 <span class="math inline">\(i\)</span> 有代价 <span class="math inline">\(W_i\)</span> 和 <span class="math inline">\(K_i(\sum K_i\leq2\cdot10^5)\)</span> 个前置节点 <span class="math inline">\(A_{i,1}\dots A_{i,k_i}(A_{i,j}&lt; i)\)</span>，选择 <span class="math inline">\(i\)</span> 时 <span class="math inline">\(i\)</span> 的前置节点必须都选择，问选择 <span class="math inline">\(n\)</span> 号节点总共至少付出多少代价。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>一张 DAG，注意到 <span class="math inline">\(A_{i,j}&lt;i\)</span>，于是可以考虑从 <span class="math inline">\(n\)</span> 开始倒序加入选取的节点，然后将该节点的前置节点全部加入选择序列，同时统计答案即可。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, vis[N]; ll f[N], ans;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(f[i]), <span class="built_in">read</span>(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x; j &lt;= k; ++ j)</span><br><span class="line">          <span class="built_in">read</span>(x), pre[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; -- i) <span class="keyword">if</span> (vis[i]) &#123;</span><br><span class="line">        ans += f[i]; <span class="keyword">for</span> (<span class="keyword">auto</span> x : pre[i]) vis[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="d---teleportation">#D - Teleportation</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 1024MB | <a href="https://atcoder.jp/contests/abc226/tasks/abc226_d">题目连接</a></p>
</blockquote>
<h3 id="题意简述-3">#题意简述</h3>
<p>在二维平面上有 <span class="math inline">\(n(n\leq500)\)</span> 个点 <span class="math inline">\((a_i,b_i)(0\leq a_i,b_i\leq10^9)\)</span>，规定移动方式 <span class="math inline">\((x,y)\)</span> 为从 <span class="math inline">\((a,b)\)</span> 移动到 <span class="math inline">\((a+x,b+y)\)</span>，从点 <span class="math inline">\((a_i,b_i)\)</span> 移动到 <span class="math inline">\((a_j,b_j)\)</span> 仅能选取一种移动方式并反复使用，问使任意两个点可达至少需要多少中不同的移动方式。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>注意到得到的移动方式 <span class="math inline">\((x,y)\)</span> 一定有 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 互质，否则一定可以共同除以最大公因数得到 <span class="math inline">\((x&#39;,y&#39;)\)</span>，最终的总个数不会增多，于是我们暴力枚举任意两个点 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>，求出符合要求的 <span class="math inline">\((x,y)\)</span> 并用 <code>map</code> 去重即可。</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Abs</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> </span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Town</span> &#123;</span><span class="keyword">int</span> x, y;&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt;</span><br><span class="line"></span><br><span class="line">map &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">bool</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">read</span>(a[i].x), <span class="built_in">read</span>(a[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">int</span> dx = a[i].x - a[j].x;</span><br><span class="line">          <span class="keyword">int</span> dy = a[i].y - a[j].y;</span><br><span class="line">          <span class="keyword">int</span> g = <span class="built_in">gcd</span>(<span class="built_in">Abs</span>(dx), <span class="built_in">Abs</span>(dy));</span><br><span class="line">          <span class="keyword">if</span> (!m[<span class="built_in">mp</span>(dx / g, dy / g)])</span><br><span class="line">            ++ cnt, m[<span class="built_in">mp</span>(dx / g, dy / g)] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, cnt); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="e---just-one">#E - Just One</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 1024MB | <a href="https://atcoder.jp/contests/abc226/tasks/abc226_e">题目连接</a></p>
</blockquote>
<h3 id="题意简述-4">#题意简述</h3>
<p>给定一个 <span class="math inline">\(n(n\leq2\cdot10^5)\)</span> 个点 <span class="math inline">\(m(m\leq2\cdot10^5)\)</span> 条边的无向图（无重边、自环），现在每个点需要选定一条相邻的边定向为出边，每条边需要恰好被定向一次，问有多少种定向方法，对 <span class="math inline">\(998244353\)</span> 取模。</p>
<h3 id="大体思路-4">#大体思路</h3>
<p>注意到一个 <span class="math inline">\(k\)</span> 个点的连通块中应当恰好有 <span class="math inline">\(k\)</span> 条边被定向，于是显然只有一棵基环树可以有合法的定向方式，且恰好有两种，于是我们考虑每一个连通块，通过统计该连通块中点、边的个数判断该连通块是否是基环树，是则给答案乘上 <span class="math inline">\(2\)</span>，否则答案为 <span class="math inline">\(0\)</span>.</p>
<h3 id="code-4">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ecnt</span><span class="params">(<span class="number">1</span>)</span>, head[N], d[N], n, m, vis[N], p_num, e_num, ans</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v, ++ d[u];</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>; e_num += d[x]; ++ p_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (!vis[e[i].v]) <span class="built_in">dfs</span>(e[i].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m); ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v), <span class="built_in">add_edge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        p_num = <span class="number">0</span>, e_num = <span class="number">0</span>; <span class="built_in">dfs</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (e_num == (p_num &lt;&lt; <span class="number">1</span>)) (ans *= <span class="number">2</span>) %= MOD;</span><br><span class="line">        <span class="keyword">else</span> &#123;ans = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="f---score-of-permutations">#F - Score of Permutations</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 1024MB | <a href="https://atcoder.jp/contests/abc226/tasks/abc226_f">题目连接</a></p>
</blockquote>
<h3 id="题意简述-5">#题意简述</h3>
<p>对于 <span class="math inline">\(1,2,\dots,n(n\leq50)\)</span> 的一个排列 <span class="math inline">\(P=(p_1,p_2,\dots,p_n)\)</span>，他的价值 <span class="math inline">\(S(P)\)</span> 为：</p>
<ul>
<li>数列 <span class="math inline">\(T\)</span> 最初为 <span class="math inline">\(t_i=i\)</span>，如下变换的次数即为 <span class="math inline">\(P\)</span> 的价值，一次变化如下：对于 <span class="math inline">\(i\ne p_i\)</span> 的 <span class="math inline">\(t_i\)</span>，令 <span class="math inline">\(t_{p_i}=t_i\)</span>，所有数字变化同时发生，在至少一次变换后，如果 <span class="math inline">\(t_i=i\)</span>，那么变换结束。</li>
</ul>
<p>设 <span class="math inline">\(S_n\)</span> 为 <span class="math inline">\(n\)</span> 的所有排列的集合，给定 <span class="math inline">\(k\)</span>，求 <span class="math display">\[
(\sum_{P\in S_n}S(P)^K)\bmod 998244353,
\]</span></p>
<h3 id="大体思路-5">#大体思路</h3>
<p>首先考虑如何快速计算一个排列 <span class="math inline">\(P\)</span> 的价值，不难发现所有的 <span class="math inline">\(p_i\)</span> 会形成若干个环，显然变化总次数（<span class="math inline">\(P\)</span> 的价值）为所有环长的 LCM，于是我们发现一个排列的价值与仅与该排列形成的环的个数及每个环的长度有关，不难发现所有环的环长恰好是 <span class="math inline">\(n\)</span> 的一组<strong>划分数</strong>，由于 <span class="math inline">\(50\)</span> 的划分数仅有 <span class="math inline">\(204226\)</span> 种，每种不同的划分数的价值是容易得到的，下面考虑对于每种划分数出现的次数进行计数。</p>
<p>我们先考虑划分段，然后再考虑将划分得到的段连接成环。</p>
<p>考虑枚举 <span class="math inline">\(n\)</span> 的全排列，共有 <span class="math inline">\(n!\)</span> 种，现在将其划分为 <span class="math inline">\(m\)</span> 段，每段的长度为 <span class="math inline">\(l_i\)</span>，我们可以将其简记为有 <span class="math inline">\(f_i\)</span> 个长度为 <span class="math inline">\(l_i\)</span> 的段，设共有 <span class="math inline">\(m\)</span> 种不同的段长，于是考虑其中的每一段，对于相同的 <span class="math inline">\(l_i\)</span> 个数，显然被计数了 <span class="math inline">\(l_i!\)</span> 次，如 <span class="math inline">\(12|456\)</span>，后面的 <span class="math inline">\(456\)</span> 在 <span class="math inline">\(n\)</span> 的全排列中会被计数 <span class="math inline">\(3!=6\)</span> 次，<span class="math inline">\(12\)</span> 则会被计数 <span class="math inline">\(2!=2\)</span> 次，同时注意到 <span class="math inline">\(f_i\)</span> 个长度为 <span class="math inline">\(l_i\)</span> 的段之间是没有区别/顺序的，于是我们还需要除以 <span class="math inline">\(f_i!\)</span>，于是我们得到了将 <span class="math inline">\(n\)</span> 划分为 <span class="math inline">\(f_i,l_i\)</span> 对应段划分的所有方案，为 <span class="math display">\[
n!\cdot\prod_{i=1}^m\dfrac{1}{(l_i!)^{f_i}\cdot f_i!},
\]</span> 然后，我们考虑每个段划分如何连成一个环，也就是长度为 <span class="math inline">\(l_i\)</span> 的<strong>环排列数</strong>，为 <span class="math inline">\((l_i-1)!\)</span>，于是我们得到了一组划分的所有情况数 <span class="math display">\[
n!\cdot\prod_{i=1}^m\left(\dfrac{1}{(l_i!)^{f_i}\cdot f_i!}\cdot ((l_i-1)!)^{f_i}\right),
\]</span> 由于 <span class="math inline">\(50\)</span> 的划分数只有 <span class="math inline">\(204226\)</span> 种，所以我们直接 DFS 枚举划分数，同时维护对应的价值和对应的数量即可。</p>
<h3 id="code-5">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, fac[N], fac_p[N][N], res, inv_fac[N], inv_fac_p[N][N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">madd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;x = x + y &lt; MOD ? x + y : x + y - MOD;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (<span class="number">1ll</span> * x * y / <span class="built_in">gcd</span>(x, y)) % MOD;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * x % MOD;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>; x = <span class="number">1ll</span> * x * x % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    val = <span class="built_in">fpow</span>(val, k);</span><br><span class="line">    <span class="built_in">madd</span>(ans, <span class="number">1ll</span> * val * num % MOD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rst, <span class="keyword">int</span> lmt, <span class="keyword">int</span> val, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rst) &#123;<span class="built_in">calc</span>(val, num); <span class="keyword">return</span>;&#125; <span class="keyword">if</span> (rst &lt; lmt) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lmt; i &lt;= rst; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i * j &lt;= rst; ++ j) &#123;</span><br><span class="line">          <span class="keyword">int</span> new_num = <span class="number">1ll</span> * num * inv_fac_p[i][j] % MOD;</span><br><span class="line">          new_num = <span class="number">1ll</span> * new_num * inv_fac[j] % MOD * fac_p[i - <span class="number">1</span>][j] % MOD;</span><br><span class="line">          <span class="built_in">dfs</span>(rst - i * j, i + <span class="number">1</span>, <span class="built_in">lcm</span>(val, i), new_num);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(k); fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j)</span><br><span class="line">        fac_p[i][j] = <span class="built_in">fpow</span>(fac[i], j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">      inv_fac[i] = <span class="built_in">fpow</span>(fac[i], MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j)</span><br><span class="line">        inv_fac_p[i][j] = <span class="built_in">fpow</span>(fac_p[i][j], MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(n, <span class="number">1</span>, <span class="number">1</span>, fac[n]); <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="g---the-baggage">#G - The baggage</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 1024MB | <a href="https://atcoder.jp/contests/abc226/tasks/abc226_g">题目连接</a></p>
</blockquote>
<h3 id="题意简述-6">#题意简述</h3>
<p>有 <span class="math inline">\(a_i(1\leq i\leq5)\)</span> 个重量为 <span class="math inline">\(i\)</span> 的包裹，和 <span class="math inline">\(b_i(1\leq a_i\leq5)\)</span> 个力量为 <span class="math inline">\(i\)</span> 的人，每个人可以拿总重不超过自己力量上限的任意个包裹，问能否将所有的包裹都拿起。</p>
<h3 id="大体思路-6">#大体思路</h3>
<p>不知道这题为什么放在 G 题，明明就是个极为简单的贪心/yiw</p>
<p>首先不难想到我们一定是从大至小地考虑每个包裹，因为重量小的包裹可行的组合数更多，限制要更少，于是我们从大到小考虑每个包裹。</p>
<p>首先重量为 <span class="math inline">\(5\)</span> 的包裹显然只能让力量为 <span class="math inline">\(5\)</span> 的人拿，重量为 <span class="math inline">\(4\)</span> 的包裹可以让力量为 <span class="math inline">\(4\)</span> 或 <span class="math inline">\(5\)</span> 的人拿，如果让 <span class="math inline">\(4\)</span> 的人先拿，那么剩下的 <span class="math inline">\(5\)</span> 可以有组合 <span class="math inline">\(2,2,1\)</span> 或 <span class="math inline">\(3,2\)</span>，如果让 <span class="math inline">\(5\)</span> 先拿，那么结合省下的 <span class="math inline">\(4\)</span> 只剩下组合 <span class="math inline">\(2,2,1\)</span>，显然让 <span class="math inline">\(4\)</span> 先拿更优。</p>
<p>然后考虑 <span class="math inline">\(3\)</span> 以怎样的顺序进行，</p>
<p>以同样的方式不难证明，重量 <span class="math inline">\(3\)</span> 优先选力量 <span class="math inline">\(3\)</span> 一定不会更差；然后考虑如果再选 <span class="math inline">\(4\)</span>，那么与剩下的 <span class="math inline">\(5\)</span> 组合有 <span class="math inline">\(1,2,3\)</span> 和 <span class="math inline">\(1,1,2,2\)</span>，如果选 <span class="math inline">\(5\)</span>，那么与剩下的 <span class="math inline">\(4\)</span> 组合有 <span class="math inline">\(2,2,2\)</span> 和 <span class="math inline">\(1,1,2,2\)</span> 和 <span class="math inline">\(1,2,3\)</span>，显然先选 <span class="math inline">\(5\)</span> 剩下的可行组合方式、可兼容的 <span class="math inline">\(2\)</span> 更多，于是重量 <span class="math inline">\(3\)</span> 的选择顺序一定是 <span class="math inline">\(3,5,4\)</span>.</p>
<p>最后 <span class="math inline">\(2\)</span> 和 <span class="math inline">\(1\)</span> 的选择顺序都是从大到小榨取剩余人的剩余价值即可。</p>
<p>注意到为了保证组合的正确，我们每次让力量为 <span class="math inline">\(x\)</span> 的人拿重量 <span class="math inline">\(y\)</span> 的包裹仅拿 <span class="math inline">\(1\)</span> 个，然后将它加入到 <span class="math inline">\(x-y\)</span> 力量的人中即可。</p>
<p><a href="https://atcoder.jp/contests/abc226/editorial/2897">原题题解</a>好像给了一个极其严谨的证明，有兴趣的话可以去看看。</p>
<p>（<del>OI 不需要证明；贪心，狗都不证！（狗头保命）</del>）</p>
<h3 id="code-6">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t; ll a[<span class="number">6</span>], b[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ll z = <span class="built_in">min</span>(a[x], b[y]);</span><br><span class="line">    a[x] -= z, b[y] -= z, b[y - x] += z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MAIN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++ i) <span class="built_in">read</span>(b[i]);</span><br><span class="line">    a[<span class="number">0</span>] = b[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pick</span>(<span class="number">5</span>, <span class="number">5</span>); <span class="built_in">pick</span>(<span class="number">4</span>, <span class="number">4</span>); <span class="built_in">pick</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">pick</span>(<span class="number">3</span>, <span class="number">3</span>); <span class="built_in">pick</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="built_in">pick</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">2</span>; -- i) <span class="built_in">pick</span>(<span class="number">2</span>, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">1</span>; -- i) <span class="built_in">pick</span>(<span class="number">1</span>, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (a[i]) &#123;<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="built_in">read</span>(t); <span class="keyword">while</span> (t --) <span class="built_in">MAIN</span>(); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="h---random-kth-max">#H - Random Kth Max</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 1024MB | <a href="https://atcoder.jp/contests/abc226/tasks/abc226_h">题目连接</a></p>
</blockquote>
<h3 id="题意简述-7">#题意简述</h3>
<p>有 <span class="math inline">\(n(n\leq10^5)\)</span> 个连续随机变量 <span class="math inline">\(a_i\)</span> ，每个变量 <span class="math inline">\(a_i\)</span> 有一个取值范围 <span class="math inline">\([l_i,r_i](0\leq l_i&lt;r_r\leq100)\)</span>，<span class="math inline">\(a_i\)</span> 等概率取到该区间内的任何数，为这 <span class="math inline">\(a_i\)</span> 个数中的期望第 <span class="math inline">\(k\)</span> 大，答案对 <span class="math inline">\(998244353\)</span> 取模。</p>
<h3 id="大体思路-7">#大体思路</h3>
<p>不会，咕着～</p>
<h2 id="总结">#总结</h2>
<p>感觉这场 ABC 除了 H 以外也就是普及组水平，但是 100 min 写完雀食颇具难度，wtcl /kk</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>思维</tag>
        <tag>计数</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP冲刺-TEST17 总结</title>
    <url>/2021/11/10/ZROI-21-NOIP-SP-TEST17/</url>
    <content><![CDATA[<h2 id="屑在前面">#屑在前面</h2>
<p>由于身体原因及某几场考试的 T3、T4 不可补，于是中间就咕咕咕了几篇，补不补随缘吧/wq</p>
<h2 id="t1-博弈">#T1 博弈</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 512MiB | <a href="http://www.zhengruioi.com/contest/1040/problem/2144">题目连接</a></p>
</blockquote>
<h3 id="大体思路">#大体思路</h3>
<p>首先显然开环的顺序由先手决定，考虑大于等于四个结的环，如果后手不选择交换，先手一定只能拿到 4 个，如果选择交换那么先手一定一个都拿不到，所以显然先手会选择从小到大开环，然后我们 DP 一遍即可，时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<blockquote>
<p>数据范围只有 <span class="math inline">\(100\)</span> 就离大谱...</p>
</blockquote>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dp[N][<span class="number">2</span>][<span class="number">2</span>]; <span class="keyword">int</span> n, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + a[i] - <span class="number">4</span> &gt; dp[i][<span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">0</span>] = dp[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + <span class="number">4</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + a[i] - <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] + a[i] - <span class="number">4</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + <span class="number">4</span>;</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">1</span>] = dp[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] + a[i] - <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + a[i] &gt; dp[i][<span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = dp[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + a[i] &gt; dp[i][<span class="number">0</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = dp[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld&quot;</span>, dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t2-齿轮">#T2 齿轮</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 512MiB | <a href="http://www.zhengruioi.com/contest/1040/problem/2145">题目连接</a></p>
</blockquote>
<h3 id="大体思路-1">#大体思路</h3>
<p>注意到在同一连通块中的任意两个齿轮之间的转速关系仅与两者的齿数有关，中间的所有齿轮的影响都可以被抵消掉，于是我们可以将一个连通块中的所有齿轮根据旋转方向的不同分为两个不交的集合（是二分图），考虑将两个齿轮咬合后连通块锁死当且仅当两者咬合前在同一连通块且所属集合相同，于是我们需要维护每个齿轮所属的连通块及所属的集合。</p>
<p>当两个连通块合并时，采用启发式合并，将齿轮数小的集合并到较大的集合中，若其中一方锁死，则整体锁死，否则当咬合的两个齿轮咬合前所属的集合相同时，应当将较小的集合中的所有点所属的集合取反，均摊后时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<p>对于修改齿数及询问直接处理即可，整体时间复杂度为 <span class="math inline">\(O((q+n)\log n)\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>; x = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> nxt, u, v;&#125; e[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], <span class="built_in">cnt</span>(<span class="number">1</span>), n, m, T, a[N];</span><br><span class="line"><span class="keyword">int</span> ans, val, siz[N], f[N], bel[N];</span><br><span class="line"><span class="keyword">bool</span> locked[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span> (x != f[x]) x = f[x] = f[f[x]]; <span class="keyword">return</span> x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[cnt].u = u, e[cnt].v = v;</span><br><span class="line">    e[cnt].nxt = head[u], head[u] = cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    bel[u] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span>(e[i].v != fa) <span class="built_in">dfs</span>(e[i].v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) f[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) siz[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x, y, c; <span class="built_in">read</span>(opt);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) <span class="built_in">read</span>(x), <span class="built_in">read</span>(c), a[x] = c;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> fu = <span class="built_in">find</span>(x), fv = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (siz[fu] &gt; siz[fv])</span><br><span class="line">              <span class="built_in">swap</span>(x, y), <span class="built_in">swap</span>(fu, fv);</span><br><span class="line">            <span class="keyword">if</span> (fu == fv) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bel[x] == bel[y])</span><br><span class="line">                  locked[fv] = <span class="literal">true</span>;	</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                siz[fv] += siz[fu], f[fu] = fv;</span><br><span class="line">                <span class="keyword">if</span> (bel[x] == bel[y]) <span class="built_in">dfs</span>(x, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">                <span class="keyword">if</span> (locked[fu]) locked[fv] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">read</span>(x), <span class="built_in">read</span>(y), <span class="built_in">read</span>(c);</span><br><span class="line">            <span class="keyword">int</span> fu = <span class="built_in">find</span>(x), fv = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (fu != fv) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">continue</span>;&#125; </span><br><span class="line">            <span class="keyword">if</span> (locked[fu]) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> fst = c * a[x], scd = a[y];</span><br><span class="line">                <span class="keyword">int</span> g = <span class="built_in">gcd</span>(fst, scd); fst /= g, scd /= g;</span><br><span class="line">                <span class="keyword">if</span> (bel[x] != bel[y]) fst = -fst;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, fst, scd); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t3-排班方案">#T3 排班方案</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 512MiB | <a href="http://www.zhengruioi.com/contest/1040/problem/2146">题目连接</a></p>
</blockquote>
<h3 id="大体思路-2">#大体思路</h3>
<p>简单颓一颓柿子不难得到： <span class="math display">\[
\prod_{i=1}^n(d_{i-1}-(i-1)+d_i-d_{i-1})=\prod_{i=1}^n(d_i-i+1)=C,
\]</span> 由于限制 <span class="math inline">\(d_{i-1}\leq d_i\)</span>，于是应当有 <span class="math inline">\(d_{i-1}-(i-1)+1\leq d_i-i+1+1\)</span>，于是考虑从小到大枚举 <span class="math inline">\(C\)</span> 的因数作为 <span class="math inline">\(d_{n}-n+1\)</span>，然后根据直接暴力 DFS，显然剩下的越大越好，于是直接贪心构造剩下的序列即可，这样的递归不会超过 <span class="math inline">\(n\)</span> 层，于是跑满的时间复杂度为 <span class="math inline">\(O(n\sqrt n)\)</span>，简单剪剪枝就能过了。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, c, d[N], dv[N], dcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lmt, <span class="keyword">int</span> rst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rst == <span class="number">1</span>) &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) d[i] = <span class="number">1</span>; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rst &lt;= lmt) &#123;d[x] = rst; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; x; ++ i) d[i] = <span class="number">1</span>; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= rst &amp;&amp; i &lt;= lmt; ++ i) <span class="keyword">if</span> (!(rst % i)) &#123;</span><br><span class="line">        mx = <span class="built_in">Max</span>(mx, i); </span><br><span class="line">        <span class="keyword">if</span> (rst / i &lt;= lmt) &#123;d[x] = rst / i; <span class="keyword">return</span> <span class="built_in">solve</span>(x - <span class="number">1</span>, d[x] + <span class="number">1</span>, i);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mx) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> d[x] = mx;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve</span>(x - <span class="number">1</span>, d[x] + <span class="number">1</span>, rst / mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MAIN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(c); dcnt = <span class="number">0</span>; <span class="keyword">bool</span> flg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) d[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= c &amp;&amp; !flg; ++ i) <span class="keyword">if</span> (!(c % i)) &#123;</span><br><span class="line">        dv[++ dcnt] = c / i; d[n] = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(n - <span class="number">1</span>, d[n] + <span class="number">1</span>, c / i)) flg = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flg) <span class="keyword">for</span> (<span class="keyword">int</span> i = dcnt; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">        d[n] = dv[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(n - <span class="number">1</span>, d[n] + <span class="number">1</span>, c / dv[i])) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, d[i] + i - <span class="number">1</span>); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="built_in">read</span>(t); <span class="keyword">while</span> (t --) <span class="built_in">MAIN</span>(); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t4-简单的数据结构题">#T4 简单的数据结构题</h2>
<blockquote>
<p>Time Limit: 3s | Memory Limit: 512MiB | <a href="http://www.zhengruioi.com/contest/1040/problem/2147">题目连接</a></p>
</blockquote>
<h3 id="大体思路-3">#大体思路</h3>
<p>考虑将询问离线，然后维护以 <span class="math inline">\(i\)</span> 为右端点的所有不同的区间与，同时记录以该值为区间与的左端点的范围（考虑区间与一定是单调不降的），显然这个左端点范围内的所有都可以与 <span class="math inline">\(i\)</span> 组合，这样的区间与最多只会有 <span class="math inline">\(\log a_i=30\)</span> 种，然后考虑将这个序列从以 <span class="math inline">\(i-1\)</span> 为右端点转移到以 <span class="math inline">\(i\)</span> 为右端点，显然只需要加入一个 <span class="math inline">\(a_i\)</span>，然后将所有的原本的区间与全部与上一个 <span class="math inline">\(a_i\)</span>，同时去重，这一步的复杂度为 <span class="math inline">\(O(\log n)\)</span>，然后检查所有的区间与，如果是完全平方数，那么就将该区间与对应的左端点区间全部加一，最后对于每个询问检查对应区间和即可，注意每一次修改都是在之前的基础上进行修改。时间复杂度为 <span class="math inline">\(O(q\log n+n\log n\log a)\)</span>.</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pbk(x) push_back(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> l, r, val;&#125; e[N], ne[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    ll val[<span class="number">2</span>][N]; <span class="keyword">int</span> lmt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;lmt = x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;<span class="keyword">while</span> (lmt) val[<span class="number">0</span>][lmt] = val[<span class="number">1</span>][lmt] = <span class="number">0</span>, lmt --;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, ll y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= lmt; i += (i &amp; -i))</span><br><span class="line">          val[<span class="number">0</span>][i] += y, val[<span class="number">1</span>][i] += y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= (i &amp; -i))</span><br><span class="line">          res += <span class="number">1ll</span> * (x + <span class="number">1</span>) * val[<span class="number">0</span>][i] - val[<span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll c)</span> </span>&#123;<span class="built_in">change</span>(x, c), <span class="built_in">change</span>(y + <span class="number">1</span>, -c);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ask</span>(y) - <span class="built_in">ask</span>(x - <span class="number">1</span>);&#125;</span><br><span class="line">&#125; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, q, a[N], cnt, tot; ll ans[N];</span><br><span class="line"></span><br><span class="line">vector &lt;pii &gt; sq[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sq[i].<span class="built_in">clear</span>();</span><br><span class="line">    t.<span class="built_in">reset</span>(); cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">int</span> dv = <span class="built_in">sqrt</span>(x); <span class="keyword">return</span> (dv * dv) == x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MAIN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(q); <span class="built_in">reset</span>(); t.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">read</span>(l), <span class="built_in">read</span>(r);</span><br><span class="line">        sq[r].<span class="built_in">pbk</span>(<span class="built_in">mp</span>(l, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        e[++ cnt] = (Node)&#123;i, i, a[i]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j) &#123;</span><br><span class="line">            Node now = e[j]; now.val &amp;= a[i];</span><br><span class="line">            <span class="keyword">if</span> (tot &amp;&amp; ne[tot].val == now.val)</span><br><span class="line">              ne[tot].r = now.r;</span><br><span class="line">            <span class="keyword">else</span> ne[++ tot] = now;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = tot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j) e[j] = ne[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j)</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">check</span>(e[j].val)) t.<span class="built_in">modify</span>(e[j].l, e[j].r, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> now : sq[i]) ans[now.sec] = t.<span class="built_in">query</span>(now.fir, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="built_in">read</span>(T); <span class="keyword">while</span> (T --) <span class="built_in">MAIN</span>(); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我想了好久才想出这题咋做这档事 - 9</title>
    <url>/2021/11/05/some-solutions-9/</url>
    <content><![CDATA[<h2 id="prob.-1-uva1401-remember-the-word">#Prob. 1 UVA1401 Remember the Word</h2>
<blockquote>
<p>Time Limit: 3s | Memory Limit: N/A MB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>给定一个字符串 <span class="math inline">\(S(|S|\leq3\cdot10^5)\)</span> 以及 <span class="math inline">\(n(n\leq4000)\)</span> 个单词 <span class="math inline">\(T_i(T_i\leq100)\)</span>，问有多少种方式将 <span class="math inline">\(S\)</span> 划分为若干个 <span class="math inline">\(T_i\)</span> 拼接的形式，答案对 <span class="math inline">\(20071027\)</span> 取模。</p>
<h3 id="大体思路">#大体思路</h3>
<p>考虑在 trie 上进行 DP，设 <span class="math inline">\(\ell\)</span> 表示 <span class="math inline">\(|S|\)</span>，<span class="math inline">\(f_{i}\)</span> 表示拼出 <span class="math inline">\(S[i\dots\ell]\)</span>（字符串从 <span class="math inline">\(0\)</span> 开始编号，设 <span class="math inline">\(S_{\ell}\)</span> 为空）可行的方案数，显然有初始状态 <span class="math inline">\(f_{\ell}=1\)</span>，然后考虑从大到小枚举还需拼出的字符串的长度，从该字符串结尾开始向后寻找可行的单词，进行 DP 即可。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">20071027</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span><span class="keyword">int</span> ch[<span class="number">30</span>], tag;&#125; t[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, n, f[N], T;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, len = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = S[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!t[p].ch[k]) t[p].ch[k] = ++ cnt;</span><br><span class="line">        p = t[p].ch[k];</span><br><span class="line">    &#125;</span><br><span class="line">    t[p].tag |= <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++ j)</span><br><span class="line">          t[i].ch[j] = <span class="number">0</span>;</span><br><span class="line">        t[i].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mset</span>(f, <span class="number">0</span>); cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF) &#123;</span><br><span class="line">        <span class="built_in">clear</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">char</span> S[N]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, S);</span><br><span class="line">            <span class="built_in">insert</span>(S);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s); f[len] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; ++ j) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = s[j] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!t[p].ch[k]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> p = t[p].ch[k];</span><br><span class="line">                <span class="keyword">if</span> (t[p].tag) (f[i] += f[j + <span class="number">1</span>]) %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, ++ T, f[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-2-cf955d-scissors">#Prob. 2 CF955D Scissors</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 256MB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定两个串 <span class="math inline">\(s,t\)</span> 和整数 <span class="math inline">\(k(|t|\leq2\cdot k\leq|s|\leq5\cdot10^5)\)</span>，你可以在 <span class="math inline">\(s\)</span> 中取出任意的两个不相交的串，将它们按顺序拼在一起形成一个新串。求一种取串的方案使得 <span class="math inline">\(t\)</span> 是新串的子串。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>注意到如果 <span class="math inline">\(t\)</span> 是得到的新串的子串，那么一定是将 <span class="math inline">\(t\)</span> 分为了两部分（可能存在一部分是空串），于是我们对于每个前缀和后缀都求出最靠前/靠后的出现位置，最后尝试进行组合即可。</p>
<p>来考虑如何求出对应位置，考虑当前缀长度增加时，显然如果较短的前缀都不行的位置，较长的前缀一定也不行，于是这个位置一定是递增的，反之亦然。</p>
<p>于是我们就可以通过维护一个当前匹配位置的指针结合 Hash 求得上面两种位置。</p>
<p>总体时间复杂度为 <span class="math inline">\(O(|s|+|t|)\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l,x) memset(l,x,sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600010</span>;</span><br><span class="line"><span class="keyword">const</span> ull BASE = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="keyword">int</span> n, m, k, prep[N], sufp[N];</span><br><span class="line">ull hs[N], ht[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">Gethash</span><span class="params">(ull hash[], <span class="keyword">int</span> l, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash[l + len - <span class="number">1</span>] - hash[l - <span class="number">1</span>] * p[len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s + <span class="number">1</span>, t + <span class="number">1</span>); p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      hs[i] = hs[i - <span class="number">1</span>] * BASE + (ull)(s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">      ht[i] = ht[i - <span class="number">1</span>] * BASE + (ull)(t[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) p[i] = p[i - <span class="number">1</span>] * BASE;</span><br><span class="line">    <span class="built_in">mset</span>(prep, <span class="number">-1</span>); <span class="built_in">mset</span>(sufp, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>, l = <span class="number">1</span>; x &lt;= m; ++ x) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l + x - <span class="number">1</span> &lt;= n &amp;&amp; <span class="built_in">Gethash</span>(hs, l, x) != ht[x]) ++ l;</span><br><span class="line">        <span class="keyword">if</span> (l + x - <span class="number">1</span> &lt;= n) prep[x] = l + x - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>, l = k; x &lt; m; ++ x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prep[x] &gt;= k || prep[x] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= n &amp;&amp; (x &gt; l || <span class="built_in">Gethash</span>(hs, l - x + <span class="number">1</span>, x) != ht[x])) ++ l;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= n) prep[x] = l;</span><br><span class="line">        <span class="keyword">else</span> prep[x] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prep[<span class="number">0</span>] = k;</span><br><span class="line">    <span class="keyword">if</span> (~prep[m]) prep[m] = <span class="built_in">max</span>(prep[m], k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>, l = n; x &lt;= m; ++ x) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l - x + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp;</span><br><span class="line">               <span class="built_in">Gethash</span>(hs, l - x + <span class="number">1</span>, x) != <span class="built_in">Gethash</span>(ht, m - x + <span class="number">1</span>, x)) -- l;</span><br><span class="line">        <span class="keyword">if</span> (l - x + <span class="number">1</span> &gt;= <span class="number">1</span>) sufp[m - x + <span class="number">1</span>] = l - x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>, l = n - k + <span class="number">1</span>; x &lt; m; ++ x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sufp[m - x + <span class="number">1</span>] &lt;= n - k + <span class="number">1</span> || sufp[m - x + <span class="number">1</span>] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">1</span> &amp;&amp; (l &gt; n - x + <span class="number">1</span> || </span><br><span class="line">               <span class="built_in">Gethash</span>(hs, l, x) != <span class="built_in">Gethash</span>(ht, m - x + <span class="number">1</span>, x))) -- l;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= <span class="number">1</span>) sufp[m - x + <span class="number">1</span>] = l;</span><br><span class="line">        <span class="keyword">else</span> sufp[m - x + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (~sufp[<span class="number">1</span>]) sufp[<span class="number">1</span>] = <span class="built_in">min</span>(sufp[<span class="number">1</span>], n - k + <span class="number">1</span>);</span><br><span class="line">    sufp[m + <span class="number">1</span>] = n - k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prep[i] == <span class="number">-1</span> || sufp[i + <span class="number">1</span>] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (prep[i] &gt;= sufp[i + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k || m - i &gt; k) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != m)</span><br><span class="line">            <span class="keyword">if</span> (prep[i] &lt; k || n - sufp[i + <span class="number">1</span>] + <span class="number">1</span> &lt; k) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d %d&quot;</span>, prep[i] - k + <span class="number">1</span>, sufp[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-3-cf985f-isomorphic-strings">#Prob. 3 CF985F Isomorphic Strings</h2>
<blockquote>
<p>Time Limit: 3s | Memory Limit: 256MB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p>我们定义两个串 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 相似当且仅当存在一种映射，将 <span class="math inline">\(s\)</span> 中出现的每种字符映射到另一种字符上，按此映射进行变化，得到的字符串为 <span class="math inline">\(t\)</span>。</p>
<p>现给出一个长度为 <span class="math inline">\(n(n\leq2\cdot10^5)\)</span> 的字符串 <span class="math inline">\(S\)</span>，以及 <span class="math inline">\(m(m\leq2\cdot10^5)\)</span> 次询问，每次询问三个数 <span class="math inline">\(x,y,k\)</span>，表示询问从 <span class="math inline">\(x\)</span> 开始的长度为 <span class="math inline">\(k\)</span> 的字符串与从 <span class="math inline">\(y\)</span> 开始的长度为 <span class="math inline">\(k\)</span> 的字符串是否相似。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>我们可以考虑用 01 串去表示每个字符对应的位置序列（这个位置是该字符则是 1 否则是 0），于是注意到相似意味着将两个串的所有位置序列从小到大排序后，相同位置上对应的位置序列应当是相同的，我们可以用类似字符串哈希的方法对位置序列进行处理。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l,x) memset(l,x,sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> ull BASE = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> ull MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, q, x, y, len;</span><br><span class="line">ull h[N][<span class="number">30</span>], p[N], a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;q, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++ j)</span><br><span class="line">        h[i][j] = ((h[i - <span class="number">1</span>][j] * BASE) % MOD + (ull)((s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>) == j)) % MOD;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) p[i] = (p[i - <span class="number">1</span>] * BASE) % MOD;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++ i) &#123;</span><br><span class="line">            a[i] = (h[x + len - <span class="number">1</span>][i] - (h[x - <span class="number">1</span>][i] * p[len]) % MOD + MOD) % MOD;</span><br><span class="line">            b[i] = (h[y + len - <span class="number">1</span>][i] - (h[y - <span class="number">1</span>][i] * p[len]) % MOD + MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">27</span>); <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">27</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++ i)</span><br><span class="line">          <span class="keyword">if</span> (a[i] != b[i]) &#123;ok = <span class="literal">false</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (ok) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-4-jsoi2007文本生成器">#Prob. 4 [JSOI2007]文本生成器</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 128MB</p>
</blockquote>
<h3 id="题意简述-3">#题意简述</h3>
<p>给定一个有 <span class="math inline">\(n(n\leq60)\)</span> 个单词的字典（单词长度不超过 <span class="math inline">\(100\)</span>），问有多少个长度为 <span class="math inline">\(m(m\leq100)\)</span> 的文本是可读的，我们定义一段文本是可读的当且仅当存在至少一个字典中的词在该文本中出现。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>显然正难反易，我们可以求所有不可读的文本数量，然后用总数减去即可。</p>
<p>计数考虑在 AC 自动机上进行 DP，很套路的状态是 <span class="math inline">\(f_{i,j}\)</span> 表示当前处理的长度为 <span class="math inline">\(i\)</span>，当前在 AC 自动机的 <span class="math inline">\(j\)</span> 号节点上，显然有 <span class="math inline">\(f_{0,0}=1\)</span>，然后直接在 AC 自动机上进行转移即可，注意不要经过有终点标记的节点。</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span><span class="keyword">int</span> ch[<span class="number">30</span>], fail, tag;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC</span> &#123;</span></span><br><span class="line">    Trie t[N]; <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">AC</span><span class="params">()</span> </span>&#123;cnt = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!t[p].ch[k]) t[p].ch[k] = ++ cnt;</span><br><span class="line">            p = t[p].ch[k];</span><br><span class="line">        &#125;</span><br><span class="line">        t[p].tag |= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line">          <span class="keyword">if</span> (t[<span class="number">0</span>].ch[i]) q.<span class="built_in">push</span>(t[<span class="number">0</span>].ch[i]);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line">              <span class="keyword">if</span> (t[now].ch[i]) &#123;</span><br><span class="line">                  t[t[now].ch[i]].fail = t[t[now].fail].ch[i];</span><br><span class="line">                  t[t[now].ch[i]].tag |= t[t[t[now].fail].ch[i]].tag;</span><br><span class="line">                  q.<span class="built_in">push</span>(t[now].ch[i]);</span><br><span class="line">              &#125; <span class="keyword">else</span> t[now].ch[i] = t[t[now].fail].ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, f[N][N], ans;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>, (a *= a) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s), ac.<span class="built_in">insert</span>(s);</span><br><span class="line">    ac.<span class="built_in">build</span>(); f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= ac.cnt; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++ k)</span><br><span class="line">          <span class="keyword">if</span> (!ac.t[ac.t[j].ch[k]].tag)</span><br><span class="line">            (f[i][ac.t[j].ch[k]] += f[i - <span class="number">1</span>][j]) %= MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ac.cnt; ++ i)</span><br><span class="line">      (ans += f[m][i]) %= MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="built_in">fpow</span>(<span class="number">26</span>, m) - ans + MOD) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-5-heoi2012旅行问题">#Prob. 5 [HEOI2012]旅行问题</h2>
<blockquote>
<p>Time Limit: s | Memory Limit: MB</p>
</blockquote>
<h3 id="大体思路-4">#大体思路</h3>
<p>不难发现我们要找的也就是两个串的最长公共后缀，这与 AC 自动机 fail 边所指向的节点的定义相吻合，于是只需要找到建出 AC 自动机的 fail 树，找到对应的 LCA 即可。</p>
<h3 id="code-4">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span><span class="keyword">int</span> ch[<span class="number">26</span>], fail;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ecnt = <span class="number">1</span>, head[N], m; ll ans[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ds[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC_automaton</span> &#123;</span></span><br><span class="line">    Trie t[N]; <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">AC_automaton</span><span class="params">()</span> </span>&#123;cnt = <span class="number">0</span>, t[<span class="number">0</span>].fail = <span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        ds[id].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!t[p].ch[k]) &#123;</span><br><span class="line">                t[p].ch[k] = ++ cnt;</span><br><span class="line">                ans[cnt + <span class="number">1</span>] = (ans[p + <span class="number">1</span>] * <span class="number">26</span> % MOD + (ll)k) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            p = t[p].ch[k]; ds[id].<span class="built_in">push_back</span>(p + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line">          <span class="keyword">if</span> (t[<span class="number">0</span>].ch[i]) q.<span class="built_in">push</span>(t[<span class="number">0</span>].ch[i]);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line">              <span class="keyword">if</span> (t[now].ch[i]) &#123;</span><br><span class="line">                  t[t[now].ch[i]].fail = t[t[now].fail].ch[i];</span><br><span class="line">                  q.<span class="built_in">push</span>(t[now].ch[i]);</span><br><span class="line">              &#125; <span class="keyword">else</span> t[now].ch[i] = t[t[now].fail].ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_tree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) <span class="built_in">add</span>(t[i].fail + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], son[N], siz[N], top[N], T, f[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>, f[x] = fa, d[x] = d[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (e[i].v != fa) &#123;</span><br><span class="line">          <span class="built_in">dfs1</span>(e[i].v, x);</span><br><span class="line">          siz[x] += siz[e[i].v];</span><br><span class="line">          <span class="keyword">if</span> (siz[e[i].v] &gt; siz[son[x]])</span><br><span class="line">            son[x] = e[i].v;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++ T, top[x] = t;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) &#123;<span class="keyword">return</span>;&#125; <span class="built_in">dfs2</span>(son[x], t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (e[i].v != f[x] &amp;&amp; e[i].v != son[x])</span><br><span class="line">        <span class="built_in">dfs2</span>(e[i].v, e[i].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[a] != top[b]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[top[a]] &lt; d[top[b]]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        a = f[top[a]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[a] &lt; d[b]) &#123;<span class="built_in">swap</span>(a, b);&#125; <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="keyword">char</span> s[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        ac.<span class="built_in">insert</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    ac.<span class="built_in">build</span>(); ac.<span class="built_in">build_tree</span>();</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, k, l;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;i, &amp;j, &amp;k, &amp;l);</span><br><span class="line">        <span class="keyword">int</span> lca = <span class="built_in">LCA</span>(ds[i][j], ds[k][l]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[lca]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-6-uva1519-dictionary-size">#Prob. 6 UVA1519 Dictionary Size</h2>
<blockquote>
<p>Time Limit: 3s | Memory Limit: N/A MB</p>
</blockquote>
<div style="width=10px;line_height: 1px;">
<a href=https://dfkuaid.github.io/2021/08/22/UVA1519/ style="text-decoration:none;"> <font face="黑体" size=6> <b>「题解」UVA1519 Dictionary Size</b> </font> <font face="黑体" size=2> <br>  发表于 2021-08-22 14:52 Dfkuaid<br> </font> <font face="黑体" size=6> </font> <font face="FangSong" size=4> 摘要： UVA1519 Dictionary Size 题解 <br> </font>
<p align="right">
<font face="黑体" size=4> 阅读全文   <br> <u>   &gt;&gt;   </u>   <br> </font>
</p>
<p></a></p>
</div>
<h2 id="prob.-7-bzoj2462-矩阵模板-bzoj2351-matrix">#Prob. 7 BZOJ2462 矩阵模板 / BZOJ2351 Matrix</h2>
<blockquote>
<p>Time Limit: N/A s | Memory Limit: N/A MB</p>
</blockquote>
<h3 id="题意简述-4">#题意简述</h3>
<p>给定一个 <span class="math inline">\(M(M\leq1000)\)</span> 行 <span class="math inline">\(N(N\leq1000)\)</span> 列的 01 矩阵，以及 <span class="math inline">\(Q\)</span> 个 <span class="math inline">\(A(A\leq100)\)</span> 行 <span class="math inline">\(B(A\leq100)\)</span> 列的 01 矩阵，你需要求出这 <span class="math inline">\(Q\)</span> 个矩阵哪些在原矩阵中出现过。</p>
<h3 id="大体思路-5">#大体思路</h3>
<p>二维哈希板子。</p>
<h3 id="code-5">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l,x) memset(l,x,sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e8</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ull b1 = <span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">const</span> ull b2 = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a, b, q;</span><br><span class="line">ull r[N][N], c[N][N], p1[N * N], p2[N * N];</span><br><span class="line"><span class="keyword">bool</span> h[MOD + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;a, &amp;b);</span><br><span class="line">    p1[<span class="number">0</span>] = p2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a * b; ++ i)</span><br><span class="line">      p1[i] = p1[i - <span class="number">1</span>] * b1, p2[i] = p2[i - <span class="number">1</span>] * b2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">          <span class="keyword">char</span> t; cin &gt;&gt; t;</span><br><span class="line">          r[i][j] = t - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        r[i][j] += r[i - <span class="number">1</span>][j] * b1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        r[i][j] += r[i][j - <span class="number">1</span>] * b2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = b; j &lt;= m; j++) &#123;</span><br><span class="line">            ull tmp = r[i][j] - r[i - a][j] * p1[a]</span><br><span class="line">                 - r[i][j - b] * p2[b] + r[i - a][j - b] * p1[a] * p2[b];</span><br><span class="line">            h[tmp % MOD] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">              <span class="keyword">char</span> t; cin &gt;&gt; t;</span><br><span class="line">              c[i][j] = t - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line">                c[i][j] += c[i - <span class="number">1</span>][j] * b1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line">                c[i][j] += c[i][j - <span class="number">1</span>] * b2;</span><br><span class="line">        <span class="built_in">putchar</span>(h[c[a][b] % MOD] ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>); <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-8-leetcode201.-数字范围按位与">#Prob. 8 Leetcode201. 数字范围按位与</h2>
<blockquote>
<p>Time Limit: N/A s | Memory Limit: N/A MB</p>
</blockquote>
<h3 id="题意简述-5">#题意简述</h3>
<p>给定 <span class="math inline">\(l,r(1\leq l\leq r\leq2^{31}-1)\)</span>，求 <span class="math inline">\([l,r]\)</span> 中所有数 <span class="math inline">\(\&amp;\)</span> 运算的结果。</p>
<h3 id="大体思路-6">#大体思路</h3>
<p>注意到一但某一位向前进过位，那么之后的所有位置都不会有任何贡献，于是我们直接将 <span class="math inline">\(l,r\)</span> 分别转为二进制后从高位到低位扫一遍即可。</p>
<h3 id="code-6">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenl = <span class="number">0</span>, lenr = <span class="number">0</span>, L[<span class="number">35</span>], R[<span class="number">35</span>], ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l) L[lenl ++] = (l &amp; <span class="number">1</span>), l &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r) R[lenr ++] = (r &amp; <span class="number">1</span>), r &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (lenl != lenr) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lenl - <span class="number">1</span>; ~i; -- i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (L[i] != R[i]) <span class="keyword">break</span>;</span><br><span class="line">            ans += (L[i] &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-9-hdu3336-count-the-string">#Prob. 9 HDU3336 Count the string</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 32MB</p>
</blockquote>
<h3 id="题意简述-6">#题意简述</h3>
<p>给定字符串 <span class="math inline">\(S(|S|\leq2\cdot10^5)\)</span>，问每个前缀的出现次数和，对 <span class="math inline">\(10007\)</span> 取模。</p>
<h3 id="大体思路-7">#大体思路</h3>
<p>考虑到一个串的子串的出现位置集合一定包含这个串的出现集合，于是我们考虑 KMP 的 fail 边（next 边），它的定义是最长公共前后缀，于是我们求出 <code>next[]</code> 数组后从后往前按 next 边进行转移即可。</p>
<h3 id="code-7">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, nxt[N], num[N], ans;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s); ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) num[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">-1</span>; nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; n; ++ q) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; s[q] != s[p]) p = nxt[p];</span><br><span class="line">            ++ p, nxt[q + <span class="number">1</span>] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">          num[nxt[i]] += num[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          (ans += num[i]) %= MOD;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="prob.-10-poj2752-seek-the-name-seek-the-fame">#Prob. 10 POJ2752 Seek the Name, Seek the Fame</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 64MB</p>
</blockquote>
<h3 id="题意简述-7">#题意简述</h3>
<p>给定字符串 <span class="math inline">\(S\)</span>，求 <span class="math inline">\(S\)</span> 中每个既是前缀又是后缀的串的长度。</p>
<h3 id="大体思路-8">#大体思路</h3>
<p>注意到如果 <span class="math inline">\(T_1\)</span> 是最长的这样一个串，<span class="math inline">\(T_2\)</span> 一定既是 <span class="math inline">\(T_1\)</span> 的后缀又是 <span class="math inline">\(T_1\)</span> 的前缀，依次类推，而最长公共前后缀正与 KMP 的 <code>nxet[]</code> 的定义相符，所以我们只需要 KMP 求出 <code>next[]</code> 数组，然后一直向前跳即可。</p>
<h3 id="code-8">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len, nxt[N], cnt, ans[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">-1</span>; nxt[<span class="number">0</span>] = <span class="number">-1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; len; ++ q) &#123;</span><br><span class="line">            <span class="keyword">while</span> (~p &amp;&amp; s[p] != s[q]) p = nxt[p];</span><br><span class="line">            ++ p, nxt[q + <span class="number">1</span>] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = len;</span><br><span class="line">        <span class="keyword">while</span> (p) ans[++ cnt] = p, p = nxt[p];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>Trie</tag>
        <tag>KMP</tag>
        <tag>AC 自动机</tag>
        <tag>字符串哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我想了好久才想出这题咋做这档事 - 8</title>
    <url>/2021/11/05/some-solutions-8/</url>
    <content><![CDATA[<h2 id="prob.-1-cf1354d-multise">#Prob. 1 CF1354D Multise</h2>
<blockquote>
<p>Time Limit: 1.5s | Memory Limit: 28MB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>维护一个<strong>可重集</strong>，最初有 <span class="math inline">\(n(n\leq10^6)\)</span> 个元素 <span class="math inline">\(a_i(a_i\in[1,n])\)</span>，有 <span class="math inline">\(q(q\leq10^6)\)</span> 次操作，分为以下两种：</p>
<ul>
<li><span class="math inline">\(k&lt;0\)</span>，删除排名为 <span class="math inline">\(|k|\)</span> 的数字，若不存在，则忽略；</li>
<li><span class="math inline">\(k&gt;0\)</span>，加入一个 <span class="math inline">\(k\)</span>，满足 <span class="math inline">\(k\in[1,n]\)</span>；</li>
</ul>
<p>最后输出可重集中的任意一个数字即可。</p>
<h3 id="大体思路">#大体思路</h3>
<p>空间限制比较紧，平衡树很有可能会被卡空间，这里考虑用权值线段树动态开点实现，插入时直接单点加一即可，删除时类似于平衡树在线段树上二分即可（线段树本身就是二分结构），维护各个节点的区间和即可。时间、空间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, cnt, rt = <span class="number">1</span>, p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">     ++ p[k]; <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">add</span>(k &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    -- p[k]; <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, lsum = p[k &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (lsum &gt;= x) <span class="keyword">return</span> <span class="built_in">del</span>(k &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">del</span>(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x - lsum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q); <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k), <span class="built_in">add</span>(rt, <span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">0</span>) <span class="built_in">add</span>(rt, <span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[rt] &gt;= -k) <span class="built_in">del</span>(rt, <span class="number">1</span>, n, -k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p[rt] &lt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">del</span>(rt, <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-2-cf1181d-irrigation">#Prob. 2 CF1181D Irrigation</h2>
<blockquote>
<p>Time Limit: 2.5s | Memory Limit: 512MB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定 <span class="math inline">\(m(m\leq5\cdot10^5)\)</span> 个城市，每年会选出一个城市举办比赛，现给出前 <span class="math inline">\(n(n\leq5\cdot10^5)\)</span> 年城市举办比赛的情况。在接下来的年份中，每年的比赛会在举办比赛次数最小的城市举办，如果有很多城市举办次数均为最小值，则在编号最小的城市举办比赛。现给出 <span class="math inline">\(q(q\leq5\cdot10^5)\)</span> 个询问，每次询问第 <span class="math inline">\(K(n+1\leq K\leq10^{18})\)</span> 年在哪个城市举办比赛。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>注意到我们一定是先选累计举办次数少的城市举办比赛，于是我们考虑将最初的城市按照给出的累计比赛次数升序排序，然后将询问离线。</p>
<p>根据题面，一个城市 <span class="math inline">\(x\)</span> 被选的前提是最初选择次数比 <span class="math inline">\(x\)</span> 的次数少的城市，当前累计选择次数与 <span class="math inline">\(x\)</span> 相同，用此时前面所有的城市的累计选择次数的和减去初始的所有累计次数，我们称得到的值为 <span class="math inline">\(x\)</span> 的<strong>解锁值</strong>，如图（图咕咕咕了）</p>
<figure>
<img src="" alt="这里应当有一张图，但它咕咕咕了" /><figcaption aria-hidden="true">这里应当有一张图，但它咕咕咕了</figcaption>
</figure>
<p>我们将上面的语言用图形化的形式表示出来，也就是 <span class="math inline">\(x\)</span> 前面的矩形的高度与其持平时才可以将其解锁，显然每个 <span class="math inline">\(x\)</span> 的解锁值可以通过计算矩形面积的方式进行 <span class="math inline">\(O(n)\)</span> 递推。</p>
<p>于是我们将所有询问排序，对于每一个询问，考虑将这个询问之前能解锁的所有城市加入候选序列，然后发现在解锁下一个城市之前，已解锁区间一定是以一个按编号循环的形式进行选择，也就是当前询问次数减去解锁值后，模当前已解锁序列中的城市个数 <span class="math inline">\(tot\)</span> 得到的数（如果是 <span class="math inline">\(0\)</span> 那么就是 <span class="math inline">\(tot\)</span>），对应的就是应选城市的排名，用权值线段树维护即可。</p>
<h3 id="时间复杂度分析">#时间复杂度分析</h3>
<ul>
<li>排序为 <span class="math inline">\(O(n\log n+m\log m)\)</span>；</li>
<li>求解锁值为 <span class="math inline">\(O(n)\)</span>；</li>
<li>每个城市最多加入序列一次，总体为 <span class="math inline">\(O(n\log n)\)</span>，每个询问最多查询一次，总体时间复杂度为 <span class="math inline">\(O(m\log n)\)</span>；</li>
<li>综上所述，由于 <span class="math inline">\(n,m\)</span> 同阶，于是总体时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</li>
</ul>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">City</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, idx;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> City b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    ll val; <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t, cnt, ans[M], sum[N], rt = <span class="number">1</span>, p = <span class="number">1</span>;</span><br><span class="line">ll lmt[M], lim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;++ sum[k]; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">insert</span>(k &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    sum[k] = sum[k &lt;&lt; <span class="number">1</span>] + sum[k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;<span class="keyword">return</span> l;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, lsum = sum[k &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= lsum) <span class="keyword">return</span> <span class="built_in">kth</span>(k &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x - lsum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); ++ a[x].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) a[i].idx = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i].val);</span><br><span class="line">        q[i].val -= (ll)n, q[i].idx = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + m + <span class="number">1</span>);  <span class="built_in">sort</span>(q + <span class="number">1</span>, q + t + <span class="number">1</span>);</span><br><span class="line">    lim = a[m].val * m - n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">      lmt[i] = lmt[i - <span class="number">1</span>] + ((i - <span class="number">1</span>) * (a[i].val - a[i - <span class="number">1</span>].val));</span><br><span class="line">    <span class="built_in">insert</span>(rt, <span class="number">1</span>, m, a[p ++].idx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].val &gt; lim) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((q[i].val - lim) % m)</span><br><span class="line">              ans[q[i].idx] = (q[i].val - lim) % m;</span><br><span class="line">            <span class="keyword">else</span> ans[q[i].idx] = m;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= m &amp;&amp; q[i].val &gt; lmt[p])</span><br><span class="line">          <span class="built_in">insert</span>(rt, <span class="number">1</span>, m, a[p ++].idx);</span><br><span class="line">        <span class="keyword">int</span> rk = q[i].val - lmt[p - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (rk % (p - <span class="number">1</span>) == <span class="number">0</span>) rk = p - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> rk = rk % (p - <span class="number">1</span>);</span><br><span class="line">        ans[q[i].idx] = <span class="built_in">kth</span>(rt, <span class="number">1</span>, m, rk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-3-noi2004郁闷的出纳员">#Prob. 3 [NOI2004]郁闷的出纳员</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 128MB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p>经典老题了属于是。</p>
<p>给定一个下界 <span class="math inline">\(0\leq m\leq10^9\)</span>，有 <span class="math inline">\(n(n\leq3\cdot10^5)\)</span> 个操作，分为 <span class="math inline">\(4\)</span> 种：</p>
<ul>
<li><code>I k</code> 向数列中加入一个大小为 <span class="math inline">\(k\)</span> 的数，如果 <span class="math inline">\(k&lt;m\)</span>，则忽略；</li>
<li><code>A k</code> 把数列中所有的数加上 <span class="math inline">\(k\)</span>；</li>
<li><code>S k</code> 把数列中的所有数减去 <span class="math inline">\(k\)</span>，如果数列中有数小于 <span class="math inline">\(m\)</span>，那么将其从数列中删除；</li>
<li><code>F k</code> 查询第 <span class="math inline">\(k\)</span> 大的工资，没有则为 <code>-1</code>；</li>
</ul>
<p>最后输出一共删除了多少数（未加入不算）。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>权值线段树的水题，当然用平衡树也可以做。</p>
<p>对于所有的数加/减的操作，我们直接维护一个全局变量 <span class="math inline">\(\Delta\)</span>，表示真实值与当前权值线段树中的值的差值；</p>
<p>对于全局减后的删除操作，我们在权值线段树上二分，如果整个左子树都小于 <span class="math inline">\(m-\Delta\)</span>，那就整个删掉左子树（采用动态开点，直接令 <code>lson = 0</code>），然后递归右子树，否则递归左子树，显然这样的递归最多 <span class="math inline">\(O(\log n)\)</span> 层，于是单次删除的时间复杂度为 <span class="math inline">\(O(\log n)\)</span>.</p>
<p>单点插入 <span class="math inline">\(k\)</span> 直接经典插入即可，不过要注意 <span class="math inline">\(\Delta\)</span> 对于 <span class="math inline">\(k\)</span> 也是起作用的，但是它不应该起作用，所以我们需要插入的是 <span class="math inline">\(k-\Delta\)</span> 来抵消 <span class="math inline">\(\Delta\)</span> 的错误作用。</p>
<p>查询时直接在权值线段树上二分即可。</p>
<p>总体时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>，上面的 <span class="math inline">\(\Delta\)</span> 显然可以转变为直接对 <span class="math inline">\(m\)</span> 操作，两种方式本质相同。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> UPL = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ls, rs, sum;&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, ans, tag, rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    p[k].sum = p[p[k].ls].sum + p[p[k].rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) k = ++ cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;++ p[k].sum; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">add</span>(p[k].ls, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(p[k].rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt; x) <span class="built_in">update</span>(p[k].ls, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p[k].sum -= p[p[k].ls].sum;</span><br><span class="line">        ans += p[p[k].ls].sum; p[k].ls = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">if</span> (mid &lt; x) <span class="built_in">update</span>(p[k].rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, rsum = p[p[k].rs].sum;</span><br><span class="line">    <span class="keyword">if</span> (rsum &gt;= x) <span class="keyword">return</span> <span class="built_in">kth</span>(p[k].rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(p[k].ls, l, mid, x - rsum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">char</span> c; <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">add</span>(rt, -UPL, UPL, x - tag);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) tag += x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">            tag -= x;</span><br><span class="line">            <span class="built_in">update</span>(rt, -UPL, UPL, m - tag - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; p[rt].sum) &#123;<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">kth</span>(rt, -UPL, UPL, x) + tag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-4-cf600e-lomsat-gelral">#Prob. 4 CF600E Lomsat gelral</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 256MB</p>
</blockquote>
<h3 id="题意简述-3">#题意简述</h3>
<p>有一棵 <span class="math inline">\(n\)</span> 个结点的以 <span class="math inline">\(1\)</span> 号结点为根的<strong>有根树</strong>。</p>
<p>每个结点都有一个颜色，颜色是以编号表示的， <span class="math inline">\(i\)</span> 号结点的颜色编号为 <span class="math inline">\(c_i\)</span>.</p>
<p>如果一种颜色在以 <span class="math inline">\(x\)</span> 为根的子树内出现次数最多，称其在以 <span class="math inline">\(x\)</span> 为根的子树中占<strong>主导地位</strong>。显然，同一子树中可能有多种颜色占主导地位。</p>
<p>你的任务是对于每一个 <span class="math inline">\(i\in[1,n]\)</span>，求出以 <span class="math inline">\(i\)</span> 为根的子树中，占主导地位的颜色的编号和。</p>
<p><span class="math inline">\(n\le 10^5,c_i\le n\)</span>.</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>线段树合并水题，树上的每个节点都有一棵线段树，直接在树上自底向上合并即可。</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ls, rs; ll val, tot;&#125; p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c[N], rt[N], head[N], ecnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ref[N], rcnt, cnt; ll f[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">New</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> rcnt ? ref[rcnt --] : ++ cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    p[x].ls = p[x].rs = p[x].tot = p[x].val = <span class="number">0</span>;</span><br><span class="line">    ref[++ rcnt] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[p[k].ls].val &gt; p[p[k].rs].val)</span><br><span class="line">      p[k].val = p[p[k].ls].val, p[k].tot = p[p[k].ls].tot;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p[p[k].ls].val &lt; p[p[k].rs].val)</span><br><span class="line">      p[k].val = p[p[k].rs].val, p[k].tot = p[p[k].rs].tot;</span><br><span class="line">    <span class="keyword">else</span> p[k].val = p[p[k].ls].val, p[k].tot = p[p[k].ls].tot + p[p[k].rs].tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[cnt].u = u, e[cnt].v = v;</span><br><span class="line">    e[cnt].nxt = head[u], head[u] = cnt ++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) k = <span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;p[k].tot = (ll)l, ++ p[k].val; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(p[k].ls, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(p[k].rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> k1, <span class="keyword">int</span> k2, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k1 || !k2) <span class="keyword">return</span> k1 + k2;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        p[k1].val += p[k2].val;</span><br><span class="line">        <span class="built_in">recover</span>(k2); <span class="keyword">return</span> k1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    p[k1].ls = <span class="built_in">merge</span>(p[k1].ls, p[k2].ls, l, mid);</span><br><span class="line">    p[k1].rs = <span class="built_in">merge</span>(p[k1].rs, p[k2].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k1); <span class="built_in">recover</span>(k2); <span class="keyword">return</span> k1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(e[i].v, x);</span><br><span class="line">        rt[x] = <span class="built_in">merge</span>(rt[x], rt[e[i].v], <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x] = p[rt[x]].tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">        <span class="built_in">update</span>(rt[i], <span class="number">1</span>, n, c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-5-poi2011rot-tree-rotations">#Prob. 5 [POI2011]ROT-Tree Rotations</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 128MB</p>
</blockquote>
<h3 id="题意简述-4">#题意简述</h3>
<p>给定一颗有 <span class="math inline">\(n\)</span> 个<strong>叶节点</strong>的二叉树。每个叶节点都有一个权值 <span class="math inline">\(p_i\)</span>（注意，根不是叶节点），所有叶节点的权值构成了一个 <span class="math inline">\(1 \sim n\)</span> 的排列。 对于这棵二叉树的任何一个结点，保证其要么是叶节点，要么左右两个孩子都存在。 现在你可以任选一些节点，交换这些节点的左右子树。 在最终的树上，按照先序遍历遍历整棵树并依次写下遇到的叶结点的权值构成一个长度为 <span class="math inline">\(n\)</span> 的排列，你需要最小化这个排列的逆序对数。</p>
<h3 id="大体思路-4">#大体思路</h3>
<p>首先不难看出，一个子树内的逆序对与外部是毫不相干的，于是考虑自底向上的合并，对于逆序对这个东西，很套路地考虑分治进行统计，对于当前区间，考虑中点左右分别在左右两棵子树的情况，然后对于交换与不交换分别统计答案，然后再分治到中点左右两个小区间，这一步可以在合并左右子树时一并完成。然后对于每个父节点，选择代价较小者即可。</p>
<h3 id="code-4">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> sum, ls, rs;&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt, rt;</span><br><span class="line">ll lsum, rsum, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    p[k].sum = p[p[k].ls].sum + p[p[k].rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) k = ++ cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;p[k].sum += <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">build</span>(p[k].ls, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">build</span>(p[k].rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> k1, <span class="keyword">int</span> k2, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k1 || !k2) <span class="keyword">return</span> k1 + k2;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;p[k1].sum += p[k2].sum; <span class="keyword">return</span> k1;&#125;</span><br><span class="line">    lsum += (ll)(p[p[k1].rs].sum * p[p[k2].ls].sum);</span><br><span class="line">    rsum += (ll)(p[p[k2].rs].sum * p[p[k1].ls].sum);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    p[k1].ls = <span class="built_in">merge</span>(p[k1].ls, p[k2].ls, l, mid);</span><br><span class="line">    p[k1].rs = <span class="built_in">merge</span>(p[k1].rs, p[k2].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k1); <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, op; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;op);</span><br><span class="line">    <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">        <span class="keyword">int</span> ls = <span class="built_in">dfs</span>(), rs = <span class="built_in">dfs</span>();</span><br><span class="line">        lsum = rsum = <span class="number">0</span>;</span><br><span class="line">        p = <span class="built_in">merge</span>(ls, rs, <span class="number">1</span>, n);</span><br><span class="line">        ans += <span class="built_in">Min</span>(lsum, rsum);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">build</span>(p, <span class="number">1</span>, n, op);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n); rt = <span class="built_in">dfs</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-6-hdu6606-distribution-of-books">#Prob. 6 HDU6606 Distribution of books</h2>
<blockquote>
<p>Time Limit: 8s | Memory Limit: 64MiB</p>
</blockquote>
<div style="width=10px;line_height: 1px;">
<a href=https://dfkuaid.github.io/2021/09/08/HDU6606/ style="text-decoration:none;"> <font face="黑体" size=6> <b>[题解]HDU6606 Distribution of books</b> </font> <font face="黑体" size=2> <br>  发表于 2021-09-08 11:31 Dfkuaid<br> </font> <font face="黑体" size=6> </font> <font face="FangSong" size=4> 摘要： HDU6606 Distribution of books 题解 <br> </font>
<p align="right">
<font face="黑体" size=4> 阅读全文   <br> <u>   &gt;&gt;   </u>   <br> </font>
</p>
<p></a></p>
</div>
<h2 id="prob.-7-hdu6609-find-the-answer">#Prob. 7 HDU6609 Find the answer</h2>
<blockquote>
<p>Time Limit: 4s | Memory Limit: 64MiB</p>
</blockquote>
<h3 id="题意简述-5">#题意简述</h3>
<p>给定一个长度为 <span class="math inline">\(n(n\leq2\cdot10^5)\)</span> 的序列 <span class="math inline">\(a_i(a_i\leq10^9)\)</span> 和上界 <span class="math inline">\(m(m\leq10^9)\)</span>，要求对于每个 <span class="math inline">\(i\)</span> 求出至少使多少个 <span class="math inline">\(a_k(1\leq k&lt;i)\)</span> 变为 <span class="math inline">\(0\)</span> 才能使得 <span class="math inline">\(\sum_{j=1}^ia_j\leq m\)</span>.</p>
<h3 id="大体思路-5">#大体思路</h3>
<p>将原题简单转换一下为：选出尽可能多的数使得和不超过 <span class="math inline">\(m\)</span>，那么一定是尽可能选小的，于是我们直接用权值线段树维护，查询时直接在权值线段树上二分即可。</p>
<h3 id="code-5">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ls, rs, tot; ll sum;&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, cnt, rt; ll a[N], m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">      p[i].sum = p[i].tot = p[i].ls = p[i].rs = <span class="number">0</span>;</span><br><span class="line">    cnt = rt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    p[k].sum = p[p[k].ls].sum + p[p[k].rs].sum;</span><br><span class="line">    p[k].tot = p[p[k].ls].tot + p[p[k].rs].tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) k = ++ cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;p[k].sum += x, ++ p[k].tot; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(p[k].ls, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(p[k].rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = s / l;</span><br><span class="line">        <span class="keyword">if</span> (res &lt;= p[k].tot) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p[k].tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; ll lsum = p[p[k].ls].sum;</span><br><span class="line">    <span class="keyword">if</span> (lsum &gt;= s) <span class="keyword">return</span> <span class="built_in">query</span>(p[k].ls, l, mid, s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p[p[k].ls].tot + <span class="built_in">query</span>(p[k].rs, mid + <span class="number">1</span>, r, s - lsum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - <span class="number">1</span> - <span class="built_in">query</span>(rt, <span class="number">0</span>, m, m - a[i]));</span><br><span class="line">            <span class="built_in">update</span>(rt, <span class="number">0</span>, m, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我想了好久才想出这题咋做这档事 - 7</title>
    <url>/2021/11/02/some-solutions-7/</url>
    <content><![CDATA[<h2 id="prob.-1-cf1527e-partition-game">#Prob. 1 CF1527E Partition Game</h2>
<blockquote>
<p>Time Limit: 3s | Memory Limit: 256MB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>给你一个长度为 <span class="math inline">\(n\)</span> 序列，定义其中一个连续子序列 <span class="math inline">\(t\)</span> 的代价为： <span class="math display">\[
cost(t)=\sum_{x\in set(t)}last(x)−first(x)
\]</span> 其中 <span class="math inline">\(set(t)\)</span> 表示该子序列的元素集合，<span class="math inline">\(last(x)\)</span> 表示 <span class="math inline">\(x\)</span> 在该子序列中最后一次出现的位置，<span class="math inline">\(first(x)\)</span> 表示 <span class="math inline">\(x\)</span> 在该子序列中第一次出现的位置。</p>
<p>也就是说一个连续子序列的贡献为对于其中每种元素最后一次出现的位置与第一次出现的位置的下标差的和。现在你要把原序列划分成 <span class="math inline">\(k\)</span> 个连续子序列，求最小代价和。</p>
<p>其中 <span class="math inline">\(1\leq n\leq35000,1\leq k\leq min(n,100),1\leq a_i \leq n\)</span>.</p>
<h3 id="大体思路">#大体思路</h3>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 为把前 <span class="math inline">\(i\)</span> 个数分为 <span class="math inline">\(j\)</span> 段的最小代价，通过枚举枚举最后一段的长度，有转移方程： <span class="math display">\[
f_{i,j}=\min_{1\leq k\leq i}\{f_{k-1,j-1}+cost(k,i)\},
\]</span> 其中 <span class="math inline">\(cost(i,j)\)</span> 表示将所有 <span class="math inline">\(a_k(k\in[i,j])\)</span> 划分为一段的代价，来考虑如何计算 <span class="math inline">\(cost(i,j)\)</span>，对于 <span class="math inline">\(a_j\)</span>，假设 <span class="math inline">\(\exists k\in[i,j-1]\)</span>，使得 <span class="math inline">\(a_k=a_j\)</span>，那么应当有 <span class="math display">\[
cost(i,j)=cost(i,j-1)+j-last_{a_j},
\]</span> 其中 <span class="math inline">\(last_{a_j}\)</span> 表示在 <span class="math inline">\([i,j-1]\)</span> 中 <span class="math inline">\(a_j\)</span> 最后一次出现的位置，否则就应当有 <span class="math inline">\(cost(i,j)=cost(i,j-1)\)</span>，这里我们<strong>将原本整个的贡献拆分为了许多段</strong>。</p>
<p>直接暴力的时间复杂度为 <span class="math inline">\(O(kn^2)\)</span>（<span class="math inline">\(cost\)</span> 可以 <span class="math inline">\(n^2\)</span> 预处理）。</p>
<p>考虑进行优化，我们拿出常用的方法：比较 <span class="math inline">\(f_{i,j}\)</span> 和 <span class="math inline">\(f_{i+1,j}\)</span> 的式子的区别： <span class="math display">\[
\begin{aligned}
f_{i,j}&amp;=\min_{1\leq k\leq i}\{f_{k-1,j-1}+cost(k, i)\},\\
f_{i+1,j}&amp;=\min_{1\leq k\leq i+1}\{f_{k-1,j-1}+cost(k,i+1)\}.\\
\end{aligned}
\]</span> 注意到上面两个式子仅有求 <span class="math inline">\(\min\)</span> 范围和 <span class="math inline">\(cost\)</span> 略有不同，于是考虑用一个数列维护<span class="math inline">\(j\)</span> 相同时的候选序列，发现当且仅当 <span class="math inline">\(k\leq last_{a_{i+1}}\)</span> 时 <span class="math inline">\(cost\)</span> 才会改变，且一定是增加了 <span class="math inline">\(i+1-last_{a_{i+1}}\)</span>，且 <span class="math inline">\(a_i\)</span> 的改变对于 <span class="math inline">\(a_{i+1}\)</span> 依旧有效，于是我们自前向后进行更新，对于求 <span class="math inline">\(\min\)</span> 的范围，我们只需要在求 <span class="math inline">\(f_{i,j}\)</span> 之前将 <span class="math inline">\(f_{i-1,j-1}\)</span> 插入到 <span class="math inline">\(i\)</span> 号位置即可。</p>
<p>于是我们只需要单点修改、区间修改以及区间取 <span class="math inline">\(\min\)</span> 三个操作，直接 <span class="math inline">\(k\)</span> 棵线段树即可。时间复杂度 <span class="math inline">\(O(kn\log n)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ls, rs, tag, minn;&#125; p[N * M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, rt[N], a[N], lst[N], f[N][M], ans = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    p[k].minn += x, p[k].tag += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    p[k].minn = <span class="built_in">Min</span>(p[p[k].ls].minn, p[p[k].rs].minn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(p[k].ls, p[k].tag);</span><br><span class="line">    <span class="built_in">update</span>(p[k].rs, p[k].tag);</span><br><span class="line">    p[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) k = ++ cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p[k].ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p[k].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;<span class="built_in">update</span>(k, c); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(p[k].ls, l, mid, x, y, c);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) <span class="built_in">modify</span>(p[k].rs, mid + <span class="number">1</span>, r, x , y, c);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> p[k].minn;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = INF; <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) ans = <span class="built_in">Min</span>(ans, <span class="built_in">query</span>(p[k].ls, l, mid, x, y));</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) ans = <span class="built_in">Min</span>(ans, <span class="built_in">query</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="built_in">mset</span>(f, <span class="number">0x3f</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">build</span>(rt[i], <span class="number">1</span>, n);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">Min</span>(i, m); ++ j) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(rt[j], <span class="number">1</span>, n, i, i, f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (lst[a[i]]) <span class="built_in">modify</span>(rt[j], <span class="number">1</span>, n, <span class="number">1</span>, lst[a[i]], i - lst[a[i]]);</span><br><span class="line">            f[i][j] = <span class="built_in">query</span>(rt[j], <span class="number">1</span>, n, <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        lst[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-2-cf1149c-tree-generator">#Prob. 2 CF1149C Tree Generator™</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 256MB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>定义一棵树的括号序列为从任意一点开始，每进入一个节点，就加入一个 <code>(</code>，每从一个节点退出，就加入一个 <code>)</code>，最终形成的序列。</p>
<p>给你一棵 <span class="math inline">\(n(n\leq10^5)\)</span> 个节点的树的括号序列，输出它的直径。</p>
<p>有 <span class="math inline">\(m(m\leq10^5)\)</span> 次询问，每次询问表示交换两个括号，输出交换两个括号后的直径（保证每次操作后都为一棵树）</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>不难（并不）发现一棵树的一条链在去掉中间所有匹配括号后一定形如下面的括号序列： <span class="math display">\[
\begin{aligned}
)))))\dots)))((((\dots((\\
)))))\dots)))))))))))))\\
(((((\dots(((((((((((((
\end{aligned}
\]</span> 于是我们考虑如何去找这样一条最长的去匹配括号序列，我们考虑将字符串的表示转化为数字的表示，不妨用 <span class="math inline">\(1\)</span> 表示 <span class="math inline">\((\)</span>，用 <span class="math inline">\(-1\)</span> 表示 <span class="math inline">\()\)</span>，我们可以把交换操作看作两次修改操作，显然无法离线，于是需要考虑通过可以快速合并的信息来得到最终的答案，这里我们考虑用线段树进行维护。</p>
<p>我们称 <code>)</code> 与 <code>(</code> 相交的地方是中间点，那么第二种情况可以看作中间点是最右端，第三种情况则是中间点在最左端。然后合并时考虑中间点在哪些位置，需要哪些值进行维护，解释起来有些麻烦，建议结合代码并画图理解。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ls, rs, s, lmx, rmn, lv, rv, lrv, v;&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, rt;</span><br><span class="line"><span class="keyword">char</span> S[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    p[k].s = p[p[k].ls].s + p[p[k].rs].s;</span><br><span class="line">    p[k].lmx = <span class="built_in">Max</span>(p[p[k].ls].lmx, p[p[k].rs].lmx + p[p[k].ls].s);</span><br><span class="line">    p[k].rmn = <span class="built_in">Min</span>(p[p[k].rs].rmn, p[p[k].ls].rmn + p[p[k].rs].s);</span><br><span class="line">    p[k].lv = <span class="built_in">Max</span>(<span class="built_in">Max</span>(p[p[k].ls].lv, p[p[k].rs].lv - p[p[k].ls].s),</span><br><span class="line">                  p[p[k].ls].lrv + p[p[k].rs].lmx);</span><br><span class="line">    p[k].rv = <span class="built_in">Max</span>(<span class="built_in">Max</span>(p[p[k].rs].rv, p[p[k].ls].rv + p[p[k].rs].s),</span><br><span class="line">                  p[p[k].rs].lrv - p[p[k].ls].rmn);</span><br><span class="line">    p[k].lrv = <span class="built_in">Max</span>(p[p[k].ls].lrv + p[p[k].rs].s, p[p[k].rs].lrv - p[p[k].ls].s);</span><br><span class="line">    p[k].v = <span class="built_in">Max</span>(<span class="built_in">Max</span>(p[p[k].ls].v, p[p[k].rs].lv - p[p[k].ls].rmn), </span><br><span class="line">                 <span class="built_in">Max</span>(p[p[k].rs].v, p[p[k].ls].rv + p[p[k].rs].lmx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) k = ++ cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        p[k].s = (S[l] == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">        p[k].lmx = <span class="built_in">Max</span>(p[k].s, <span class="number">0</span>); p[k].rmn = <span class="built_in">Min</span>(p[k].s, <span class="number">0</span>);</span><br><span class="line">        p[k].lrv = p[k].lv = p[k].rv = p[k].v = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p[k].ls, l, mid); <span class="built_in">build</span>(p[k].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        p[k].s = c, p[k].lmx = <span class="built_in">Max</span>(p[k].s, <span class="number">0</span>);</span><br><span class="line">        p[k].rmn = <span class="built_in">Min</span>(p[k].s, <span class="number">0</span>); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(p[k].ls, l, mid, x, c);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(p[k].rs, mid + <span class="number">1</span>, r, x, c);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, S + <span class="number">1</span>);</span><br><span class="line">    (n -= <span class="number">1</span>) &lt;&lt;= <span class="number">1</span>; <span class="built_in">build</span> (rt, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[rt].v);</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (S[a] != S[b]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(S[a], S[b]);</span><br><span class="line">            <span class="built_in">modify</span>(rt, <span class="number">1</span>, n, a, (S[a] == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line">            <span class="built_in">modify</span>(rt, <span class="number">1</span>, n, b, (S[b] == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[rt].v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-3-hdu5634-rikka-with-phi">#Prob. 3 HDU5634 Rikka with Phi</h2>
<blockquote>
<p>Time Limit: 8s | Memory Limit: 128MB</p>
</blockquote>
<div style="width=10px;line_height: 1px;">
<a href=https://dfkuaid.github.io/2021/09/08/HDU5634/ style="text-decoration:none;"> <font face="黑体" size=6> <b>[题解]HDU5634 Rikka with Phi</b> </font> <font face="黑体" size=2> <br>  发表于 2021-09-08 10:32 Dfkuaid<br> </font> <font face="黑体" size=6> </font> <font face="FangSong" size=4> 摘要： HDU5634 Rikka with Phi 题解 <br> </font>
<p align="right">
<font face="黑体" size=4> 阅读全文   <br> <u>   &gt;&gt;   </u>   <br> </font>
</p>
<p></a></p>
</div>
<h2 id="prob.4-hdu6315-naive-operations">#Prob.4 HDU6315 Naive Operations</h2>
<blockquote>
<p>Time Limit: 3s | Memory Limit: 512MB</p>
</blockquote>
<div style="width=10px;line_height: 1px;">
<a href=https://dfkuaid.github.io/2021/09/08/HDU6315/ style="text-decoration:none;"> <font face="黑体" size=6> <b>[题解]HDU6315 Naive Operations</b> </font> <font face="黑体" size=2> <br>  发表于 2021-09-08 10:56 Dfkuaid<br> </font> <font face="黑体" size=6> </font> <font face="FangSong" size=4> 摘要： HDU6315 Naive Operations 题解 <br> </font>
<p align="right">
<font face="黑体" size=4> 阅读全文   <br> <u>   &gt;&gt;   </u>   <br> </font>
</p>
<p></a></p>
</div>
<h2 id="prob.-5-poj2155-matrix">#Prob. 5 POJ2155 Matrix</h2>
<blockquote>
<p>Time Limit: 3s | Memory Limit: 64MB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p>给定一个 <span class="math inline">\(n\cdot n(n\leq1000)\)</span> 的最初全为 <span class="math inline">\(0\)</span> 的矩阵，<span class="math inline">\(q(q\leq50000)\)</span> 次操作，操作分为两种：</p>
<ul>
<li>将左上角为 <span class="math inline">\((x_1,y_1)\)</span>，右下角为 <span class="math inline">\((x_2,y_2)\)</span> 中的所有值取反；</li>
<li>询问 <span class="math inline">\((x,y)\)</span> 位置的值；</li>
</ul>
<h3 id="大体思路-2">#大体思路</h3>
<p>将取反操作看作区间加一，那么就是每次询问一个位置值的奇偶性，于是就变为了二维树状数组的板子题。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, bit[N][N], n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ty = y;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        y = ty;</span><br><span class="line">        <span class="keyword">while</span> (y &lt;= n) bit[x][y] += c, y += y &amp; -y;</span><br><span class="line">        x += x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> xa, <span class="keyword">int</span> ya, <span class="keyword">int</span> xb, <span class="keyword">int</span> yb, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(xa, ya, c); <span class="built_in">add</span>(xb + <span class="number">1</span>, yb + <span class="number">1</span>, c);</span><br><span class="line">    <span class="built_in">add</span>(xa, yb + <span class="number">1</span>, -c); <span class="built_in">add</span>(xb + <span class="number">1</span>, ya, -c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, ty = y;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        y = ty;</span><br><span class="line">        <span class="keyword">while</span> (y) res += bit[x][y], y -= y &amp; -y;</span><br><span class="line">        x -= x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">        <span class="built_in">mset</span>(bit, <span class="number">0</span>); <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">        <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">            <span class="keyword">char</span> op; <span class="keyword">int</span> xa, ya, xb, yb;</span><br><span class="line">            cin &gt;&gt; op;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;xa, &amp;ya, &amp;xb, &amp;yb);</span><br><span class="line">                <span class="built_in">modify</span>(xa, ya, xb, yb, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;xa, &amp;ya);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(xa, ya) &amp; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr />
<blockquote>
<p>其实本来还有一道题的 <a href="http://poj.org/problem?id=3728">POJ3728 The merchant</a>，也是一道树上倍增/树剖水题，但是写本文时突然发现自己当时 WA 了，但是对拍都没拍出错来，而今日身体状况实在不佳，不想 DEBUG 了，那就只能先咕咕咕了[流汗黄豆.jpg]</p>
<p>2021.11.02</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP冲刺-TEST11 总结</title>
    <url>/2021/11/01/ZROI-21-NOIP-SP-TEST11/</url>
    <content><![CDATA[<h2 id="t1-因子差">#T1 因子差</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 512MiB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>认为一个数是有趣的，当且仅当：</p>
<ul>
<li>这个数是一个正整数；</li>
<li>这个数至少有 <span class="math inline">\(4\)</span> 个不同的因子；</li>
<li>这个数的任意两个因子之间的差都不小于 <span class="math inline">\(n(n\leq10^5)\)</span> 。</li>
</ul>
<p>问最小的有趣的数是多少。<strong>多组数据</strong>。</p>
<h3 id="大体思路">#大体思路</h3>
<p>首先一个数 <span class="math inline">\(x\)</span> 必然有两个因子 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(x\)</span>，于是我们只需要让第一个因数 <span class="math inline">\(p_1\)</span> 是大于等于 <span class="math inline">\(n+1\)</span> 的第一个质数，<span class="math inline">\(p_2\)</span> 是大于等于 <span class="math inline">\(p_1+1\)</span> 的第一个质数，不难证明这样必然是最优的（考虑一个非质数的因子），于是我们可以提前预处理出质数，然后 <code>lower_bound</code> 即可。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prm[N], nprm[N], ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nprm[i]) prm[++ ncnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ncnt; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prm[j] * i &gt; x) <span class="keyword">break</span>;</span><br><span class="line">            nprm[i * prm[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i % prm[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(l, len, x) lower_bound(l + 1, l + len + 1, x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">euler</span>(<span class="number">5e5</span>); <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">        <span class="built_in">read</span>(n);</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="built_in">lb</span>(prm, ncnt, n + <span class="number">1</span>) - prm;</span><br><span class="line">        <span class="keyword">int</span> prm1 = prm[pos1];</span><br><span class="line">        <span class="keyword">int</span> pos2 = <span class="built_in">lb</span>(prm, ncnt, prm1 + n) - prm;</span><br><span class="line">        <span class="keyword">int</span> prm2 = prm[pos2];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">1ll</span> * prm1 * prm2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t2-生成树">#T2 生成树</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 512MiB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定一个 <span class="math inline">\(n(n\leq1000)\)</span> 个点的完全图，每次删去一个生成树，问最多能删多少次，并给出方案。</p>
<p><span class="math inline">\(t(t\leq500)\)</span> 组数据，保证满足 <span class="math inline">\(\sum n\leq1000\)</span>.</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>构造题，具体见代码。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">1</span> + n &gt;&gt; <span class="number">1</span>, l = mid, r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a[l], a[r]);</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) -- l; <span class="keyword">else</span> ++ r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &gt; <span class="number">1</span>; -- i) a[i] = a[i - <span class="number">1</span>];</span><br><span class="line">    a[<span class="number">1</span>] = a[n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(n); <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, i, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n / <span class="number">2</span>; ++ k)</span><br><span class="line">          <span class="built_in">solve</span>(), <span class="built_in">change</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t3-划分树">#T3 划分树</h2>
<blockquote>
<p>Time Limit: 3s | Memory Limit: 512MiB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p>给定一棵 <span class="math inline">\(n(n\leq10^5)\)</span> 的树，每个节点有一个权值 <span class="math inline">\(w_i(w_i\leq10^9)\)</span>，给定 <span class="math inline">\(K(K\leq n)\)</span>，要求将整棵树通过断开 <span class="math inline">\(K-1\)</span> 条边划分为 <span class="math inline">\(K\)</span> 部分，使得到的森林的权值最小。</p>
<p>定义一棵树的权值为树上所有的节点的权值的和，一个森林的权值为森林中的所有树的权值中的最大值。</p>
<p><span class="math inline">\(t(t\leq10^5)\)</span> 组数据，保证 <span class="math inline">\(\sum n\leq2\cdot10^5\)</span>.</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>要求最大值最小，直接二分不亏，现在来考虑如何对于 <span class="math inline">\(x\)</span> 进行判定。</p>
<p>设 <span class="math inline">\(f_i\)</span> 表示以 <span class="math inline">\(i\)</span> 为根的子树内满足条件至少需要断开多少条边，<span class="math inline">\(g_i\)</span> 表示以 <span class="math inline">\(i\)</span> 为根的子树与 <span class="math inline">\(i\)</span> 相连的连通快的大小，然后对于每个 <span class="math inline">\(i\)</span>，贪心地选其中 <span class="math inline">\(g\)</span> 小的一定更优。</p>
<p>于是直接 <code>sort()</code> 后 DP 即可，时间复杂度为 <span class="math inline">\(O(n\log^2n)\)</span>.</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, k, n, w[N], head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>), f[N]; ll sum, siz[N];</span><br><span class="line"></span><br><span class="line">vector &lt;ll&gt; all_siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;<span class="built_in">mset</span>(head, <span class="number">0</span>); ecnt = <span class="number">1</span>, sum = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, ll lmt)</span> </span>&#123;</span><br><span class="line">    f[x] = <span class="number">0</span>, siz[x] = <span class="number">0</span>; all_siz[x].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; siz[x] = w[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">solve</span>(e[i].v, x, lmt); ++ cnt;</span><br><span class="line">        all_siz[x].<span class="built_in">push_back</span>(siz[e[i].v]);</span><br><span class="line">        f[x] += f[e[i].v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(all_siz[x].<span class="built_in">begin</span>(), all_siz[x].<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : all_siz[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (siz[x] + k &lt;= lmt) siz[x] += k, -- cnt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x] += cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (x &lt; w[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, <span class="number">0</span>, x); <span class="keyword">return</span> f[<span class="number">1</span>] &lt;= k - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MAIN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(k); <span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v), <span class="built_in">add_edge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(w[i]), sum += w[i];</span><br><span class="line">    ll l = <span class="number">0</span>, r = sum, res = sum;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) res = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="built_in">read</span>(t); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, i); <span class="built_in">MAIN</span>();&#125; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t4">#T4</h2>
<p>巨大恶心的可持久化数组维护分块的字符串题，咕咕咕～</p>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我想了好久才想出这题咋做这档事 - 6</title>
    <url>/2021/11/01/some-solutions-6/</url>
    <content><![CDATA[<h2 id="写在前面">#0.0 写在前面</h2>
<p>自从某天之后，题解都是单篇发了，于是“关于我想了好久才想出这题咋做这档事”这个标题就算是荒废了，正巧最近发现暑假在 ZR 学的东西，回来补的题，由于疏于整理，根本记不住，就想着写博客总结一下，于是就让这个标题<del>借尸还魂</del>重获新生了。</p>
<h2 id="prob.-1-abc070d-transit-tree-path">#Prob. 1 ABC070D Transit Tree Path</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 256MB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>给出一棵有 <span class="math inline">\(n(n\leq10^5)\)</span> 个结点的树和指定节点 <span class="math inline">\(K\)</span>，给出 <span class="math inline">\(q(q\leq10^5)\)</span> 个询问，求结点 <span class="math inline">\(x_i\)</span> 过结点 <span class="math inline">\(K\)</span> 到节点 <span class="math inline">\(y_i\)</span> 的最短距离。</p>
<h3 id="大体思路">#大体思路</h3>
<p>直接以 <span class="math inline">\(K\)</span> 为根，<span class="math inline">\(O(n)\)</span> 处理出 <span class="math inline">\(K\)</span> 到任意一个点的距离，询问时直接回答距离和即可。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt; ll w;&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">ll n, q, k, <span class="built_in">cnt</span>(<span class="number">1</span>), head[N], lg2[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">    e[cnt].u = u, e[cnt].v = v, e[cnt].w = w;</span><br><span class="line">    e[cnt].nxt = head[u], head[u] = cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (e[i].v != fa) &#123;</span><br><span class="line">          d[e[i].v] = d[x] + e[i].w;</span><br><span class="line">          <span class="built_in">dfs</span>(e[i].v, x);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; ll w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w); <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;q, &amp;k); <span class="built_in">dfs</span>(k, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[a] + d[b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-2-cf609e-minimum-spanning-tree-for-each-edge">#Prob. 2 CF609E Minimum spanning tree for each edge</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 256MB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>给你 <span class="math inline">\(n(n\leq2\cdot10^5)\)</span> 个点，<span class="math inline">\(m(m\leq2\cdot10^5)\)</span> 条边，如果对于一个最小生成树中要求必须包括第 <span class="math inline">\(i(1\leq i\leq m)\)</span> 条边，那么最小生成树的权值总和最小是多少。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>直接考虑 Kruscal 生成树的构造方法，每次都是将两个连通块用两者之间边权最小的边相连，那么我们考虑对于第 <span class="math inline">\(i\)</span> 条边 <span class="math inline">\(u\to v\)</span>，如果要把它包含进生成树，那么此时树上一定有且仅有一个包含 <span class="math inline">\(u,v\)</span> 的环，于是一定要删掉最小生成树上 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的路径上的边权最大的边。</p>
<p>我们可以 <span class="math inline">\(O(m\log m)\)</span> 求出最小生成树，然后 <span class="math inline">\(O(n\log n)\)</span> 倍增处理 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(2^k\)</span> 级祖先的路径上的最大值，枚举每条边 <span class="math inline">\(O(\log n)\)</span> 回答即可。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, id, nxt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Edge e[N], ue[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, head[N], cnt = <span class="number">1</span>, fa[N], vis[N], dep[N];</span><br><span class="line"><span class="keyword">int</span> inmst[N], sum, f[N][<span class="number">30</span>], g[N][<span class="number">30</span>], lg2[N], lt, ans[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    e[cnt].u = u, e[cnt].v = v, e[cnt].w = w;</span><br><span class="line">    e[cnt].id = id, e[cnt].nxt = head[u], head[u] = cnt ++;</span><br><span class="line"></span><br><span class="line">    e[cnt].u = v, e[cnt].v = u, e[cnt].w = w;</span><br><span class="line">    e[cnt].id = id, e[cnt].nxt = head[v], head[v] = cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">      x = fa[x] = fa[fa[x]];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fa[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(ue + <span class="number">1</span>, ue + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> af = <span class="built_in">find</span>(ue[i].u);</span><br><span class="line">        <span class="keyword">int</span> bf = <span class="built_in">find</span>(ue[i].v);</span><br><span class="line">        <span class="keyword">if</span> (af != bf) &#123;</span><br><span class="line">            <span class="built_in">add</span>(ue[i].u, ue[i].v, ue[i].w, ue[i].id);</span><br><span class="line">            sum += ue[i].w, fa[af] = bf, inmst[ue[i].id] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">      lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">doubly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue &lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push</span>(<span class="number">1</span>); vis[<span class="number">1</span>] = <span class="number">1</span>, dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[e[i].v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> y = e[i].v; vis[e[i].v] = <span class="number">1</span>;</span><br><span class="line">            f[y][<span class="number">0</span>] = now, g[y][<span class="number">0</span>] = e[i].w, dep[y] = dep[now] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lt; j ++) &#123;</span><br><span class="line">                f[y][j] = f[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">                g[y][j] = <span class="built_in">Max</span>(g[y][j - <span class="number">1</span>], g[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lt; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">      <span class="keyword">if</span> (dep[f[x][i]] &gt;= dep[y])</span><br><span class="line">        res = <span class="built_in">Max</span>(res, g[x][i]), x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lt; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">      <span class="keyword">if</span> (f[x][i] != f[y][i]) &#123;</span><br><span class="line">          res = <span class="built_in">Max</span>(res, <span class="built_in">Max</span>(g[x][i], g[y][i]));</span><br><span class="line">          x = f[x][i], y = f[y][i];</span><br><span class="line">      &#125;</span><br><span class="line">    res = <span class="built_in">Max</span>(res, <span class="built_in">Max</span>(g[x][<span class="number">0</span>], g[y][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;ue[i].u, &amp;ue[i].v, &amp;ue[i].w);</span><br><span class="line">        ue[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">kruskal</span>(); <span class="built_in">get_log</span>(); lt = lg2[n]; <span class="built_in">doubly</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (inmst[ue[i].id]) ans[ue[i].id] = sum;</span><br><span class="line">      <span class="keyword">else</span> ans[ue[i].id] = sum - <span class="built_in">query</span>(ue[i].u, ue[i].v) + ue[i].w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-3-cf1301e-nanosoft">#Prob. 3 CF1301E Nanosoft</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 512MB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p>给你一个 <span class="math inline">\(n\times m(n,m\leq500)\)</span> 的只包含四种颜色的网格。</p>
<p><span class="math inline">\(q(q\leq3\times10^5)\)</span> 次询问，每次问一个矩阵中所包含的形如以下格式的 Logo 的最大面积。</p>
<p><img src="https://pic.imgdb.cn/item/617fb0a52ab3f51d9189b052.jpg" /></p>
<h3 id="大体思路-2">#大体思路</h3>
<p>我们要求一个区间内的最大/最小值，不带修，首先可以考虑用 st 表。</p>
<p>我们先定一个基准点，这里本人选择了红色区域的右下角作为基准点，首先需要处理出以每个基准点为中心的位置最大范围的合法矩形的半径，这个可以通过对四种颜色分别做二维前缀和+二分答案进行预处理。</p>
<p>之后就是令人《神清气爽》的<strong>二维 st 表</strong>，当然本质上与一维并没有太多的区别，我们指定一维的优先级高于另一维，当优先级高的一维大小大于 <span class="math inline">\(1\)</span> 时就二分这一维，否则二分另一维，显然这样是可以得到正确的答案的。</p>
<p>然后我们就可以二分答案最大的半径，然后就可以判定这个区间内的最大半径是不是大于当前的半径，于是就解决了这个问题。</p>
<p>这份代码写于 2021.7.18，当我于 2021.11.1 写本篇博客时，突然意识到我们完全可以直接得到这个区间的最大值，为什么要再二分一次呢？不能理解QnQ</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, mp[N][N], sum[<span class="number">5</span>][N][N], t[N][N];</span><br><span class="line"><span class="keyword">int</span> lg2[N], st[N][N][<span class="number">10</span>][<span class="number">10</span>], ln, lm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">pre_check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    res[<span class="number">1</span>] = sum[<span class="number">1</span>][x][y] - sum[<span class="number">1</span>][x - p][y] - sum[<span class="number">1</span>][x][y - p] + sum[<span class="number">1</span>][x - p][y - p];</span><br><span class="line">    res[<span class="number">2</span>] = sum[<span class="number">2</span>][x][y + p] - sum[<span class="number">2</span>][x][y] - sum[<span class="number">2</span>][x - p][y + p] + sum[<span class="number">2</span>][x - p][y];</span><br><span class="line">    res[<span class="number">3</span>] = sum[<span class="number">3</span>][x + p][y + p] - sum[<span class="number">3</span>][x][y + p] - sum[<span class="number">3</span>][x + p][y] + sum[<span class="number">3</span>][x][y];</span><br><span class="line">    res[<span class="number">4</span>] = sum[<span class="number">4</span>][x + p][y] - sum[<span class="number">4</span>][x][y] - sum[<span class="number">4</span>][x + p][y - p] + sum[<span class="number">4</span>][x][y - p];</span><br><span class="line">    <span class="keyword">if</span> (res[<span class="number">1</span>] == p * p &amp;&amp; res[<span class="number">2</span>] == p * p &amp;&amp; res[<span class="number">3</span>] == p * p &amp;&amp; res[<span class="number">4</span>] == p * p)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_st</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ln = lg2[n], lm = lg2[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        st[i][j][<span class="number">0</span>][<span class="number">0</span>] = t[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ln; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lm; ++ j) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!i &amp;&amp; !j) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; ++ x)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= m; ++ y) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i) &#123;</span><br><span class="line">                    st[x][y][i][j] = <span class="built_in">Max</span>(st[x][y][i - <span class="number">1</span>][j], st[x + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][y][i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    st[x][y][i][j] = <span class="built_in">Max</span>(st[x][y][i][j - <span class="number">1</span>], st[x][y + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> c1, <span class="keyword">int</span> r2, <span class="keyword">int</span> c2, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    r1 += p - <span class="number">1</span>, c1 += p - <span class="number">1</span>, r2 -= p, c2 -= p;</span><br><span class="line">    <span class="keyword">int</span> k1 = lg2[r2 - r1 + <span class="number">1</span>], k2 = lg2[c2 - c1 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res1 = st[r1][c1][k1][k2];</span><br><span class="line">    <span class="keyword">int</span> res2 = st[r1][c2 - (<span class="number">1</span> &lt;&lt; k2) + <span class="number">1</span>][k1][k2];</span><br><span class="line">    <span class="keyword">int</span> res3 = st[r2 - (<span class="number">1</span> &lt;&lt; k1) + <span class="number">1</span>][c1][k1][k2];</span><br><span class="line">    <span class="keyword">int</span> res4 = st[r2 - (<span class="number">1</span> &lt;&lt; k1) + <span class="number">1</span>][c2 - (<span class="number">1</span> &lt;&lt; k2) + <span class="number">1</span>][k1][k2];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">Max</span>(<span class="built_in">Max</span>(res1, res2), <span class="built_in">Max</span>(res3, res4));</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= p) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">Max</span>(n, m); ++ i)</span><br><span class="line">      lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">          <span class="keyword">char</span> c; cin &gt;&gt; c;</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) mp[i][j] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;G&#x27;</span>) mp[i][j] = <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;B&#x27;</span>) mp[i][j] = <span class="number">3</span>;</span><br><span class="line">          <span class="keyword">else</span> mp[i][j] = <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">          sum[<span class="number">1</span>][i][j] = sum[<span class="number">1</span>][i][j - <span class="number">1</span>] + sum[<span class="number">1</span>][i - <span class="number">1</span>][j] - sum[<span class="number">1</span>][i - <span class="number">1</span>][j - <span class="number">1</span>] + (mp[i][j] == <span class="number">1</span>);</span><br><span class="line">          sum[<span class="number">2</span>][i][j] = sum[<span class="number">2</span>][i][j - <span class="number">1</span>] + sum[<span class="number">2</span>][i - <span class="number">1</span>][j] - sum[<span class="number">2</span>][i - <span class="number">1</span>][j - <span class="number">1</span>] + (mp[i][j] == <span class="number">2</span>);</span><br><span class="line">          sum[<span class="number">3</span>][i][j] = sum[<span class="number">3</span>][i][j - <span class="number">1</span>] + sum[<span class="number">3</span>][i - <span class="number">1</span>][j] - sum[<span class="number">3</span>][i - <span class="number">1</span>][j - <span class="number">1</span>] + (mp[i][j] == <span class="number">3</span>);</span><br><span class="line">          sum[<span class="number">4</span>][i][j] = sum[<span class="number">4</span>][i][j - <span class="number">1</span>] + sum[<span class="number">4</span>][i - <span class="number">1</span>][j] - sum[<span class="number">4</span>][i - <span class="number">1</span>][j - <span class="number">1</span>] + (mp[i][j] == <span class="number">4</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">Min</span>(<span class="built_in">Min</span>(i, j), <span class="built_in">Min</span>(n - i, m - j));</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pre_check</span>(i, j, mid))</span><br><span class="line">              res = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t[i][j] = res;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">get_st</span>();</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="keyword">int</span> r1, c1, r2, c2, l = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">Min</span>((r2 - r1 + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, (c2 - c1 + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(r1, c1, r2, c2, mid))</span><br><span class="line">              res = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">4</span> * res * res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-4-cf1527d-mex-tree">#Prob. 4 CF1527D MEX Tree</h2>
<hr />
<div style="width=10px;line_height: 1px;">
<a href=https://www.cnblogs.com/Dfkuaid-210/p/CF1527D.html style="text-decoration:none;"> <font face="黑体" size=6> <b>[题解]CF1527D MEX Tree</b> </font> <font face="黑体" size=2> <br>  发表于 2021-07-26 14:24 Dfkuaid<br> </font> <font face="黑体" size=6> </font> <font face="FangSong" size=4> 摘要： CF1527D MEX Tree 题解 <br> </font>
<p align="right">
<font face="黑体" size=4> 阅读全文   <br> <u>   &gt;&gt;   </u>   <br> </font>
</p>
<p></a></p>
</div>
<hr />
<h2 id="prob.-5-uva1707-surveillance">#Prob. 5 UVA1707 Surveillance</h2>
<h3 id="题意简述-3">#题意简述</h3>
<p>给定一个长度为 <span class="math inline">\(n(n\leq10^6\)</span>) 的环，有 <span class="math inline">\(k(k\leq 10^6)\)</span> 个区域被覆盖，求最小的满足环被完全覆盖的区域数量。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>遇到环上问题，我们先不考虑环，先考虑链。如果是链的话，我们直接预处理出把每个位置覆盖住的线段最右端点是哪个位置，然后贪心就可以了。这个做法 <span class="math inline">\(O(n)\)</span>.</p>
<p>我们考虑断环为链，复制一段接在尾端，如果我们直接枚举左端点暴力做的话是 <span class="math inline">\(O(n^2)\)</span> ，考虑用倍增优化这个过程，预处理出走 <span class="math inline">\(2^i\)</span> 步能走到的位置，就可以做了。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, lg[N], mr[N], nxt[N], xtr[N][<span class="number">30</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans = INF;</span><br><span class="line">    <span class="built_in">mset</span>(mr, <span class="number">0</span>); <span class="built_in">mset</span>(nxt, <span class="number">0</span>); <span class="built_in">mset</span>(xtr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2e6</span>; ++ i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k) != EOF) &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="keyword">if</span> (r &lt; l) &#123;r += n;&#125; mr[l] = <span class="built_in">Max</span>(mr[l], r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mr[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nxt[i - <span class="number">1</span>] != INF)</span><br><span class="line">                  nxt[i] = <span class="built_in">Max</span>(nxt[i - <span class="number">1</span>], mr[i]);</span><br><span class="line">                <span class="keyword">else</span> nxt[i] = mr[i];</span><br><span class="line">                maxr = <span class="built_in">Max</span>(maxr, mr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxr &gt;= i) nxt[i] = nxt[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> nxt[i] = INF;</span><br><span class="line">            xtr[i][<span class="number">0</span>] = nxt[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg[n &lt;&lt; <span class="number">1</span>]; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &lt;&lt; <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xtr[j][i - <span class="number">1</span>] &gt;= INF) xtr[j][i] = INF;</span><br><span class="line">                <span class="keyword">else</span> xtr[j][i] = xtr[xtr[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = i, res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = lg[n &lt;&lt; <span class="number">1</span>]; j &gt;= <span class="number">0</span>; -- j)</span><br><span class="line">              <span class="keyword">if</span> (xtr[now][j] &lt; i + n)</span><br><span class="line">                res += (<span class="number">1</span> &lt;&lt; j), now = xtr[now][j];</span><br><span class="line">            <span class="keyword">if</span> (xtr[now][<span class="number">0</span>] &lt;= INF) ans = <span class="built_in">Min</span>(ans, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans != INF) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prob.-6-poj3419-difference-is-beautiful">#Prob. 6 POJ3419 Difference Is Beautiful</h2>
<hr />
<div style="width=10px;line_height: 1px;">
<a href=https://dfkuaid.github.io/2021/09/04/POJ3419/ style="text-decoration:none;"> <font face="黑体" size=6> <b>[题解]POJ3419 Difference Is Beautiful</b> </font> <font face="黑体" size=2> <br>  发表于 2021-09-04 16:02 Dfkuaid<br> </font> <font face="黑体" size=6> </font> <font face="FangSong" size=4> 摘要： POJ3419 Difference Is Beautiful 题解 <br> </font>
<p align="right">
<font face="黑体" size=4> 阅读全文   <br> <u>   &gt;&gt;   </u>   <br> </font>
</p>
<p></a></p>
</div>
<hr />
<h2 id="prob.-7-hdu3183-a-magic-lamp">#Prob. 7 HDU3183 A Magic Lamp</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 32MB</p>
</blockquote>
<h3 id="题意简述-4">#题意简述</h3>
<p>给定一个有 <span class="math inline">\(n(n\leq1000)\)</span> 位的数，你可以删掉其中的任意 <span class="math inline">\(m(m\leq1000)\)</span> 位，剩余的数位向左合并，要求得到的新数最小。</p>
<h3 id="大体思路-4">#大体思路</h3>
<p>转化一下题意，我们也就是要找到 <span class="math inline">\(n-m\)</span> 位最小的数作为答案，我们从高位到低位进行贪心，显然第一位可以选的区间是 <span class="math inline">\([1,n-(n-m-1)]\)</span>，我们肯定要选这个区间内最小的数位，设这个数位为 <span class="math inline">\(x_1\)</span>，之后每一位依次类推，可选区间应当是 <span class="math inline">\([x_1, n-(n-m-2)],[x_2,n-(n-m-3)]\dots\)</span>，于是我们可以用 st 表提前处理，做到 <span class="math inline">\(O(1)\)</span> 回答，时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="code-4">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mn[<span class="number">10</span>][N], lg[N]; <span class="keyword">char</span> s[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> s[x] &lt;= s[y] ? x : y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MIN</span>(mn[k][l], mn[k][r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1000</span>; ++ i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s + <span class="number">1</span>, &amp;m)) &#123;</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) mn[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg[n]; ++ i)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; ++ j)</span><br><span class="line">            mn[i][j] = <span class="built_in">MIN</span>(mn[i - <span class="number">1</span>][j], mn[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>, apos = <span class="number">1</span>, st = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m - <span class="number">1</span>; ~i; -- i) &#123;</span><br><span class="line">            pos = <span class="built_in">query</span>(pos, n - i);</span><br><span class="line">            ans[apos] = s[pos ++], apos ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (st = <span class="number">1</span>; st &lt; apos &amp;&amp; ans[st] == <span class="string">&#x27;0&#x27;</span>; ++ st) ;</span><br><span class="line">        <span class="keyword">if</span> (st &gt;= apos) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = st; i &lt; apos; ++ i) <span class="built_in">putchar</span>(ans[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」POJ3415 Common Substrings</title>
    <url>/2021/10/31/POJ3415/</url>
    <content><![CDATA[<blockquote>
<p>“我写了这么多 <code>memset</code>，绝不可能还因为多测没清空挂了！来，交一发……”</p>
<p>……</p>
<p>“What's up! 到底为什么 WA 啊！拍不出来……哦拍出来了！让我康康……”</p>
<p>“……不如把这个数据挑出来测吧……嗯？怎么过了？不会又是多测没清空吧？不可能啊！”</p>
<p>……</p>
<p>“Watch out! 我用了两遍 <code>tot</code> 只清空了一遍……我是**！”</p>
</blockquote>
<h2 id="题意简述">#1.0 题意简述</h2>
<blockquote>
<p>Time Limit: 5s | Memory Limit: 64MB</p>
</blockquote>
<p>定义 <span class="math display">\[
T(i,k)=T_iT_{i+1}T_{i+2}\dots T_{i+k-1},\ 1\leq i\leq i+k-1\leq|T|.\\
\]</span> 给定两个字符串 <span class="math inline">\(A,B(|A|,|B|\leq10^5)\)</span> 和 <span class="math inline">\(K\)</span>，求所有满足下列要求的三元组 <span class="math inline">\((i,j,k)\)</span>： <span class="math display">\[
\{(i,j,k)|k\geq K,A(i,k)=B(j,k)\}.
\]</span> <strong>多组数据</strong>，输入 <span class="math inline">\(K=0\)</span> 时停止。</p>
<h2 id="大体思路">#2.0 大体思路</h2>
<h3 id="转化题意">#2.1 转化题意</h3>
<p>首先不难发现，题目实际是要求公共前缀长度不小于 <span class="math inline">\(K\)</span> 的后缀对数，即： <span class="math display">\[
\sum_{i=1}^{|A|}\sum_{j=1}^{|B|}[LCP(i,j)\geq K](LCP(i,j)-K+1)
\]</span> 于是首先想到采用<strong>后缀数组</strong>进行操作，但是由于后缀数组只能（我只会）对于单个字符串进行操作，于是考虑将两个串拼起来。中间用一个未出现过的符号连接（我用的 <code>$</code>），我们默认这个符号的优先级最小，对新串进行后缀排序。</p>
<h3 id="暴力怎么做">#2.2 暴力怎么做</h3>
<p>于是我们可以直接求出 <code>height[]</code> 数组并直接使用 RMQ 做到 <span class="math inline">\(O(n^2)\)</span>.</p>
<h3 id="单调栈优化">#2.3 单调栈优化</h3>
<p>考虑从上面的暴力入手进行优化，假设我们当前对于所有 <span class="math inline">\(B_i\)</span> 求他前面（后缀排序后）所有的 <span class="math inline">\(A_j\)</span> 与它的 LCP 之和，根据我们使用 <code>height[]</code> 求 LCP 的原理，注意到这个 LCP 序列一定是从后向前非严格递减的，于是我们可以考虑通过维护一个单调的数据结构来对这一段一段的相同的 <code>height[]</code> 进行维护。</p>
<p>那具体维护什么信息呢？当我们向后考虑当前这一位时，发现绝大部分都是可以直接继承的，但是显然之前 <code>height[]</code> 比当前后缀的 <code>height[]</code> 大的都需要修改，于是我们考虑维护一个 <code>height[]</code> 单调递增的单调栈，同时维护栈内所有对应 <code>height[]</code> 的贡献（所有 <code>height[]-k+1</code> 乘上以该 <code>height[]</code> 为 LCP 的 <span class="math inline">\(A_j\)</span> 的数量的和），当我们把所有不合法的都弹出之后，再将当前的加入栈中，由于 <code>height[]</code> 是当前与上一个的 LCP 长度，于是我们需要判断上一个是否有贡献，经过上面的过程，当前维护的栈内的和就是对于当前后缀的答案，累加即可。</p>
<p>同样的，对于 <span class="math inline">\(A_i\)</span> 考虑前面的每一个 <span class="math inline">\(B_j\)</span> 时是完全一致的过程。</p>
<h3 id="时间复杂度分析">#时间复杂度分析</h3>
<ul>
<li>求解 SA 是 <span class="math inline">\(O(n\log n)\)</span>；</li>
<li>求解 <code>height[]</code> 是 <span class="math inline">\(O(n)\)</span>；</li>
<li>单调栈每个元素最多进栈、出栈各 <span class="math inline">\(O(1)\)</span> 级别次，于是均摊复杂度为 <span class="math inline">\(O(n)\)</span>；</li>
</ul>
<p>综上，时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>，瓶颈在于求解 SA.</p>
<h2 id="code">#3.0 Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k; <span class="keyword">char</span> a[N], b[N], s[N]; ll ans;</span><br><span class="line"><span class="keyword">int</span> sa[N], rk[N], oldrk[N], px[N], id[N], cnt[N], n, ht[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mset</span>(sa, <span class="number">0</span>), <span class="built_in">mset</span>(rk, <span class="number">0</span>), <span class="built_in">mset</span>(oldrk, <span class="number">0</span>), <span class="built_in">mset</span>(ht, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mset</span>(px, <span class="number">0</span>), <span class="built_in">mset</span>(id, <span class="number">0</span>), <span class="built_in">mset</span>(cnt, <span class="number">0</span>); ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_sa</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, p, w;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ++ cnt[rk[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i) sa[cnt[rk[i]] --] = i;</span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">1</span>;; w &lt;&lt;= <span class="number">1</span>, m = p) &#123;</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>, i = n; i &gt; n - w; --i) id[++ p] = i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (sa[i] &gt; w) id[++ p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ++ cnt[px[i] = rk[id[i]]];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i) sa[cnt[px[i]] --] = id[i];</span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk, rk, <span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          rk[sa[i]] = <span class="built_in">comp</span>(sa[i], sa[i - <span class="number">1</span>], w) ? p : ++ p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sa[rk[i]] = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k) -- k;</span><br><span class="line">        <span class="keyword">while</span> (s[i + k] == s[sa[rk[i] - <span class="number">1</span>] + k]) ++ k;</span><br><span class="line">        ht[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], stp, lena, lenb; ll sum, tot[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mset</span>(tot, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; k) &#123;stp = <span class="number">0</span>, sum = <span class="number">0</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">while</span> (stp &amp;&amp; ht[stk[stp]] &gt;= ht[i]) &#123;</span><br><span class="line">            sum -= <span class="number">1ll</span> * tot[stk[stp]] * (ht[stk[stp]] - k + <span class="number">1</span>);</span><br><span class="line">            sum += <span class="number">1ll</span> * tot[stk[stp]] * (ht[i] - k + <span class="number">1</span>);</span><br><span class="line">            tot[i] += tot[stk[stp]]; -- stp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sa[i - <span class="number">1</span>] &lt;= lena) sum += <span class="number">1ll</span> * (ht[i] - k + <span class="number">1</span>), ++ tot[i];</span><br><span class="line">        stk[++ stp] = i; <span class="keyword">if</span> (sa[i] &gt; lena + <span class="number">1</span>) ans += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mset</span>(tot, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; k) &#123;stp = <span class="number">0</span>, sum = <span class="number">0</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">while</span> (stp &amp;&amp; ht[stk[stp]] &gt;= ht[i]) &#123;</span><br><span class="line">            sum -= <span class="number">1ll</span> * tot[stk[stp]] * (ht[stk[stp]] - k + <span class="number">1</span>);</span><br><span class="line">            sum += <span class="number">1ll</span> * tot[stk[stp]] * (ht[i] - k + <span class="number">1</span>);</span><br><span class="line">            tot[i] += tot[stk[stp]]; -- stp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sa[i - <span class="number">1</span>] &gt; lena + <span class="number">1</span>) sum += <span class="number">1ll</span> * (ht[i] - k + <span class="number">1</span>), ++ tot[i];</span><br><span class="line">        stk[++ stp] = i; <span class="keyword">if</span> (sa[i] &lt;= lena) ans += sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MAIN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>); <span class="built_in">reset</span>();</span><br><span class="line">    lena = <span class="built_in">strlen</span>(a + <span class="number">1</span>), lenb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lena; ++ i) s[i] = a[i];</span><br><span class="line">    n = lena + <span class="number">1</span> + lenb; s[lena + <span class="number">1</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenb; ++ i) s[lena + <span class="number">1</span> + i] = b[i];</span><br><span class="line">    <span class="built_in">get_sa</span>(<span class="number">256</span>); <span class="built_in">get_height</span>(); <span class="built_in">solve</span>(); <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="built_in">read</span>(k); <span class="keyword">while</span> (k) &#123;<span class="built_in">MAIN</span>(); <span class="built_in">read</span>(k);&#125; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
        <tag>后缀数组</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」CF1073G Yet Another LCP Problem</title>
    <url>/2021/10/30/CF1073G/</url>
    <content><![CDATA[<blockquote>
<p>这题从早上调到下午，伴随着 <span class="math inline">\(3\)</span> 杯茶的离去，SA、线段树、st 表各挂了 <span class="math inline">\(2\)</span> 次/kk</p>
</blockquote>
<h2 id="题意简述">#1.0 题意简述</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 256MB</p>
</blockquote>
<p>记 <span class="math inline">\(lcp(i,j)\)</span> 表示 <span class="math inline">\(i\)</span> 这个后缀和 <span class="math inline">\(j\)</span> 这个后缀的最长公共前缀长度，</p>
<p>给定一个字符串 <span class="math inline">\(S(|S|\leq2\cdot10^5)\)</span> ，<span class="math inline">\(q(q\leq2\cdot10^5)\)</span> 次询问，每次询问的时候给出两个正整数集合 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，求 <span class="math inline">\(\sum_{i \in A,j \in B}lcp(i,j)\)</span> 的值</p>
<p>保证数据满足 <span class="math inline">\(\sum|A|,\sum|B|\leq2\cdot 10^5\)</span>.</p>
<h2 id="大体思路">#2.0 大体思路</h2>
<p>求后缀之间的 LCP 的和，很容易（<del>并不</del>）想到使用<strong>后缀数组</strong>来解决问题，于是我们先求出后缀数组及对应的 <span class="math inline">\(height\)</span> 数组。</p>
<p>这里需要提前说明一个将要使用的定理： <span class="math display">\[
LCP(i,j)=\min_{i+1\leq k\leq j}\{height_k\}
\]</span> 于是可以用 st 表 <span class="math inline">\(O(n\log n)\)</span> 预处理，<span class="math inline">\(O(1)\)</span> 查询。</p>
<h3 id="分块">#2.1 分块</h3>
<p>考虑对于集合 <span class="math inline">\(B\)</span> 中的每一个元素向集合 <span class="math inline">\(A\)</span> 统计答案，于是我们把 <span class="math inline">\(A\)</span> 按 <span class="math inline">\(rank\)</span> 排序后，分成 <span class="math inline">\(\sqrt n\)</span> 大小的块，然后再考虑如何对于 <span class="math inline">\(b_i\)</span> 计算对于 <span class="math inline">\(A\)</span> 的所有答案。</p>
<p>于是我们对于 <span class="math inline">\(b_i\)</span> 将所有情况分为三种，分别讨论：</p>
<ol type="1">
<li><p>当前块左端点的 <span class="math inline">\(rank\leq rank_{b_i}\leq\)</span> 当前块的右端点的 <span class="math inline">\(rank\)</span>，如下图</p>
<p><img src="https://pic.imgdb.cn/item/617cfd412ab3f51d9147bfbc.jpg" /></p>
<p>这种情况暴力扫一遍统计答案即可。</p></li>
<li><p><span class="math inline">\(rand_{b_i}&lt;\)</span> 当前块左端点，如下图</p>
<p><img src="https://pic.imgdb.cn/item/617cfdab2ab3f51d914827c6.jpg" /></p>
<p>根据上面给出的定理，我们可以很容易得到 <span class="math inline">\(b_i\)</span> 与这一段的 LCP 一定是（非严格）递减的， 于是当我们求出 <span class="math inline">\(b_i\)</span> 与左端点的 LCP 为 <span class="math inline">\(x\)</span>，然后鹅分最后一个 LCP<span class="math inline">\(\geq x\)</span> 的位置，然后显然这个位置及之前的所有的贡献都是 <span class="math inline">\(x\)</span>，剩下的部分可以提前维护出来做后缀和得到。</p></li>
<li><p>当前块右端点 <span class="math inline">\(&lt;rand_{b_i}\)</span>，与上种情况基本一致。</p></li>
</ol>
<p>于是时间复杂度为 <span class="math inline">\(O(n\sqrt n\log\sqrt n)\)</span>，很遗憾<strong>不能通过本题</strong>。</p>
<h3 id="线段树">#2.2 线段树</h3>
<p>我们尝试对以上分块的做法进行一些优化。上面的方法之所以要分块，是因为要统计 LCP 的前缀和。那么我们尝试动态维护这个东西。</p>
<p>不妨把 <span class="math inline">\(B\)</span> 中的元素也<strong>按 <span class="math inline">\(rank\)</span> 排序</strong>。对于 <span class="math inline">\(B\)</span> 排序后的第 <span class="math inline">\(i\)</span> 个元素，设它与 <span class="math inline">\(A\)</span> 中 <span class="math inline">\(rank\)</span> 小于等于它的元素 <span class="math inline">\(a_j\)</span> 的 LCP 为 <span class="math inline">\(d_{i,j}\)</span> ，那么，根据上文提到的定理，从 <span class="math inline">\(d_i\)</span> 转移到 <span class="math inline">\(d_{i+1}\)</span> 时，只需要把 <span class="math inline">\(d_i\)</span> 中所有大于 <span class="math inline">\(LCP(b_i,b_{i+1})\)</span> 的都改成 <span class="math inline">\(LCP(b_i,b_{i+1})\)</span>，再将 <span class="math inline">\(A\)</span> 中所有满足 <span class="math inline">\(rank_{b_i}&lt;rank_{a_j}\leq rank_{b_{i+1}}\)</span> 的元素加入 <span class="math inline">\(d_{i+1}\)</span> 即可；</p>
<p>我们发现以上维护 <span class="math inline">\(d_i\)</span> 的过程，需要支持两个操作：</p>
<ol type="1">
<li>把所有大于 <span class="math inline">\(k\)</span> 的数改为 <span class="math inline">\(k\)</span> ；</li>
<li>单点修改一个元素。</li>
</ol>
<p>容易发现，<span class="math inline">\(d_i\)</span> 其实是一个非严格递增的数组（直接考虑 SA 的定义不难证明），于是所有大于 <span class="math inline">\(k\)</span> 的数都会连在一起，可以将其转化为区间覆盖操作；</p>
<p><span class="math inline">\(b_i\)</span> 的答案就是 <span class="math inline">\(d_i\)</span> 的和，因此还需要支持一个区间求和的操作；</p>
<p>综上，我们发现可以用线段树维护整个 <span class="math inline">\(d_i\)</span> 转移的操作即可。</p>
<p>以上过程统计了 <span class="math inline">\(b_i\)</span> 与 <span class="math inline">\(a_j(rank_{a_j}\leq rank_{b_i})\)</span> 的答案，再反向做一遍，即可类似地统计 <span class="math inline">\(b_i\)</span> 与 <span class="math inline">\(a_j(rank_{a_j}&gt;rank_{b_i})\)</span> 的答案。这两部分的答案相加，就是最终的答案。</p>
<p>时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h2 id="code">#3.0 Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs; ll sum; <span class="keyword">int</span> mn, mx, cov;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;ls = rs = sum = mn = mx = <span class="number">0</span>, cov = <span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;ls = rs = sum = mn = mx = <span class="number">0</span>, cov = <span class="number">-1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    Node p[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> rt, cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">SegmentTree</span><span class="params">()</span> </span>&#123;rt = cnt = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;<span class="keyword">while</span> (cnt) p[cnt].<span class="built_in">reset</span>(), -- cnt; rt = <span class="number">0</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        p[k].cov = x; p[k].mn = p[k].mx = x;</span><br><span class="line">        p[k].sum = <span class="number">1ll</span> * (r - l + <span class="number">1</span>) * x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = p[k].ls, rs = p[k].rs;</span><br><span class="line">        p[k].sum = p[ls].sum + p[rs].sum;</span><br><span class="line">        p[k].mn = <span class="built_in">Min</span>(p[ls].mn, p[rs].mn);</span><br><span class="line">        p[k].mx = <span class="built_in">Max</span>(p[ls].mx, p[rs].mx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = p[k].ls, rs = p[k].rs;</span><br><span class="line">        <span class="keyword">if</span> (~p[k].cov) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ls) <span class="built_in">cover</span>(ls, l, mid, p[k].cov);</span><br><span class="line">            <span class="keyword">if</span> (rs) <span class="built_in">cover</span>(rs, mid + <span class="number">1</span>, r, p[k].cov);</span><br><span class="line">            p[k].cov = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) k = ++ cnt; <span class="keyword">if</span> (l == r) <span class="keyword">return</span>; <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(p[k].ls, l, mid); <span class="built_in">build</span>(p[k].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;<span class="built_in">cover</span>(k, l, r, c); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(p[k].ls, l, mid, x, c);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(p[k].rs, mid + <span class="number">1</span>, r, x, c);</span><br><span class="line">        <span class="built_in">pushup</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[k].mx &lt; x) <span class="keyword">return</span>; <span class="keyword">if</span> (p[k].mn &gt;= x) &#123;<span class="built_in">cover</span>(k, l, r, x); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">        <span class="built_in">recover</span>(p[k].ls, l, mid, x); <span class="built_in">recover</span>(p[k].rs, mid + <span class="number">1</span>, r, x); <span class="built_in">pushup</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> sa[N], rk[N], oldrk[N], px[N], id[N], cnt[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_sa</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, p, w;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ++ cnt[rk[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i) sa[cnt[rk[i]] --] = i;</span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">1</span>;; w &lt;&lt;= <span class="number">1</span>, m = p) &#123;</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>, i = n; i &gt; n - w; --i) id[++ p] = i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (sa[i] &gt; w) id[++ p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ++ cnt[px[i] = rk[id[i]]];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i) sa[cnt[px[i]] --] = id[i];</span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk, rk, <span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          rk[sa[i]] = <span class="built_in">comp</span>(sa[i], sa[i - <span class="number">1</span>], w) ? p : ++ p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sa[rk[i]] = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ht[N], h[<span class="number">30</span>][N], lg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rk_height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) &#123;ht[rk[i]] = k = <span class="number">0</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (k) k --; <span class="built_in">assert</span>(rk[i]);</span><br><span class="line">        <span class="keyword">while</span> (s[i + k] == s[sa[rk[i] - <span class="number">1</span>] + k]) ++ k;</span><br><span class="line">        ht[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[<span class="number">0</span>][i] = ht[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg[n]; ++ i) </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; ++ j)</span><br><span class="line">        h[i][j] = <span class="built_in">Min</span>(h[i - <span class="number">1</span>][j], h[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q, a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> rk[x] &lt; rk[y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Min</span>(h[k][l], h[k][r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> n - x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rk[x] &gt; rk[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(rk[x] + <span class="number">1</span>, rk[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(q); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); lg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">build_sa</span>(<span class="number">256</span>); <span class="built_in">get_rk_height</span>();</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="keyword">int</span> k, l; ll ans  = <span class="number">0</span>; <span class="built_in">read</span>(k), <span class="built_in">read</span>(l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++ i) <span class="built_in">read</span>(b[i]);</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, cmp);</span><br><span class="line">        <span class="built_in">sort</span>(b + <span class="number">1</span>, b + l + <span class="number">1</span>, cmp);</span><br><span class="line">        seg.<span class="built_in">reset</span>(); seg.<span class="built_in">build</span>(seg.rt, <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= l; ++ i) &#123;</span><br><span class="line">            seg.<span class="built_in">recover</span>(seg.rt, <span class="number">1</span>, k, <span class="built_in">lcp</span>(b[i], b[i - <span class="number">1</span>])); </span><br><span class="line">            <span class="keyword">while</span> (j &lt;= k &amp;&amp; rk[a[j]] &lt;= rk[b[i]])</span><br><span class="line">              seg.<span class="built_in">modify</span>(seg.rt, <span class="number">1</span>, k, j, <span class="built_in">lcp</span>(b[i], a[j])), ++ j;</span><br><span class="line">            ans += seg.p[seg.rt].sum;</span><br><span class="line">        &#125;</span><br><span class="line">        seg.<span class="built_in">reset</span>(); seg.<span class="built_in">build</span>(seg.rt, <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = k; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">            seg.<span class="built_in">recover</span>(seg.rt, <span class="number">1</span>, k, <span class="built_in">lcp</span>(b[i], b[i + <span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; rk[a[j]] &gt; rk[b[i]])</span><br><span class="line">              seg.<span class="built_in">modify</span>(seg.rt, <span class="number">1</span>, k, j, <span class="built_in">lcp</span>(b[i], a[j])), j --;</span><br><span class="line">            ans += seg.p[seg.rt].sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」Codeforces Round #751 (Div. 2) 题解</title>
    <url>/2021/10/29/CF-751-Div2/</url>
    <content><![CDATA[<h2 id="a.-two-subsequences">A. Two Subsequences</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 256MB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>给定一个字符串 <span class="math inline">\(S(|S|\leq100)\)</span>，从中取出一个子序列 <span class="math inline">\(a\)</span>，剩下的部分合为 <span class="math inline">\(b\)</span>，要求 <span class="math inline">\(a\)</span> 的字典序最小，输出 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>。</p>
<p>有 <span class="math inline">\(t(t\leq1000)\)</span> 次询问。</p>
<h3 id="大体思路">#大体思路</h3>
<p>直接找字典序最小的单个字符作为 <span class="math inline">\(a\)</span> 即可。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> t, pos, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); pos = <span class="number">1</span>; n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="keyword">if</span> (s[pos] &gt; s[i]) pos = i;</span><br><span class="line">        <span class="built_in">putchar</span>(s[pos]); <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="keyword">if</span> (i != pos) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="b.-divine-array">B. Divine Array</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 256MB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定 <span class="math inline">\(n(n\leq2000)\)</span> 个正整数的序列，每次该序列按照如下规则变化：<span class="math inline">\(a_i\)</span> 变为 <span class="math inline">\(cnt_{a_i}\)</span>；现有 <span class="math inline">\(q(q\leq10^5)\)</span> 个询问，每次询问位置 <span class="math inline">\(i\)</span> 在第 <span class="math inline">\(t(t\leq10^9)\)</span> 次变换后的值是多少。</p>
<p>有 <span class="math inline">\(t(t\leq 1000)\)</span>，保证数据满足 <span class="math inline">\(\sum n\leq2000,\sum q\leq10^5\)</span>.</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>显然一个数列的变化次数不可能超过 <span class="math inline">\(n\)</span> 次，于是直接预处理即可，赛时为了保证正确，直接预处理了 <span class="math inline">\(2000\)</span> 次变化/qd</p>
<p>时间复杂度 <span class="math inline">\(O(n^2+q)\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> t, n, a[N], q, b[N][N], tot[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">        <span class="built_in">read</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(b[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) tot[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) ++ tot[b[i][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2000</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) b[j][i] = tot[b[j][i - <span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) tot[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) ++ tot[b[j][i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">read</span>(q);</span><br><span class="line">        <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, k; <span class="built_in">read</span>(x), <span class="built_in">read</span>(k);</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= <span class="number">2000</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[x][<span class="number">2000</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[x][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="c.-array-elimination">C. Array Elimination</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 512MB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p>给定一个有 <span class="math inline">\(n(n\leq2\times10^5)\)</span> 个非负整数的序列 <span class="math inline">\(a_i(a_i\leq2^{30})\)</span>，我们可以选定一个 <span class="math inline">\(k(1\leq k\leq n)\)</span> 进行如下操作：</p>
<ul>
<li>在 <span class="math inline">\(a_i\)</span> 中选出 <span class="math inline">\(k\)</span> 个数；</li>
<li>令 <span class="math inline">\(x=a_{i_1}\&amp;a_{i_2}\&amp;\cdots\&amp;a_{i_k}\)</span>；</li>
<li>将 <span class="math inline">\(a_{i_1},a_{i_2},\dots,a_{i_k}\)</span> 减去 <span class="math inline">\(x\)</span>；</li>
</ul>
<p>最终将所有 <span class="math inline">\(a_i\)</span> 变为 <span class="math inline">\(0\)</span>.</p>
<p>问可以选出多少个 <span class="math inline">\(k\)</span>，并给出所有可能的 <span class="math inline">\(k\)</span>.</p>
<p>最多 <span class="math inline">\(t(t\leq10^4)\)</span> 组数据，满足 <span class="math inline">\(\sum n\leq2\times10^5\)</span>.</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>注意到对于二进制下第 <span class="math inline">\(j\)</span> 位，显然当我们选出的 <span class="math inline">\(k\)</span> 个数的第 <span class="math inline">\(j\)</span> 位都是 <span class="math inline">\(1\)</span>，<span class="math inline">\(x\)</span> 的第 <span class="math inline">\(j\)</span> 位才能是 <span class="math inline">\(1\)</span>，于是显然如果要将第 <span class="math inline">\(j\)</span> 位的 <span class="math inline">\(1\)</span> 全部消除，选定的 <span class="math inline">\(k\)</span> 必须是第 <span class="math inline">\(j\)</span> 位 <span class="math inline">\(1\)</span> 的出现次数的因数，所以如果我们要将所有位上的 <span class="math inline">\(1\)</span> 都消除，那么我们选定的 <span class="math inline">\(k\)</span> 显然必须是所有位上的 <span class="math inline">\(1\)</span> 的出现次数的公因数。</p>
<p>于是我们求出最大公因数后 <span class="math inline">\(O(\sqrt n)\)</span> 枚举因数即可。时间复杂度 <span class="math inline">\(O(n\log^2 n+n\sqrt n)\)</span>.</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, tot[N], a[N], ans[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">        <span class="built_in">read</span>(n); <span class="built_in">memset</span>(tot, <span class="number">0</span>, <span class="keyword">sizeof</span> tot); cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; ++ j)</span><br><span class="line">            tot[j] += (a[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> g = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++ i)</span><br><span class="line">          g = <span class="built_in">gcd</span>(g, tot[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= g; ++ i) <span class="keyword">if</span> (!(g % i)) &#123;</span><br><span class="line">            ans[++ cnt] = i;</span><br><span class="line">            <span class="keyword">if</span> (i * i != g) ans[++ cnt] = g / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans + <span class="number">1</span>, ans + cnt + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!g) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="d.-frog-traveler">D. Frog Traveler</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 512MB</p>
</blockquote>
<h3 id="题意简述-3">#题意简述</h3>
<p>有一只青蛙在一个高为 <span class="math inline">\(n(1\leq n\leq10^5)\)</span> 的井的井底，当青蛙处于 <span class="math inline">\(i\)</span> 高度时，可以向上跳 <span class="math inline">\([0,a_i]\)</span> 高度，当它跳到 <span class="math inline">\(i\)</span> 高度时，会下滑 <span class="math inline">\(b_i\)</span>，问最小跳跃次数，并输出路径。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>显然 DP 是不行的，于是考虑建图最短路，即将每个高度拆为两个点：入点和出点，入点到出点的距离为 <span class="math inline">\(0\)</span>，其余边的距离为 <span class="math inline">\(1\)</span>，然后跑 01 最短路。</p>
<p>发现这样建图边数过多，无法接受，考虑优化建图。发现每次都是单个点向一个区间连边，考虑用线段树优化建图，这样边数可以优化到 <span class="math inline">\(O(n\log n)\)</span> 级别，再进行 01 最短路即可。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ls, rs;&#125; p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, w, nxt;&#125; e[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], b[N], head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>), cnt;</span><br><span class="line"><span class="keyword">int</span> npos[N], id[N], rk[N], endpos, rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v, e[ecnt].w = w;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) k = ++ cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        id[l] = cnt; rk[cnt] = l;</span><br><span class="line">        <span class="keyword">if</span> (!l) endpos = cnt; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p[k].ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p[k].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">add_edge</span>(k, p[k].ls, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">add_edge</span>(k, p[k].rs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;<span class="built_in">add_edge</span>(c, k, <span class="number">1</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">connect</span>(p[k].ls, l, mid, x, y, c);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) <span class="built_in">connect</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) npos[i] = ++ cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">add_edge</span>(id[i], npos[i + b[i]], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">connect</span>(rt, <span class="number">0</span>, n, i - a[i], i, npos[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deque &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">int</span> d[N], vis[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">shortest_path</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mset</span>(d, <span class="number">0x3f</span>); <span class="built_in">mset</span>(vis, <span class="number">0</span>);</span><br><span class="line">    d[u] = <span class="number">0</span>; q.<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>; vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">          <span class="keyword">if</span> (d[e[i].v] &gt; d[x] + e[i].w) &#123;</span><br><span class="line">              d[e[i].v] = d[x] + e[i].w;</span><br><span class="line">              pre[e[i].v] = i;</span><br><span class="line">              <span class="keyword">if</span> (e[i].w) q.<span class="built_in">push_back</span>(e[i].v);</span><br><span class="line">              <span class="keyword">else</span> q.<span class="built_in">push_front</span>(e[i].v);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N], acnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[id[<span class="number">0</span>]] &gt;= INF) &#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[id[<span class="number">0</span>]]); <span class="keyword">int</span> now = id[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (now) &#123;</span><br><span class="line">        ans[++ acnt] = pre[now];</span><br><span class="line">        now = e[pre[now]].u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans + <span class="number">1</span>, ans + acnt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= acnt; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (rk[e[ans[i]].v] || e[ans[i]].v == endpos)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, rk[e[ans[i]].v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">build</span>(rt, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(b[i]);</span><br><span class="line">    <span class="built_in">mapping</span>(); <span class="built_in">shortest_path</span>(id[n]); <span class="built_in">print</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="e.-optimal-insertion">E. Optimal Insertion</h2>
<blockquote>
<p>Time Limit: 3s | Memory Limit: 512MB</p>
</blockquote>
<h3 id="题意简述-4">#题意简述</h3>
<p>给定一个长度为 <span class="math inline">\(n(n\leq10^6)\)</span> 的序列 <span class="math inline">\(a_i\)</span> 和长度为 <span class="math inline">\(m(m\leq10^6)\)</span> 的序列 <span class="math inline">\(b_i\)</span>，现在要将 <span class="math inline">\(b_i\)</span> 中的元素全部插入 <span class="math inline">\(a_i\)</span> 中，要求 <span class="math inline">\(a_i\)</span> 的顺序不变，<span class="math inline">\(b_i\)</span> 顺序不限，问得到序列的最小逆序对数。</p>
<p>共有 <span class="math inline">\(t(t\leq10^4)\)</span> 组询问，满足 <span class="math inline">\(\sum n\leq10^6,\sum m\leq10^6\)</span>.</p>
<h3 id="大体思路-4">#大体思路</h3>
<p>注意到最终答案序列中的逆序对数一共有两种来源：<span class="math inline">\(a_i\)</span> 自有的和插入 <span class="math inline">\(b_i\)</span> 得到的。</p>
<p>显然 <span class="math inline">\(b_i\)</span> 的考虑顺序不会影响答案，不妨将 <span class="math inline">\(b_i\)</span> 自小到大排序，设 <span class="math inline">\(p_i\)</span> 为 <span class="math inline">\(b_i\)</span> 在 <span class="math inline">\(a_i\)</span> 的插入位置，如 <span class="math inline">\(p_1=1\)</span> 则表示 <span class="math inline">\(b_1\)</span> 插在 <span class="math inline">\(a_1\)</span> 前面，于是 <span class="math inline">\(p_i=n+1\)</span> 表示插在 <span class="math inline">\(a_i\)</span> 尾部。</p>
<p>对于排序后的 <span class="math inline">\(b_i\)</span>，显然有 <span class="math inline">\(p_1\leq p_2\leq p_3\leq\cdots\leq p_m\)</span>，可以用交换法证明这个贪心。</p>
<p>然后考虑分治，每次考虑位于中间的 <span class="math inline">\(b_{mid}\)</span>，找到目标区间中贡献最小的位置作为 <span class="math inline">\(p_{mid}\)</span>，然后将区间分为两部分继续分治即可。这个分治的正确性同样可以采用交换法并结合上面的贪心进行证明。</p>
<p>显然这样的分治不会超过 <span class="math inline">\(O(\log(n+m))\)</span> 层，每层将 <span class="math inline">\(n\)</span> 个位置遍历一次，于是时间复杂度为 <span class="math inline">\(O(n\log(n+m))\)</span>.</p>
<p>经过上述操作后我们得到了答案序列，然后用树状数组维护求得逆序对即可。</p>
<p>（当然用线段树应当也可以，不过笔者用线段树被卡常了 QnQ）</p>
<blockquote>
<p>有意思的是卡常的点的输出全是 <span class="math inline">\(0\)</span>，当时测试不是分治挂了的时候，<del>人工智能</del>让他在 test 5 不对答案序列计算答案，然后突然就 Accepted 了/cy</p>
<p>当然还是老老实实换了树状数组/kk</p>
</blockquote>
<h3 id="code-4">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIMIT = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[N], len;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">BIT</span><span class="params">()</span> </span>&#123;len = <span class="number">0</span>;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;len = x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;<span class="keyword">while</span> (len) val[len --] = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;<span class="keyword">while</span> (x &lt;= len) val[x] += c, x += (x &amp; -x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll res = <span class="number">0</span>; <span class="keyword">while</span> (x) res += val[x], x -= (x &amp; -x); <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(l, len, x) lower_bound(l + 1, l + len + 1, x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ub(l, len, x) upper_bound(l + 1, l + len + 1, x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, m, a[N], b[N], c[N], p[N], upper[N], lower[N], dct[N]; ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;bit.<span class="built_in">reset</span>(); ans = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">discretize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) dct[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) dct[n + i] = b[i];</span><br><span class="line">    <span class="built_in">sort</span>(dct + <span class="number">1</span>, dct + n + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">unique</span>(dct + <span class="number">1</span>, dct + n + m + <span class="number">1</span>) - dct - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">lb</span>(dct, len, a[i]) - dct;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) b[i] = <span class="built_in">lb</span>(dct, len, b[i]) - dct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>; <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, res = INF;</span><br><span class="line">    upper[pl - <span class="number">1</span>] = <span class="number">0</span>, upper[pl] = (a[pl] &gt; b[mid]);</span><br><span class="line">    lower[pr + <span class="number">1</span>] = <span class="number">0</span>, lower[pr] = (a[pr] &lt; b[mid]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pl; i &lt; pr; ++ i) upper[i + <span class="number">1</span>] = upper[i] + (a[i + <span class="number">1</span>] &gt; b[mid]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pr; i &gt; pl; -- i) lower[i - <span class="number">1</span>] = lower[i] + (a[i - <span class="number">1</span>] &lt; b[mid]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pl; i &lt;= pr; ++ i) <span class="keyword">if</span> (upper[i - <span class="number">1</span>] + lower[i] &lt; res)</span><br><span class="line">      res = upper[i - <span class="number">1</span>] + lower[i], p[mid] = i;</span><br><span class="line">    <span class="keyword">if</span> (pl == pr) p[mid] = pl;</span><br><span class="line">    <span class="built_in">solve</span>(l, mid - <span class="number">1</span>, pl, p[mid]); <span class="built_in">solve</span>(mid + <span class="number">1</span>, r, p[mid], pr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ap = <span class="number">1</span>, lp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ap &lt;= n &amp;&amp; ap &lt; p[i]) c[lp ++] = a[ap], ++ ap;</span><br><span class="line">        c[lp ++] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ap &lt;= n) c[lp ++] = a[ap], ++ ap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + m; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">        ans += bit.<span class="built_in">query</span>(c[i] - <span class="number">1</span>);</span><br><span class="line">        bit.<span class="built_in">add</span>(c[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MAIN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m); <span class="built_in">reset</span>(); bit.<span class="built_in">init</span>(n + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">read</span>(b[i]);</span><br><span class="line">    <span class="built_in">discretize</span>(); <span class="built_in">sort</span>(b + <span class="number">1</span>, b + m + <span class="number">1</span>); a[n + <span class="number">1</span>] = INF;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, m, <span class="number">1</span>, n + <span class="number">1</span>); <span class="built_in">get_list</span>();</span><br><span class="line">    <span class="built_in">calculate</span>(); <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t); <span class="keyword">while</span> (t --) <span class="built_in">MAIN</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="f.-difficult-mountain">F. Difficult Mountain</h2>
<blockquote>
<p>Time Limit: 2s | Memory Limit: 512MB</p>
</blockquote>
<h3 id="题意简述-5">#题意简述</h3>
<p><span class="math inline">\(n(n\leq5\times10^5)\)</span> 个人依次爬一座难度为 <span class="math inline">\(d(d\leq10^9)\)</span> 的山，每个人有两个参数：<span class="math inline">\(s_i\)</span> 和 <span class="math inline">\(a_i\)</span>，当且仅当当前山的难度不大于 <span class="math inline">\(s_i\)</span> 这个人才可以爬上去，同时会将山的难度变为 <span class="math inline">\(\max(d,a_i)\)</span>，你可以安排他们爬山的顺序，问最多能有多少个人登顶。</p>
<h3 id="大体思路-5">#大体思路</h3>
<p>一个很是巧妙的贪心：按照 <span class="math inline">\(\max(s,a)\)</span> 排序，从小到大；然后再按照 <span class="math inline">\(s\)</span> 从小到大排序，最后按照 <span class="math inline">\(a\)</span>。</p>
<p>考虑证明上面贪心策略：设 <span class="math inline">\(\max(s_i,a_i)&lt;\max(s_j,a_j)\)</span></p>
<ul>
<li><p><span class="math inline">\(s_i\geq a_i,s_j\geq a_j\)</span></p>
<p>这种情况不难发现，如果我们先让 <span class="math inline">\(i\)</span> 爬，<span class="math inline">\(j\)</span> 一定可以爬，但是如果我们先让 $j $ 爬，<span class="math inline">\(i\)</span> 可能不能爬，所以我们先让 <span class="math inline">\(i\)</span> 爬，不会使答案变劣。</p></li>
<li><p><span class="math inline">\(s_i\geq a_i,s_j&lt;a_j\)</span></p>
<p>如果我们先让 <span class="math inline">\(i\)</span> 爬，然后 <span class="math inline">\(j\)</span> 一定可以爬，如果我们先让 <span class="math inline">\(j\)</span> 爬，<span class="math inline">\(i\)</span> 一定不能爬。我们先让 <span class="math inline">\(i\)</span> 爬，会使答案变优。</p></li>
<li><p><span class="math inline">\(s_i&lt;a_i,s_j\geq a_j\)</span></p>
<p>如果我们先让 <span class="math inline">\(i\)</span> 爬，然后 <span class="math inline">\(j\)</span> 一定可以爬，但是如果我们先让 <span class="math inline">\(j\)</span> 爬，<span class="math inline">\(i\)</span> 可能不能爬，所以我们先让 <span class="math inline">\(i\)</span> 爬不会使答案变劣。</p></li>
<li><p><span class="math inline">\(s_i&lt;a_i,s_j&lt;a_j\)</span></p>
<p>如果我们先让 <span class="math inline">\(i\)</span> 爬，<span class="math inline">\(j\)</span> 可能能爬，如果 <span class="math inline">\(j\)</span> 先爬，则 <span class="math inline">\(i\)</span> 一定不能爬，让 <span class="math inline">\(i\)</span> 先爬，不会是答案变劣。</p></li>
</ul>
<p>同理，经过同样的分析，我们可以得到当最值相等时我们让 <span class="math inline">\(s\)</span> 小的先爬不会使答案变劣。</p>
<p>排序直接跑就可以。</p>
<p>似乎是一个规律：如果一个贪心策略与两个元素的大小都有关系，不妨考虑其最小值或最大值，或者加减乘除运算。这个题就是一个典型的考虑最大值的贪心。</p>
<h3 id="code-5">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Alpinists</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, a;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Alpinists b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mx1 = <span class="built_in">Max</span>(s, a), mx2 = <span class="built_in">Max</span>(b.s, b.a);</span><br><span class="line">        <span class="keyword">if</span> (mx1 != mx2) <span class="keyword">return</span> mx1 &lt; mx2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> s == b.s ? a &lt; b.a : s &lt; b.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, d, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">read</span>(p[i].s), <span class="built_in">read</span>(p[i].a);</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (p[i].s &gt;= d) ++ ans, d = <span class="built_in">Max</span>(d, p[i].a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP冲刺-TEST10 总结</title>
    <url>/2021/10/29/ZROI-21-NOIP-SP-TEST10/</url>
    <content><![CDATA[<blockquote>
<p>...too young...too simple,sometimes naive!</p>
</blockquote>
<h2 id="t1-不知道高到哪里去了">#T1 不知道高到哪里去了</h2>
<blockquote>
<p>Time Limits: 3s | Memroy Limit: 256MiB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<blockquote>
<p>比你们不知道高到哪里去了！</p>
</blockquote>
<p>一个 <span class="math inline">\(n(n\leq10^4)\)</span> 个点 <span class="math inline">\(m(5\times10^5)\)</span> 条边的带权无向图（可能有重边、自环），你处在 <span class="math inline">\(C\)</span> 点，刺客开始时在 <span class="math inline">\(I\)</span> 点，你要到 <span class="math inline">\(T\)</span> 点去，你不知道刺客向哪里走，刺客时刻知道你的位置，问你的速度至少是刺客的多少倍（实数）才能安全到达 <span class="math inline">\(T\)</span> 点，如果无法到达，则输出 <code>-1</code>。</p>
<h3 id="大体思路">#大体思路</h3>
<p>考虑二分答案，考虑如何判定。显然我们可以得到每次到达任意一点的最小时间，刺客的最小时间可以提前用最短路得到，当我们发现当前边的终点的最小时间比刺客晚，那么我们就不前往，看最终是否能够到达 <span class="math inline">\(T\)</span> 点即可。时间复杂度为 <span class="math inline">\(O((m+n)\log^2 n)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair <span class="meta-string">&lt;double, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> dd eps = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt, w;&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> C, I, T, n, m;</span><br><span class="line"></span><br><span class="line">dd d[N], TimeLimit[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v, e[ecnt].w = w;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(w);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v, w); <span class="built_in">add_edge</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(C); <span class="built_in">read</span>(I); <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="built_in">fill</span>(TimeLimit + <span class="number">1</span>, TimeLimit + n + <span class="number">1</span>, INF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dd l = <span class="number">0</span>, r = <span class="number">10000001</span>;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;pdi &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, dd v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d + <span class="number">1</span>, d + n + <span class="number">1</span>, INF);</span><br><span class="line">    <span class="built_in">fill</span>(vis + <span class="number">1</span>, vis + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (TimeLimit[s] &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>, s)); d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[now]) <span class="keyword">continue</span>; vis[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = e[i].nxt) &#123;</span><br><span class="line">            dd w = (dd)e[i].w / v;</span><br><span class="line">            <span class="keyword">if</span> (d[e[i].v] &lt;= d[now] + w) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (TimeLimit[e[i].v] &lt;= d[now] + w) <span class="keyword">continue</span>;</span><br><span class="line">            d[e[i].v] = d[now] + w; </span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">mp</span>(-d[e[i].v], e[i].v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(dd mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dijkstra</span>(C, mid); <span class="keyword">return</span> d[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="built_in">dijkstra</span>(I, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) TimeLimit[i] = d[i];</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps) &#123;</span><br><span class="line">        dd mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= <span class="number">10000000</span>) &#123;<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t2-身经百战">#T2 身经百战</h2>
<blockquote>
<p>Time Limits: 1s | Memroy Limit: 256MiB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<blockquote>
<p>我是身经百战了，见得多了！</p>
</blockquote>
<p>身经百战的你要和怪物战斗。有 <span class="math inline">\(n(n\leq10^6)\)</span> 个怪，每个怪的血量 <span class="math inline">\(v_i(v_i\leq10^9)\)</span> 都是一个非负整数，当血量变为负数后怪就死了。有 <span class="math inline">\(m(m\leq10^5)\)</span> 种魔法，第 <span class="math inline">\(i\)</span> 种用一个三元组 <span class="math inline">\((a_i,b_i,c_i)\)</span> 表示，魔法可以重复使用。</p>
<p>你有两种操作可以做：</p>
<ul>
<li>花费 <span class="math inline">\(1\)</span> 点能量，给一个怪的血量减掉 <span class="math inline">\(1\)</span>。</li>
<li>如果一个怪的血量是 <span class="math inline">\(a_i\)</span>，你可以花费 <span class="math inline">\(c_i\)</span> 的能量把它的血量变为 <span class="math inline">\(b_i\)</span>。</li>
</ul>
<p>你希望削弱这些怪，但你不想杀生。请问最少要花费多少能量才能把所有怪的血量都变成 <span class="math inline">\(1\)</span>。注意：一个血量为 <span class="math inline">\(0\)</span> 的怪仍然是存活的。</p>
<p><strong>数据保证有解。</strong></p>
<h3 id="大体思路-1">#大体思路</h3>
<p>不难发现每个怪物都是独立的问题，所以其实可以看作多次询问，同样因为这个原因，我们尝试进行 DP。</p>
<p><span class="math inline">\(f_{i,j}\)</span> 表示将第 <span class="math inline">\(i\)</span> 个怪物的血量变为 <span class="math inline">\(j\)</span> 所需要的最小代价。注意到这个 DP 的转移具有后效性，所以考虑将所有转移变为边，找最短路，我们发现上面的状态设计有许多的冗余状态，我们只需要保留给出数据中出现的数，将原本 DP 的转移变为边则是 <span class="math inline">\(a_i\to b_i\)</span> （边权为 <span class="math inline">\(c_i\)</span>）以及 <span class="math inline">\(x_i\)</span> 向所有比它小的数连边（边权为差值），但是这样的边的数量仍旧是 <span class="math inline">\(O(m^2)\)</span> 级别的，不能接受，注意到第二部分的边可以被简化，也就是 <span class="math inline">\(x_i\)</span> 只需要向比自己小的第一个数连边即可，这样得到的转移图与之前是等价的，边的数量为 <span class="math inline">\(O(n+m)\)</span>，现在我们只需要建出反向边，以 <span class="math inline">\(1\)</span> 为源点最短路即可。</p>
<p>时间复杂度为 <span class="math inline">\(O((n+m)\log(n+m))\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plli pair <span class="meta-string">&lt;long long, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Magic</span> &#123;</span><span class="keyword">int</span> a, b; ll c;&#125; p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt; ll w;&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, v[N], head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>), a[N];</span><br><span class="line">ll d[N]; <span class="keyword">int</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v, e[ecnt].w = w;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(l, len, x) lower_bound(l + 1, l + len + 1, x)</span></span><br><span class="line"></span><br><span class="line">priority_queue &lt;plli &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mset</span>(d, <span class="number">0x3f</span>); <span class="built_in">mset</span>(vis, <span class="number">0</span>);</span><br><span class="line">    d[s] = <span class="number">0</span>; q.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[now]) <span class="keyword">continue</span>; vis[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = e[i].nxt)</span><br><span class="line">          <span class="keyword">if</span> (d[e[i].v] &gt; d[now] + e[i].w) &#123;</span><br><span class="line">              d[e[i].v] = d[now] + e[i].w;</span><br><span class="line">              q.<span class="built_in">push</span>(<span class="built_in">mp</span>(-d[e[i].v], e[i].v));</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(v[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(p[i].a), <span class="built_in">read</span>(p[i].b), <span class="built_in">read</span>(p[i].c);</span><br><span class="line">        a[i * <span class="number">2</span> - <span class="number">1</span>] = p[i].a, a[i * <span class="number">2</span>] = p[i].b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[<span class="number">2</span> * m + i] = v[i];</span><br><span class="line">    a[<span class="number">2</span> * m + n + <span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">2</span> * m + n + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> _m = <span class="built_in">unique</span>(a + <span class="number">1</span>, a + <span class="number">2</span> * m + n + <span class="number">2</span>) - a - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">lb</span>(a, _m, p[i].a) - a;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="built_in">lb</span>(a, _m, p[i].b) - a;</span><br><span class="line">        <span class="built_in">add_edge</span>(v, u, p[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; _m; ++ i)</span><br><span class="line">      <span class="built_in">add_edge</span>(i, i + <span class="number">1</span>, a[i + <span class="number">1</span>] - a[i]);</span><br><span class="line">    <span class="built_in">solve</span>((<span class="built_in">lb</span>(a, _m, <span class="number">1</span>) - a)); ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="built_in">lb</span>(a, _m, v[i]) - a;</span><br><span class="line">        ans += d[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t3-跑得比谁都快">#T3 跑得比谁都快</h2>
<blockquote>
<p>Time Limits: 3s | Memroy Limit: 256MiB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<blockquote>
<p>你们有一个好，全世界跑到什么地方，你们比其他的西方记者啊，跑得还快。</p>
</blockquote>
<p>这条路上有 <span class="math inline">\(n(n\leq2\times10^5)\)</span> 个红绿灯，把路分成了 <span class="math inline">\(n+1\)</span> 个部分。红绿灯的颜色是循环的，一次循环内，在 <span class="math inline">\([0,g)\)</span> 的时间里它是绿色的，在 <span class="math inline">\([g,g+r)\)</span> 的时间里它是红色的。一开始，每个红绿灯都处于循环的开始，也就是说都会先绿 <span class="math inline">\(g(g+r\leq10^9)\)</span> 的时间。</p>
<p>记者团里有 <span class="math inline">\(q(q\leq2\times10^5)\)</span> 个香港记者。每个记者要从路的开头跑到末端，遇到红灯的话不能穿过，必须等红灯变绿。记者的最大速度是 <span class="math inline">\(1\)</span>，记者可以瞬间改变自己的速度。告诉你记者出发的时间，问你她什么时候跑到。</p>
<p>本题<strong>强制在线</strong>，假如输入的第 <span class="math inline">\(i(1&lt;i\leq q)\)</span> 个记者的出发时间为 <span class="math inline">\(time_i\)</span>，那么她实际出发的时间是 <span class="math inline">\(time_i\text{ xor }(ans_{i−1} \bmod 2147483647)\)</span>，其中 <span class="math inline">\(ans_{i−1}\)</span> 表示第 <span class="math inline">\(i−1\)</span> 个人的到达时间。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>考虑在任意红绿灯出发遇到的第一个红灯的位置，由于 <span class="math inline">\(m=g+r\)</span> 是周期，所以不妨将时间通过 <span class="math inline">\(\bmod m\)</span> 将所有时间分为 <span class="math inline">\(m\)</span> 种，设 <span class="math inline">\(t_i\)</span> 为到达 <span class="math inline">\(i\)</span> 号红绿灯前没有任何一个红绿灯阻挡到达 <span class="math inline">\(i\)</span> 的时间，显然是 <span class="math inline">\(s_i\bmod m\)</span>（<span class="math inline">\(s_i\)</span> 为 <span class="math inline">\(len\)</span> 的前缀和），设 <span class="math inline">\(j\)</span> 为从 <span class="math inline">\(i\)</span> 出发后遇到的第一个红灯，由于两者之间没有任何红灯阻拦，考虑到从任意一个红绿灯出发必然是在该红绿灯进行了停顿，但显然不会对到 <span class="math inline">\(j\)</span> 的时间和到 <span class="math inline">\(i\)</span> 的时间之间的差值造成影响，且出发时间必然是 <span class="math inline">\(m\)</span> 的倍数，在 <span class="math inline">\(i\)</span> 于是两者之间经过的时间必然是 <span class="math inline">\(t_j-t_i=km+b\)</span>，<span class="math inline">\(k\in Z,b\in[g,r)\)</span>，于是我们找 <span class="math inline">\([t_i\bmod m+g,t_i\bmod m+r)\)</span> 区间最小值即可，然后采用 <span class="math inline">\(j\)</span> 到终点的时间更新 <span class="math inline">\(i\)</span> 到终点的时间，最后将 <span class="math inline">\(i\)</span> 插入到 <span class="math inline">\(t_i\bmod m\)</span> 的位置即可。</p>
<p>再来看查询时，同样考虑第一个遇到的红绿灯，不过上面维护出的都是开始时间为 <span class="math inline">\(0\)</span> 的情况（循环从头开始），所以我们开始时需要将查询区间进行矫正。</p>
<p>时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ls, rs, val;&#125; p[N];</span><br><span class="line"></span><br><span class="line">ll n, m, G, R, q, len[N], s[N], sp[N], lst, pcnt, f[N]; <span class="keyword">int</span> rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) k = ++ pcnt; p[k].val = c;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>; <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">insert</span>(p[k].ls, l, mid, x, c);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(p[k].rs, mid + <span class="number">1</span>, r, x, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> n + <span class="number">1</span>; <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> p[k].val;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, res = INF;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) res = <span class="built_in">min</span>(res, <span class="built_in">query</span>(p[k].ls, l, mid, x, y));</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) res = <span class="built_in">min</span>(res, <span class="built_in">query</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> y == n + <span class="number">1</span> ? s[y] - s[x] : (s[y] - s[x] + m - <span class="number">1</span>) / m * m;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(G), <span class="built_in">read</span>(R); m = G + R;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++ i) <span class="built_in">read</span>(len[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++ i)</span><br><span class="line">      s[i] = s[i - <span class="number">1</span>] + len[i], sp[i] = s[i] % m; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = (sp[i] + G) % m, r = (l + R - <span class="number">1</span>) % m, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) pos = <span class="built_in">min</span>(<span class="built_in">query</span>(rt, <span class="number">0</span>, m - <span class="number">1</span>, <span class="number">0</span>, r), <span class="built_in">query</span>(rt, <span class="number">0</span>, m - <span class="number">1</span>, l, m - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> pos = <span class="built_in">query</span>(rt, <span class="number">0</span>, m - <span class="number">1</span>, l, r);</span><br><span class="line">        f[i] = <span class="built_in">dist</span>(i, pos) + f[pos]; <span class="built_in">insert</span>(rt, <span class="number">0</span>, m - <span class="number">1</span>, sp[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        ll x; <span class="built_in">read</span>(x); x ^= (lst % MOD); s[<span class="number">0</span>] = -x; <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = (<span class="number">0ll</span> + m - x % m + G) % m, r = (l + R - <span class="number">1</span>) % m;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) pos = <span class="built_in">min</span>(<span class="built_in">query</span>(rt, <span class="number">0</span>, m - <span class="number">1</span>, <span class="number">0</span>, r), <span class="built_in">query</span>(rt, <span class="number">0</span>, m - <span class="number">1</span>, l, m - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> pos = <span class="built_in">query</span>(rt, <span class="number">0</span>, m - <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, lst = <span class="built_in">dist</span>(<span class="number">0</span>, pos) + f[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t4-人生经验">#T4 人生经验</h2>
<blockquote>
<p>Time Limits: 1s | Memroy Limit: 512MiB</p>
</blockquote>
<h3 id="题意简述-3">#题意简述</h3>
<blockquote>
<p>我作为一个长者，来告诉你们一些人生的经验…</p>
</blockquote>
<p>人生经验以 01 字符串的形式存在。</p>
<p>一个长度为奇数的 01 字符串是好的，当且仅当它可以被用下面的办法转化为 <code>1</code>：</p>
<ul>
<li>选一个奇数 <span class="math inline">\(i(3\leq i\leq|S|)\)</span></li>
<li>把 <span class="math inline">\(S\)</span> 分成两个字符串 <span class="math inline">\(A,B\)</span> 满足 <span class="math inline">\(|A|=i,|B|=|S|−i,S=AB\)</span></li>
<li>通过一个给定的函数 <span class="math inline">\(f(U)\)</span> 将 <span class="math inline">\(A\)</span> 的末尾三位数变为一位数，一直重复直到 <span class="math inline">\(A\)</span> 只剩下一个数</li>
<li>用 <span class="math inline">\(A+B\)</span> 替代 <span class="math inline">\(S\)</span>。</li>
</ul>
<p>现在给定一个字符串，包含 <code>0</code> <code>1</code> <code>?</code> 三种字符，<code>?</code> 可以替换为 <code>0</code> 或者 <code>1</code>，请问有多少种替换方案使得替换的结果是一个好串。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>DP 套 DP。</p>
<p>我们考虑如何判断一个串是否合法，不难发现，那些操作都可以转化成下面两个操作：</p>
<ul>
<li>把两个字符压入栈。</li>
<li>把一个字符压入栈，进行缩字符串，然后再让另一个字符入栈。</li>
</ul>
<p>虽然栈的情况可能很多，但其实去掉我们不管的，只有 <span class="math inline">\(4\)</span> 种情况：</p>
<ol type="1">
<li>当前栈中序列加入 <code>1</code> 之后能缩成 <code>1</code>。</li>
<li>当前栈中序列加入 <code>1</code> 之后能缩成 <code>0</code>。</li>
<li>当前栈中序列加入 <code>0</code> 之后能缩成 <code>1</code>。</li>
<li>当前栈中序列加入 <code>0</code> 之后能缩成 <code>0</code>。</li>
</ol>
<p>上面四种情况就是我们所关心的。然后我们就可以设计 DP 状态：</p>
<p><span class="math inline">\(f_{i,a}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 个字符，第 <span class="math inline">\(a\)</span> 个放法是否合法，然后考察整个字符串的话，只需要看 <span class="math inline">\(f_{n−1}\)</span> 即可。</p>
<p>接下来我们考虑计数，通过上面的启发，再加上字符串是不确定的，所以我们设状态 <span class="math inline">\(g_{a,b,c,d}\)</span> 分别表示上面 <span class="math inline">\(4\)</span> 种转移是否合法，<span class="math inline">\(f_{i,S}\)</span> 表示考虑到第 <span class="math inline">\(i\)</span> 位，合法转移为 <span class="math inline">\(S\)</span> 的情况的数量。</p>
<p>我们每次考虑两个数，先考虑两个字符压入栈的情况，然后枚举合法情况，转移即可。</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, t, f[N][<span class="number">16</span>], a[N], ans; <span class="keyword">char</span> s[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;<span class="keyword">return</span> g[x | (y &lt;&lt; <span class="number">1</span>) | (z &lt;&lt; <span class="number">2</span>)] - <span class="string">&#x27;0&#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Madd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y &gt;= MOD ? x + y - MOD : x + y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MAIN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, g, s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">mset</span>(f, <span class="number">0</span>); ans = <span class="number">0</span>; f[<span class="number">0</span>][<span class="number">9</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++ i) </span><br><span class="line">      <span class="keyword">for</span> (a[i - <span class="number">1</span>] = <span class="number">0</span>; a[i - <span class="number">1</span>] &lt; <span class="number">2</span>; ++ a[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> (a[i] = <span class="number">0</span>; a[i] &lt; <span class="number">2</span>; ++ a[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] != a[i - <span class="number">1</span>] + <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; s[i] != a[i] + <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; <span class="number">16</span>; ++ S) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!f[i - <span class="number">2</span>][S]) <span class="keyword">continue</span>; <span class="keyword">int</span> SS = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>; p1 &lt; <span class="number">2</span>; ++ p1)</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> p2 = <span class="number">0</span>; p2 &lt; <span class="number">2</span>; ++ p2) &#123;</span><br><span class="line">                      <span class="keyword">int</span> p = ((S &amp; (<span class="number">1</span> &lt;&lt; (<span class="built_in">get</span>(a[i - <span class="number">1</span>], a[i], p1) &lt;&lt; <span class="number">1</span>) + p2)) &gt; <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">if</span> (<span class="built_in">get</span>(<span class="number">0</span>, a[i], p1) == p2) p |= ((S &amp; (<span class="number">1</span> &lt;&lt; (a[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>))) &gt; <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">if</span> (<span class="built_in">get</span>(<span class="number">1</span>, a[i], p1) == p2) p |= ((S &amp; (<span class="number">1</span> &lt;&lt; (a[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>)) &gt; <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">if</span> (p) SS |= (<span class="number">1</span> &lt;&lt; (p1 &lt;&lt; <span class="number">1</span>) + p2);</span><br><span class="line">                  &#125;</span><br><span class="line">                f[i][SS] = <span class="built_in">Madd</span>(f[i][SS], f[i - <span class="number">2</span>][S]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (a[n] = <span class="number">0</span>; a[n] &lt; <span class="number">2</span>; ++ a[n]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s[n] != <span class="string">&#x27;?&#x27;</span>) &amp;&amp; (s[n] != a[n] + <span class="string">&#x27;0&#x27;</span>))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; <span class="number">16</span>; ++ S)</span><br><span class="line">          <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; (a[n] &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>))</span><br><span class="line">            ans = <span class="built_in">Madd</span>(ans, f[n - <span class="number">1</span>][S]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t); <span class="keyword">while</span> (t --) <span class="built_in">MAIN</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP冲刺-TEST9 总结</title>
    <url>/2021/10/29/ZROI-21-NOIP-SP-TEST9/</url>
    <content><![CDATA[<h2 id="t1-红黑树">#T1 红黑树</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 512MiB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>给定一棵 <span class="math inline">\(n(n\leq10^6)\)</span> 个节点的树，每个节点有红、黑两种颜色，每次可以将颜色相同的连通块染为另一种颜色，问将整棵树变为同种颜色的最少步数。</p>
<h3 id="大体思路">#大体思路</h3>
<p>不难发现初始状态下相同颜色的点的变化必然是同步的，所以我们可以将一个颜色是相同的连通块合并为一个点，得到一棵新的树，然后我们发现我们最优的策略必然是从中心开始，一点一点地将整棵树变为同种颜色，不难发现这样所需的操作次数是 <span class="math inline">\(\left\lfloor\frac {len} 2\right\rfloor\)</span>，其中 <span class="math inline">\(len\)</span> 为新的树的直径，证明可以考虑 <span class="math inline">\(len\)</span> 为奇数、偶数两种情况分开讨论。时间复杂度为 <span class="math inline">\(O(n)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N], ne[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N], siz[N], num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        num = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++ i)</span><br><span class="line">          fa[i] = i, siz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != fa[x]) x = fa[x] = fa[fa[x]]; <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (siz[x] &gt; siz[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        siz[y] += siz[x], fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; dsu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, col[N], head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>), <span class="built_in">ncnt</span>(<span class="number">1</span>), nhead[N], vis[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ne[ncnt].u = u, ne[ncnt].v = v;</span><br><span class="line">    ne[ncnt].nxt = nhead[u], nhead[u] = ncnt ++;</span><br><span class="line"></span><br><span class="line">    ne[ncnt].u = v, ne[ncnt].v = u;</span><br><span class="line">    ne[ncnt].nxt = nhead[v], nhead[v] = ncnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (col[e[i].v] == col[x])</span><br><span class="line">          dsu.<span class="built_in">merge</span>(e[i].v, x), <span class="built_in">combine</span>(e[i].v, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (col[e[i].v] != col[x])</span><br><span class="line">          <span class="built_in">connect</span>(dsu.<span class="built_in">find</span>(x), dsu.<span class="built_in">find</span>(e[i].v));</span><br><span class="line">        <span class="built_in">build</span>(e[i].v, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    d[x] = d[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nhead[x]; i; i = ne[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ne[i].v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(ne[i].v, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &gt; d[res]) res = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); dsu.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">char</span> c; cin &gt;&gt; c; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) col[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> col[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v); <span class="built_in">add_edge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (!vis[i]) <span class="built_in">combine</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>, ed = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">dfs</span>(dsu.<span class="built_in">find</span>(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mset</span>(d, <span class="number">0</span>); st = res; res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(dsu.<span class="built_in">find</span>(st), <span class="number">0</span>); ed = res;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, d[ed] / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t2-操作序列">#T2 操作序列</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 512MiB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>给出一个长度为 <span class="math inline">\(k(k\leq10^5)\)</span> 的数列，然后给出 <span class="math inline">\(n(n\leq10^5)\)</span> 个操作：</p>
<p>操作分为三种：</p>
<ol type="1">
<li><span class="math inline">\(a_i=b\)</span>；</li>
<li>给 <span class="math inline">\(a_i\)</span> 加上 <span class="math inline">\(b\)</span>；</li>
<li>给 <span class="math inline">\(a_i\)</span> 乘上 <span class="math inline">\(b\)</span>；</li>
</ol>
<p>其中 <span class="math inline">\(i,b\)</span> 是给定的，每个操作只能用一次，最多使用 <span class="math inline">\(m(m\leq10^5)\)</span> 个操作，让整个数列的乘积最大，给出最大乘积模 <span class="math inline">\(10^9+7\)</span> 后的结果。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>显然对于同一个位置，赋值操作只会使用一次，然后我们便可以将胜出的赋值操作转化为加法操作，然后对于加法操作，我们一定是先加贡献大的那个，之后便可以把所有的加法操作转化为乘法操作，注意到每一个加法操作一定是在相同位置上一步加法操作的基础上转化，得到新的权值——采用此操作可以使答案怎加多少倍。</p>
<p>之后将所有的乘法操作按照新的权值排序即可。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pbk(x) push_back(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="keyword">double</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _id, <span class="keyword">double</span> _val)</span> </span>&#123;id = _id, val = _val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">action</span> &#123;</span><span class="keyword">int</span> op, pos; ll val;&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, n, m; ll a[N], ans = <span class="number">1</span>, cov[N];</span><br><span class="line"></span><br><span class="line">vector &lt;Node&gt; add, mul, v[N];</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; fnl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> * a[pos] + val) / (<span class="number">1.0</span> * a[pos]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123;<span class="keyword">return</span> x.val &gt; y.val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x].pos != p[y].pos) <span class="keyword">return</span> p[x].pos &lt; p[y].pos;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p[x].op != p[y].op) <span class="keyword">return</span> p[x].op &lt; p[y].op;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p[x].val &lt; p[y].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(k), <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, pos; ll val;</span><br><span class="line">        <span class="built_in">read</span>(op), <span class="built_in">read</span>(pos), <span class="built_in">read</span>(val);</span><br><span class="line">        p[i].op = op, p[i].pos = pos, p[i].val = val;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cov[pos]) cov[pos] = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p[cov[pos]].val &lt; val)</span><br><span class="line">              cov[pos] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) v[pos].<span class="built_in">pbk</span>(<span class="built_in">Node</span>(i, <span class="number">1.0</span> * val));</span><br><span class="line">        <span class="keyword">else</span> mul.<span class="built_in">pbk</span>(<span class="built_in">Node</span>(i, <span class="number">1.0</span> * val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) <span class="keyword">if</span> (cov[i])</span><br><span class="line">      v[i].<span class="built_in">pbk</span>(<span class="built_in">Node</span>(cov[i], <span class="number">1.0</span> * (p[cov[i]].val - a[i])));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">1.0</span> * a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : v[i]) &#123;</span><br><span class="line">            mul.<span class="built_in">pbk</span>(<span class="built_in">Node</span>(x.id, (sum + x.val) / sum));</span><br><span class="line">            sum += x.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(mul.<span class="built_in">begin</span>(), mul.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; i &lt; mul.<span class="built_in">size</span>(); ++ i) fnl.<span class="built_in">pbk</span>(mul[i].id);</span><br><span class="line">    <span class="built_in">sort</span>(fnl.<span class="built_in">begin</span>(), fnl.<span class="built_in">end</span>(), cmp2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : fnl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x].op == <span class="number">1</span>) a[p[x].pos] = <span class="built_in">max</span>(a[p[x].pos], p[x].val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[x].op == <span class="number">2</span>) (a[p[x].pos] += p[x].val) %= MOD;</span><br><span class="line">        <span class="keyword">else</span> (a[p[x].pos] *= p[x].val) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) (ans *= a[i]) %= MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t3-吃零食">#T3 吃零食</h2>
<blockquote>
<p>Time Limit: 1s | Memory Limit: 256MiB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p>对于 <span class="math inline">\(n(n\leq10^6)\)</span> 的一个排列 <span class="math inline">\(p_i\)</span>，它的贡献是 <span class="math inline">\(s=\sum(i\bmod p_i)\)</span>，现在已知 <span class="math inline">\(s(s\leq10^{18})\)</span>，请给出一组合法的 <span class="math inline">\(p_i\)</span>，若无解则输出 <code>SPFA is dead!</code>。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>首先，显然 <span class="math inline">\(s\)</span> 的上界是 <span class="math display">\[
\sum_{i=0}^{n-1}i=\dfrac{n\cdot(n-1)}2
\]</span> 然后，考虑进行如下构造：</p>
<p>最初，<span class="math inline">\(a_n=1,a_i=i+1(i\in\{2,3,\dots,n-1\})\)</span>，显然这样的贡献和是 <span class="math inline">\(S=\frac{n\cdot(n-1)}2\)</span>，我们考虑 <span class="math inline">\(\Delta s=S-s\)</span>，从大到小枚举 <span class="math inline">\(i\)</span>，对于 <span class="math inline">\(i\leq\Delta s\)</span>，我们每次交换 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i-1}\)</span>，显然这样会使 <span class="math inline">\(\Delta s\)</span> 减小 <span class="math inline">\(i\)</span>，可以用归纳法证明，这样可以得到 <span class="math display">\[
[3,\dfrac {n\cdot(n-1)}2 - 2]\cup\{\dfrac{n\cdot(n - 1)}2\}
\]</span> 中的所有数，剩下的部分单独特殊构造即可。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, s, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;SPFA is dead!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;2\n1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++ i)</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;SPFA is dead!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;3\n1\n2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++ i)</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; n * (n - <span class="number">1</span>) / <span class="number">2</span>) &#123;<span class="built_in">puts</span>(<span class="string">&quot;SPFA is dead!\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        ll rest = n * (n - <span class="number">1</span>) / <span class="number">2</span> - s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) a[i] = i + <span class="number">1</span>; a[n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) a[<span class="number">1</span>] = <span class="number">3</span>, a[<span class="number">2</span>] = <span class="number">1</span>, a[n] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">swap</span>(a[<span class="number">1</span>], a[n]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; -- i) <span class="keyword">if</span> (rest &gt;= i)</span><br><span class="line">              rest -= i, <span class="built_in">swap</span>(a[i], a[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t4-数树">#T4 数树</h2>
<blockquote>
<p>Time Limit: 3s | Memory Limit: 512MiB</p>
</blockquote>
<p>咕咕咕～</p>
<p><img src="https://pic.imgdb.cn/item/617b3cfe2ab3f51d9195dba8.png" /></p>
<p><img src="https://pic.imgdb.cn/item/617b3cf02ab3f51d9195d00b.jpg" /></p>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP冲刺-TEST7 总结</title>
    <url>/2021/10/26/ZROI-21-NOIP-SP-TEST7/</url>
    <content><![CDATA[<h2 id="t1-tournament">#T1 tournament</h2>
<blockquote>
<p>Time Limit: 1s Memory Limit: 512MiB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>Zbox 投资了一家电子竞技俱乐部, 现在这家俱乐部需要参加一个杯赛.</p>
<p>这次的杯赛中总共有 <span class="math inline">\(2^n(n\leq18)\)</span> 支参赛队伍, 队伍之间的实力差距很大, 不妨认为一场比赛实力较强的队伍必然会获胜.</p>
<p>不妨认为实力最弱的队伍编号为 <span class="math inline">\(1\)</span>，次弱的编号为 <span class="math inline">\(2\)</span>，…，最强的编号为 <span class="math inline">\(2^n\)</span>.</p>
<p>赛程如下所示:</p>
<p><img src="https://pic.imgdb.cn/item/6177ea4a2ab3f51d9105a9b1.png" /></p>
<p>序列 <span class="math inline">\(p_1,p_2,\dots,p_{2^n}\)</span> 将在输入中给出, 每个位置上的数字表示在这个位置上的是编号为这个数字的队伍.</p>
<p>由于 Zbox 非常有钱, 他可以花钱使得他投资的队伍和另一只队伍交换位置(<strong>也可以不交换</strong>).</p>
<p>现在 Zbox 希望他的队伍能够赢下尽可能多的比赛, 但他却忘了将他投资的队伍编号告诉你, 因此你需要输入对于每个编号的队伍, 进行一次交换位置操作后, 至多能在这场杯赛中赢下几轮.</p>
<h3 id="大体思路">#大体思路</h3>
<p>发现 <span class="math inline">\(x\)</span> 可以赢 <span class="math inline">\(i\)</span> 场当且仅当存在一个开始位置为 <span class="math inline">\(k2^{i}+1(k\in N)\)</span> 的长度为 <span class="math inline">\(2^i\)</span> 的区间的次大值小于 <span class="math inline">\(x\)</span>，于是我们可以用 st 表维护出是否存在长度为 <span class="math inline">\(2^i\)</span> 且起始位置为 <span class="math inline">\(k2^i+1(k\in N)\)</span> 的区间的次大值为 <span class="math inline">\(x\)</span>，然后即可得到是否存在长度为 <span class="math inline">\(2^i\)</span> 且起始位置为 <span class="math inline">\(k2^i+1(k\in N)\)</span> 的区间的次大值小于等于 <span class="math inline">\(x\)</span>，然后对于每个数 <span class="math inline">\(O(1)\)</span> 查询是否存在合法区间次大值小于等于 <span class="math inline">\(x-1\)</span> 即可，总体时间复杂度为 <span class="math inline">\(O(n\cdot2^n)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, lmt, a[N], mx[<span class="number">20</span>][N], sec[<span class="number">20</span>][N], vis[<span class="number">20</span>][N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); lmt = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lmt; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lmt; ++ i) mx[<span class="number">0</span>][i] = a[i], sec[<span class="number">0</span>][i] = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= lmt; j += (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mx[i - <span class="number">1</span>][j] &lt; mx[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]) &#123;</span><br><span class="line">              mx[i][j] = mx[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)];</span><br><span class="line">              sec[i][j] = <span class="built_in">Max</span>(sec[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)], mx[i - <span class="number">1</span>][j]);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mx[i][j] = mx[i - <span class="number">1</span>][j];</span><br><span class="line">              sec[i][j] = <span class="built_in">Max</span>(sec[i - <span class="number">1</span>][j], mx[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">          &#125;</span><br><span class="line">          vis[i][sec[i][j]] |= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lmt; ++ j)</span><br><span class="line">        vis[i][j] |= vis[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lmt; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        <span class="keyword">if</span> (vis[j][a[i] - <span class="number">1</span>]) ans[a[i]] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lmt; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t2-inversion">#T2 inversion</h2>
<blockquote>
<p>Time Limit: 1s Memory Limit: 512MiB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定一个 <span class="math inline">\(n(n\leq3\times 10^5)\)</span> 个点的树，你可以选定树上任意点为起点，走出一条长度为 <span class="math inline">\(k(k\leq3\times10^5)\)</span> 的路径，这条路径的贡献是按顺序将这条路径所经过的点的编号排列得到的序列的逆序对数，问整棵树的贡献和。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>考虑树上一条长度为 <span class="math inline">\(k\)</span> 的路径会以两种顺序计算两遍代价，考虑一个长度为 <span class="math inline">\(k+1\)</span> 序列 <span class="math inline">\(a_i\)</span> 在正反计算两遍逆序对数会有哪些性质，不难发现，对于数 <span class="math inline">\(a_i,a_j\)</span>，无序数对 <span class="math inline">\((a_i,a_j)\)</span> 必然会被计算恰好一次，于是整个序列的贡献便是 <span class="math inline">\(\binom{k+1}{2}\)</span>。</p>
<p>我们将这个结论放回到树上，也就是对于一个长度为 <span class="math inline">\(k\)</span> 的路径，它具有 <span class="math inline">\(k+1\)</span> 个点，正反计算两遍得到的贡献就是 <span class="math inline">\(\binom{k+1} 2\)</span>，于是我们只需要计算长度为 <span class="math inline">\(k\)</span> 的路径的个数即可。</p>
<p>这里采用长链剖分进行计算，时间复杂度为 <span class="math inline">\(O(n)\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>), K;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[N], mxd[N], *dp[N], buf[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].v == fa) <span class="keyword">continue</span>; <span class="built_in">dfs</span>(e[i].v, x);</span><br><span class="line">        <span class="keyword">if</span> (mxd[e[i].v] &gt; mxd[son[x]]) son[x] = e[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    mxd[x] = mxd[son[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = buf; ll cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dp[x] = p++; dp[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) <span class="built_in">DP</span>(son[x], x);</span><br><span class="line">    <span class="keyword">if</span> (mxd[x] &gt; K) (cnt += dp[x][K]) %= MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].v == fa || e[i].v == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">DP</span>(e[i].v, x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">max</span>(<span class="number">0</span>, K - mxd[x]); j &lt; mxd[e[i].v] &amp;&amp; j &lt; K; ++j)</span><br><span class="line">          (cnt += <span class="number">1ll</span> * dp[e[i].v][j] * dp[x][K - j - <span class="number">1</span>]) %= MOD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mxd[e[i].v]; ++j)</span><br><span class="line">          dp[x][j] = (dp[x][j] + dp[e[i].v][j - <span class="number">1</span>]) % MOD;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v), <span class="built_in">add_edge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">DP</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, cnt * (<span class="number">1ll</span> * (K + <span class="number">1</span>) * K / <span class="number">2</span> % MOD) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t3-tree">#T3 tree</h2>
<blockquote>
<p>Time Limit: 1s Memory Limit: 512 MiB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p>给定一个 <span class="math inline">\(n(n\leq5\times10^5)\)</span> 个点的基环树，每条边的价值为断开这条边后的树的直径，如果断开后不再连通，那么这条边的价值为 <span class="math inline">\(-1\)</span>，要求计算所有边的价值。</p>
<h3 id="大体思路-2">#大体思路</h3>
<blockquote>
<p>又是一个考场上想出来没调出来的题QnQ</p>
</blockquote>
<p>考虑到树的直径共有两种：一种是不经过环的子树上的直径，另一种经过环。</p>
<p>对于第一种，我们可以直接通过树形 DP 进行计算；而对于第二种，我们考虑断开环上的每一条边后复制一遍，设 <span class="math inline">\(f_i\)</span> 表示断开 <span class="math inline">\(i\)</span> 后面的边得到的最大直径，按如下 DP 方程进行计算： <span class="math display">\[
f_{i}=\max\limits_{i-len&lt;j&lt;k\leq i}\{g_j+g_k+k-j\},
\]</span> 其中 <span class="math inline">\(g_x\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树的最大深度，对上面的式子进行变形得到： <span class="math display">\[
f_i=\max_{i-len&lt;j&lt;i}\{g_j-j+\max\limits_{j&lt;k\leq i}\{g_k+k\}\},
\]</span> 不难发现上面的式子可以通过同时维护两个单调队列进行优化（<strong>注意边界！</strong>），整体时间复杂度是 <span class="math inline">\(O(n)\)</span>.</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N], te[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, head[N], <span class="built_in">ecnt</span>(<span class="number">2</span>), vis[N], endpos, pre[N], spc[N], nxt[N];</span><br><span class="line"><span class="keyword">int</span> ring[N], rcnt, ve[N], f[N], g[N], ans, pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_ring</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].v == fa) <span class="keyword">continue</span>; pre[e[i].v] = i;</span><br><span class="line">        <span class="keyword">if</span> (vis[e[i].v]) &#123;endpos = e[i].v; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get_ring</span>(e[i].v, x)) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ring_list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = endpos;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ring[++ rcnt] = now;</span><br><span class="line">        ve[pre[now]] = ve[pre[now] ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        nxt[e[pre[now]].u] = pre[now] / <span class="number">2</span>;</span><br><span class="line">        now = e[pre[now]].u;</span><br><span class="line">    &#125; <span class="keyword">while</span> (now != endpos);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rcnt; ++ i)</span><br><span class="line">      ring[i + rcnt] = ring[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp_on_tree</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    g[x] = <span class="number">0</span>, f[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].v == fa || ve[i] || ve[i ^ <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp_on_tree</span>(e[i].v, x);</span><br><span class="line">        f[x] = <span class="built_in">Max</span>(f[x], f[e[i].v]);</span><br><span class="line">        f[x] = <span class="built_in">Max</span>(f[x], g[x] + g[e[i].v] + <span class="number">1</span>);</span><br><span class="line">        g[x] = <span class="built_in">Max</span>(g[x], g[e[i].v] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q1[N], q2[N], frt1 = <span class="number">0</span>, tal1 = <span class="number">-1</span>, frt2 = <span class="number">0</span>, tal2 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(te[i].u), <span class="built_in">read</span>(te[i].v);</span><br><span class="line">        <span class="built_in">add_edge</span>(te[i].u, te[i].v);</span><br><span class="line">        <span class="built_in">add_edge</span>(te[i].v, te[i].u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_ring</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">get_ring_list</span>(); <span class="built_in">reverse</span>(ring + <span class="number">1</span>, ring + rcnt * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rcnt; ++ i) <span class="built_in">dp_on_tree</span>(ring[i], <span class="number">0</span>), ans = <span class="built_in">Max</span>(ans, f[ring[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rcnt; ++ i) spc[nxt[ring[i]]] = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rcnt; ++ i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (frt1 &lt;= tal1 &amp;&amp; g[ring[q1[tal1]]] - q1[tal1] &lt; g[ring[i]] - i) -- tal1;</span><br><span class="line">        <span class="keyword">while</span> (frt2 &lt;= tal2 &amp;&amp; g[ring[q2[tal2]]] + q2[tal2] &lt; g[ring[i]] + i) -- tal2;</span><br><span class="line">        q1[++ tal1] = i, q2[++ tal2] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = rcnt + <span class="number">1</span>; i &lt;= rcnt &lt;&lt; <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (frt1 &lt;= tal1 &amp;&amp; q1[frt1] &lt;= i - rcnt) ++ frt1;</span><br><span class="line">        <span class="keyword">while</span> (frt2 &lt;= tal2 &amp;&amp; q2[frt2] &lt;= q1[frt1]) ++ frt2;</span><br><span class="line">        <span class="keyword">while</span> (frt2 &lt;= tal2 &amp;&amp; g[ring[q2[tal2]]] + q2[tal2] &lt; g[ring[i]] + i) -- tal2; q2[++ tal2] = i;</span><br><span class="line">        spc[nxt[ring[i]]] = <span class="built_in">Max</span>(spc[nxt[ring[i]]], g[ring[q1[frt1]]] - q1[frt1] + g[ring[q2[frt2]]] + q2[frt2]);</span><br><span class="line">        <span class="keyword">while</span> (frt1 &lt;= tal1 &amp;&amp; g[ring[q1[tal1]]] - q1[tal1] &lt; g[ring[i]] - i) -- tal1; q1[++ tal1] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (ve[i &lt;&lt; <span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, spc[i]);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t4-turing-machine">#T4 turing machine</h2>
<blockquote>
<p>Time Limit: 1s Memory Limit: 512MiB</p>
</blockquote>
<h3 id="题意简述-3">#题意简述</h3>
<p>给定程序</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">read</span>(n);<span class="keyword">read</span>(T);</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">read</span>(a[i]);<span class="comment">//a[i] must be 0 or 1</span></span><br><span class="line"><span class="keyword">for</span> t = <span class="number">1</span> <span class="keyword">to</span> T <span class="keyword">do</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        do_swap[i]=(a[i-<span class="number">1</span>]==<span class="number">0</span>) <span class="keyword">and</span> (a[i]==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> (do_swap[i]) <span class="keyword">then</span></span><br><span class="line">            swap(a[i-<span class="number">1</span>],a[i]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">write</span>(a[i],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 <span class="math inline">\(n,T\leq10^6\)</span>，优化该程序。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>首先理解给定的程序，是对于给定的 01 串，每次将所有前一位是 0 的 1 向前移动一位，问 <span class="math inline">\(T\)</span> 次变化后的 01 串。</p>
<p>于是我们对每一个 1 进行考虑，考虑他在哪些变化中不会向前移动，显然除了两者开始时相邻的情况外，在左边的 1 不会被阻止的变化，右边的 1 一定也不会在该次变化中被阻止，于是我们可以用队列维护被阻止的次数。开始时所有的变化都在队列中，显然当两者距离大于 <span class="math inline">\(1\)</span> 时，由于最开始两者同步变化，当前者停下时，两者的距离减一次变化一定不会阻止后者；剩下的部分则是当后者停下后（变化结束后）多余的阻挡和有效的阻挡。整体时间复杂度 <span class="math inline">\(O(n)\)</span>.</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], q[N], frt, tal = <span class="number">-1</span>, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; ~i; -- i) q[++ tal] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lst = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">read</span>(x); <span class="keyword">if</span> (!x) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> len = i - lst - <span class="number">1</span>; ++ tot;</span><br><span class="line">        q[++ tal] = -tot; tal = <span class="built_in">max</span>(frt - <span class="number">1</span>, tal - len);</span><br><span class="line">        <span class="keyword">while</span> (frt &lt;= tal &amp;&amp; q[frt] + tot &gt;= m) ++ frt;</span><br><span class="line">        a[i - m + tal - frt + <span class="number">1</span>] = <span class="number">1</span>, lst = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP冲刺-TEST6 总结</title>
    <url>/2021/10/26/ZROI-21-NOIP-SP-TEST6/</url>
    <content><![CDATA[<blockquote>
<p>莫要问 TEST5 去哪了，他有 4 道巨大恶心的计数题，补不动了QwQ</p>
</blockquote>
<h2 id="t1-夏令营">#T1 夏令营</h2>
<h3 id="题意简述">#题意简述</h3>
<p>给定 <span class="math inline">\(n(n\leq3\times10^5)\)</span> 个区间，每个区间有价值 <span class="math inline">\(h_i(1\leq3\times10^5)\)</span>，每个点 <span class="math inline">\(i(i\in[1,D])\)</span> 只能选最多 <span class="math inline">\(k\)</span> 个覆盖该点的区间，问可到的价值和最大的点的最大价值和。</p>
<h3 id="大体思路">#大体思路</h3>
<p>注意到我们只关注单点，且对于覆盖信息相同的点并没有实际区别，于是我们可以考虑将原本的一个区间拆成两个操作：加入和删除。</p>
<p>现在考虑如何快速维护这两个操作。注意到覆盖每个点的的区间分为两部分：包含在该点的答案里的和候选的，如果我们按照时间顺序维护这两个操作，不难发现，当新加入一个区间时，如果这个区间的价值大于当前已选区间的最小者，那么就把它加入答案，将最小者加入候选部分，否则直接加入候选；删除时，如果在候选部分就直接删，否则需要取出候选部分的最大值加入答案。</p>
<p>不难发现两个 <code>priority_queue</code> 就可以完成上面所需的操作（对顶堆？），删除时直接维护信息进行懒删除即可，每次修改只会进行 <span class="math inline">\(O(1)\)</span> 级别的操作，于是单次修改的时间复杂度为 <span class="math inline">\(O(\log n)\)</span>，总体时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plli pair <span class="meta-string">&lt;long long, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Activity</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, l, r; ll x;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Activity &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x &gt; b.x;&#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, d, k, q[N], siz, frt, tal, vis[N], st[N]; ll ans, sum;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;plli &gt; pq, cand;</span><br><span class="line"></span><br><span class="line">vector &lt;pii &gt; qry[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Activity x, Activity y)</span> </span>&#123;<span class="keyword">return</span> x.l == y.l ? x.r &lt; y.r : x.l &lt; y.l;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    frt = <span class="number">0</span>, tal = <span class="number">-1</span>; ans = <span class="number">0</span>; <span class="built_in">mset</span>(vis, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mset</span>(st, <span class="number">0</span>); <span class="keyword">while</span> (pq.<span class="built_in">size</span>()) pq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span> (cand.<span class="built_in">size</span>()) cand.<span class="built_in">pop</span>(); siz = sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; ++ i) qry[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (siz &lt; k) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">mp</span>(-a[x].x, x)); ++ siz;</span><br><span class="line">        sum += a[x].x; st[x] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        plli tmp = pq.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &amp;&amp; vis[tmp.second]) &#123;pq.<span class="built_in">pop</span>(); tmp = pq.<span class="built_in">top</span>();&#125;</span><br><span class="line">        <span class="keyword">if</span> (-tmp.first &lt; a[x].x) &#123;</span><br><span class="line">            pq.<span class="built_in">pop</span>(); cand.<span class="built_in">push</span>(<span class="built_in">mp</span>(-tmp.first, tmp.second));</span><br><span class="line">            sum += a[x].x + tmp.first;</span><br><span class="line">            pq.<span class="built_in">push</span>(<span class="built_in">mp</span>(-a[x].x, x));</span><br><span class="line">            st[tmp.second] = <span class="number">0</span>, st[x] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> cand.<span class="built_in">push</span>(<span class="built_in">mp</span>(a[x].x, x)), st[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st[x] == <span class="number">1</span>) -- siz, sum -= a[x].x;</span><br><span class="line">    vis[x] = <span class="number">1</span>, st[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cand.<span class="built_in">size</span>() &amp;&amp; siz &lt; k) &#123;</span><br><span class="line">        plli tmp = cand.<span class="built_in">top</span>(); cand.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[tmp.second]) <span class="keyword">continue</span>;</span><br><span class="line">        ++ siz, sum += tmp.first; st[tmp.second] = <span class="number">1</span>;</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">mp</span>(-tmp.first, tmp.second));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= T; ++ t) &#123;</span><br><span class="line">        <span class="built_in">read</span>(d); <span class="built_in">read</span>(n); <span class="built_in">read</span>(k); <span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="built_in">read</span>(a[i].x), <span class="built_in">read</span>(a[i].l), <span class="built_in">read</span>(a[i].r);</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i].id = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            qry[a[i].l].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(<span class="number">1</span>, i));</span><br><span class="line">            qry[a[i].r + <span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(<span class="number">-1</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k : qry[i])</span><br><span class="line">              <span class="keyword">if</span> (k.first == <span class="number">-1</span>) <span class="built_in">del</span>(k.second);</span><br><span class="line">              <span class="keyword">else</span> <span class="built_in">insert</span>(k.second);</span><br><span class="line">            ans = <span class="built_in">Max</span>(sum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>, t, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t2-游戏">#T2 游戏</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定有一个 <span class="math inline">\(2n(n\leq5\cdot10^5)\)</span> 个点的环，同时给定 <span class="math inline">\(n\)</span> 条额外的边（没有重复的端点），要求将整张图的所有点染为两种颜色，满足没有额外边两端颜色相同，在环上没有连续的三个人颜色相同。给出构造方案，若无可行的构造方案，输出 <code>impossible</code>。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>先来你考虑环上的约束条件，我们只需要保证 1 与 2 不同，3 与 4 不同……<span class="math inline">\(2n-1\)</span> 与 <span class="math inline">\(2n\)</span> 不同即可，于是我们只把 <span class="math inline">\(2i\)</span> 与 <span class="math inline">\(2i-1(1\leq i\leq n)\)</span> 相连即可，再考虑额外的 <span class="math inline">\(n\)</span> 条边，发现每次最多也只会加入 <span class="math inline">\(2\)</span> 个点，最终形成一个具有偶数个点的环，这样的图一定是一个二分图，所以直接黑白染色即可。时间复杂度 <span class="math inline">\(O(n)\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>), vis[N], col[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    col[x] = c, vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (!vis[e[i].v]) <span class="built_in">mark</span>(e[i].v, c ^ <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v); <span class="built_in">add_edge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">add_edge</span>((i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, i &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add_edge</span>(i &lt;&lt; <span class="number">1</span>, (i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (!vis[i]) <span class="built_in">mark</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (col[i]) <span class="built_in">putchar</span>(<span class="string">&#x27;X&#x27;</span>); <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t3-字符串">#T3 字符串</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>给定 <span class="math inline">\(n(n\leq100)\)</span> 个字符在字符串 <span class="math inline">\(S\)</span> 中的出现次数 <span class="math inline">\(a_i(a_i\leq10^9)\)</span>，要求将这些字符用 0/1 进行编码，每个字符编码的长度不超过 <span class="math inline">\(l(l\leq30)\)</span>，问 <span class="math inline">\(S\)</span> 在编码后的最小长度。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>因为编码长度有限制，所以直接用哈夫曼树是不行的（实际上因为数据过水可以过 QnQ），但是可以借鉴哈夫曼树的思想，使用<strong>二叉树</strong>进行编码。</p>
<p>设 <span class="math inline">\(f_{i,j,k}\)</span> 为当前处理了出现次数前 <span class="math inline">\(i\)</span> 大的字符，在二叉树的第 <span class="math inline">\(j\)</span> 层，还剩 <span class="math inline">\(k\)</span> 个结点可用时的最小长度和，容易发现具有转移： <span class="math display">\[
\begin{aligned}
f_{i,j,k}&amp;\to f_{i+1,j,k-1},\\
f_{i,j,k}&amp;\to f_{i,j+1,k\times2}.
\end{aligned}
\]</span> 然后直接转移即可，时间复杂度为 <span class="math inline">\(O(n^2l)\)</span>.</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line">ll n, l, a[N], ans, f[N][<span class="number">40</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(l);</span><br><span class="line">    <span class="keyword">while</span> (n || l) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;<span class="keyword">return</span> x &gt; y;&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp); <span class="built_in">mset</span>(f, <span class="number">0x3f</span>);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>] = f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>; ans = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">Min</span>(n, <span class="number">1ll</span> &lt;&lt; j); ++ k)</span><br><span class="line">              <span class="keyword">if</span> (f[i][j][k] &lt; INF) &#123;</span><br><span class="line">                  f[i + <span class="number">1</span>][j][k - <span class="number">1</span>] = <span class="built_in">Min</span>(f[i + <span class="number">1</span>][j][k - <span class="number">1</span>], f[i][j][k] + <span class="number">1ll</span> * a[i + <span class="number">1</span>] * j);</span><br><span class="line">                  f[i][j + <span class="number">1</span>][k * <span class="number">2</span>] = <span class="built_in">Min</span>(f[i][j + <span class="number">1</span>][k * <span class="number">2</span>], f[i][j][k]); </span><br><span class="line">              &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; ++ i)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">Min</span>(n, <span class="number">1ll</span> &lt;&lt; i); ++ j)</span><br><span class="line">            ans = <span class="built_in">Min</span>(ans, f[n][i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="built_in">read</span>(n), <span class="built_in">read</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t4-金色飞贼">#T4 金色飞贼</h2>
<p><del>巨大恶心的</del>计算几何，暂且咕着。</p>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「游记」21-CSP-S 游记</title>
    <url>/2021/10/24/21-CSP-S/</url>
    <content><![CDATA[<h2 id="day--1">DAY -1</h2>
<p>和 hyl,ceh 两位巨神中午一同出发，<del>睡了一路</del>，一路上风景不错，算是拍了几张照片，此时的 dyk 并没有意识到将要完大蛋的事实。</p>
<p>老父亲在济南就约了他在日照的同学吃饭，到了之后，简单收拾了下东西，就屁颠屁颠地跟着去蹭了吨饭，满桌子的生猛海鲜，吃得很是满足，期间三个人争着端茶倒水，原因不言而喻/xyx。ceh 似乎还顺了两口酒喝，一切都是那么安静祥和</p>
<p>回到酒店，原本说好要一起打模板的，结果不知怎么回事就唱起歌来了，然后就被人敲门了/kk，这似乎为第二天的悲剧埋下了伏笔。</p>
<p>嗨到 23:30，终于是各回各房睡大觉了。</p>
<h2 id="day-1">DAY 1</h2>
<h3 id="pre">PRE</h3>
<p>或许是在学校养成的习惯使然，到了 6:00 左右就死活睡不下去了（悲），于是就爬起来颓了亿会儿，七点多吃过早饭，回到房里再看看板子和去年的真题，结果发现 hyl 有一个面基群，于是就玩心大起加了进去，在里面线上线下同时听 hyl 开腔。</p>
<p>后来 hzh 来玩了一会儿，寒暄了几句，又离开了。</p>
<p>简单的在酒店吃了顿饭，睡了一觉，准备去考试。</p>
<p>提前好久来到了校门口，结果还要等着 J 他们一块拍张照，幸亏是没喊那个哈斯卡西的口号，要不然就真的要社死了/捂脸。下面是口号的全文： <span class="math display">\[
人生在勤，志达天下，\\
亮剑精神，信息之光，\\
脚踏实地，勇争第一。
\]</span> 当然其中有一个我们机房广为流传的梗/xyx</p>
<p>进场了，感觉自己周围都是大佬，试机时忽然想起原本想在车上复习复习 tarjan 和平衡树，却发现自己忘掉了/kk，应该问题不大...吧？</p>
<h3 id="p.m.-1435-p.m.">14:30 P.M. ~ 14:35 P.M.</h3>
<p>简单看了一遍题，发现 T4 没读懂，感觉还是顺序开题，不过对于 T3 的难度把握不准。</p>
<h3 id="p.m.-1530-p.m.">14:35 P.M. ~ 15:30 P.M.</h3>
<p>上来就被 T1 唬住了，只是直觉上觉得一定是个贪心，余光瞟到左右两边的人都早早的切换到了 T2，忽然脑中有力一点灵感，发现有一种分配方式在任何时候都是成立的，好像用堆就能维护，联想到不久前在 ZR 遇到了一个需要类似的方式的题，20min 写完，静态查错没有问题（事实证明存在问题/kk），样例一遍过，丢在一边吃灰去了。</p>
<h3 id="p.m.-1700-p.m.">15:30 P.M. ~ 17:00 P.M.</h3>
<p>T2 显然区间 DP，不会写暴力/哭唧唧，于是只能尝试写 <span class="math inline">\(O(n^4)\)</span> 的 DP，发现有个地方处理的有点麻烦，简单优化了一下，发现自己 <span class="math inline">\(O(n^3)\)</span> 了...</p>
<p>然鹅时间飞速，T2 有地方打挂了，样例过不去，<strong>不能在一棵树上吊死</strong>，于是决定先看看 T3。</p>
<h3 id="p.m.-1745-p.m.">17:00 P.M. ~ 17:45 P.M.</h3>
<p>看了看 T3，想（发呆）了很久，还是没有什么思路/kk，当机立断写个了 <span class="math inline">\(O(2^n)\)</span> 暴力滚粗。居然还能打挂了一次，代码能力真是令人堪忧啊/ll</p>
<p>简单看了一眼 T4，发现没有读懂题，于是决定回来调 T2。</p>
<h3 id="p.m.-1825-p.m.">17:45 P.M. ~ 18:25 P.M.</h3>
<p>又调了很久，期间因为读题/理解的缘故把很多细节该来该去，好歹算是两个样例都过了，没敢再去测大样例，想想自己还真是一个十足的懦夫呢（笑）</p>
<h3 id="p.m.-1830-p.m.">18:25 P.M. ~ 18:30 P.M.</h3>
<p>再检查了一下 <code>freopen</code> 和文件夹命名之类的小事，不想重蹈去年某学长 <code>freopen("julian3.in", "r", stdin);</code> 的覆辙/doge</p>
<h3 id="after">AFTER</h3>
<p>简单交流了一下，感觉自己的 T1 应当是切了，T2 没有什么底气，估计是挂掉了/kk</p>
<p>估分 100+0+28=128，wtcl/kk</p>
<p>回去的路上格外沉默呢，hyl T2 没写出来，ceh T1 假了，他们在看番，我在晕车/yun，感觉人都快没了/kk。终于 ceh 电脑没电了，于是我们开始愉快的（并不）唱歌，释放释放怨念。</p>
<h2 id="end">End</h2>
<blockquote>
<p>UPD on 10.26.21</p>
</blockquote>
<p>行，拿到选手程序了，在 luogu 上测了一下，T1 挂没了<span class="math inline">\(100pts\to 65pts\)</span>，现在就等官方分数了，心已经凉了（苦笑）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lacnt + <span class="number">1</span>; i &lt;= n; ++ i) numb[i] = numb[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>看到这个 <code>lacnt</code> 了么？他应该是 <code>lbcnt</code>...</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lbcnt + <span class="number">1</span>; i &lt;= n; ++ i) numb[i] = numb[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>我哭死</p>
<blockquote>
<p>UPD on 10.30.21</p>
</blockquote>
<p>彳亍，出成绩力，<span class="math inline">\(75+0+28+0=103\)</span>，怎么才能不考场降智啊/kk</p>
<blockquote>
<p><strong>我们所度过的每个平凡的日常 ，也许就是连续发生的奇迹。</strong>——《日常》</p>
</blockquote>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP冲刺-TEST4 总结</title>
    <url>/2021/10/20/ZROI-21-NOIP-SP-TEST4/</url>
    <content><![CDATA[<h2 id="t1-序列变换">#T1 序列变换</h2>
<blockquote>
<p>Time Limit: 1s Memory: 256MiB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>给定两个长度为 <span class="math inline">\(n(n\leq3\times10^5)\)</span> 的序列 <span class="math inline">\(a_i,b_i(1\leq a_i,b_i\leq10^9)\)</span>，定义两个序列的距离为： <span class="math display">\[
d(a,b)=\sum\limits_{i=1}^n(a_i-b_i)^2
\]</span> 你可以任意选择 <span class="math inline">\(a_i\)</span> 中两个数交换位置，求最小代价，对 <span class="math inline">\(998244353\)</span> 取模，<span class="math inline">\(T=1\)</span> 时给出最小代价所需步数。</p>
<h3 id="大体思路">#大体思路</h3>
<p><span class="math display">\[
\begin{aligned}
d(a,b)&amp;=\sum\limits_{i=1}^n(a_i-b_i)^2=\sum\limits_{i=1}^n(a_i^2-2a_ib_i+b_i^2)\\
&amp;=\sum\limits_{i=1}^na_i^2+\sum\limits_{i=1}^nb_i^2-2\sum\limits_{i=1}^na_ib_i,
\end{aligned}
\]</span></p>
<p>于是我们需要做的就是让 <span class="math inline">\(\sum_{i=1}^na_ib_i\)</span> 尽可能大，根据<strong>排序不等式</strong>可知，将 <span class="math inline">\(a_i,b_i\)</span> 都顺序/逆序排序后一一对应得到的答案最大。</p>
<p>我们可以得到变换后 <span class="math inline">\(a_i\)</span> 对应的 <span class="math inline">\(b_i\)</span> 的位置，他们会形成 <span class="math inline">\(k\)</span> 个环，显然我们的最优交换策略是按环交换，每个环需要交换 <span class="math inline">\(k-1\)</span> 次，于是总交换次数是 <span class="math inline">\(n-k\)</span> 次。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, T; ll ans, a[N], b[N], ta[N], tb[N], tot;</span><br><span class="line">ll sma, smb, sum, posa[N], posb[N], vis[N], vpos[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(t, len, x) lower_bound(t + 1, t + len + 1, x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">read</span>(a[i]), (sma += a[i] * a[i] % MOD) %= MOD, ta[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">read</span>(b[i]), (smb += b[i] * b[i] % MOD) %= MOD, tb[i] = b[i];</span><br><span class="line">    <span class="built_in">sort</span>(ta + <span class="number">1</span>, ta + n + <span class="number">1</span>); <span class="built_in">sort</span>(tb + <span class="number">1</span>, tb + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      (sum += ta[i] * tb[i] % MOD) %= MOD;</span><br><span class="line">    ans = ((sma + smb) % MOD - <span class="number">2</span> * sum % MOD + MOD) % MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans); <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) posa[i] = <span class="built_in">lb</span>(ta, n, a[i]) - ta;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) posb[i] = <span class="built_in">lb</span>(tb, n, b[i]) - tb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) vpos[posb[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) posa[i] = vpos[posa[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>; <span class="keyword">int</span> now = i; ++ tot;</span><br><span class="line">        <span class="keyword">while</span> (!vis[now]) &#123;vis[now] = <span class="number">1</span>, now = posa[now];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, n - tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t2-下象棋">#T2 下象棋</h2>
<blockquote>
<p>Time Limit: 3s Memory Limit: 256MiB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>一个 <span class="math inline">\(n\times n(n\leq10^6)\)</span> 的棋盘，上面放置了 <span class="math inline">\(m(m\leq10^6)\)</span> 个棋子，每个棋子的个攻击范围为所在的两条斜率为 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(-1\)</span> 的斜线，问当前棋盘上有多少点不会被攻击到。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>一个棋子对应了斜率为 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(-1\)</span> 的两条斜线，这样的斜线的个数是 <span class="math inline">\(O(n)\)</span> 级别的，每个斜率为 <span class="math inline">\(-1\)</span> 的斜线都与一个奇偶性确定的斜率为 <span class="math inline">\(1\)</span> 的斜线区间相交，于是我们可以对斜率为 <span class="math inline">\(-1\)</span> 的直线进行标记，斜率为 <span class="math inline">\(1\)</span> 的直线用奇偶分组前缀和处理。时间复杂度 <span class="math inline">\(O(n)\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> zx[N &lt;&lt; <span class="number">1</span>], fx[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">ll even[N &lt;&lt; <span class="number">1</span>], odd[N &lt;&lt; <span class="number">1</span>], n, m, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">len</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Min</span>(x, <span class="number">2</span> * n - x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m); ans = n * n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        ll x, y; <span class="built_in">read</span>(x), <span class="built_in">read</span>(y); </span><br><span class="line">        zx[y - x + n] = <span class="number">1</span>, fx[<span class="number">2</span> * n - x - y + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &lt;&lt; <span class="number">1</span>; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (i &amp; <span class="number">1</span>) odd[i] = odd[i - <span class="number">1</span>] + zx[i];</span><br><span class="line">      <span class="keyword">else</span> odd[i] = odd[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &lt;&lt; <span class="number">1</span>; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) even[i] = even[i - <span class="number">1</span>] + zx[i];</span><br><span class="line">      <span class="keyword">else</span> even[i] = even[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &lt;&lt; <span class="number">1</span>; ++ i) ans -= zx[i] * <span class="built_in">len</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &lt;&lt; <span class="number">1</span>; ++ i) ans -= fx[i] * <span class="built_in">len</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &lt;&lt; <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fx[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) ans += odd[n + <span class="built_in">len</span>(i) - <span class="number">1</span>] - odd[n - <span class="built_in">len</span>(i)];</span><br><span class="line">            <span class="keyword">else</span> ans += even[n + <span class="built_in">len</span>(i) - <span class="number">1</span>] - even[n - <span class="built_in">len</span>(i)];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) ans += odd[n + <span class="built_in">len</span>(i) - <span class="number">1</span>] - odd[n - <span class="built_in">len</span>(i)];</span><br><span class="line">            <span class="keyword">else</span> ans += even[n + <span class="built_in">len</span>(i) - <span class="number">1</span>] - even[n - <span class="built_in">len</span>(i)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-外星病毒">#T3 外星病毒</h2>
<blockquote>
<p>Time Limit: 1s Memory Limit: 256MiB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p>一张 <span class="math inline">\(n(n\leq10^5)\)</span> 个点 <span class="math inline">\(n\)</span> 条边的有向图，每个点 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(p_i\)</span> 的概率变为黑点，同时在变为黑点后有 <span class="math inline">\(q_i\)</span> 的概率将自己的出边所指向的点变为黑点，问每个点变为黑点的概率，对 <span class="math inline">\(998244353\)</span> 取模。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>显然这是一个基环森林，且每个基环树都是内向树，考虑基环树上的 DP；</p>
<p>先不考虑环的影响，对于一棵树，设第 <span class="math inline">\(i\)</span> 个点被染成黑色的概率是 <span class="math display">\[
f_i=p_i+(1-p_i)(1-\prod\limits_{j\in ch_i}(1-f_jq_j)),
\]</span> 其中 <span class="math inline">\(\prod_{j\in ch_i}(1-f_jq_j)\)</span> 是子树里一个也没传上来的概率，<span class="math inline">\((1-\prod_{j\in ch_j}(1-f_jq_j))\)</span> 则是存在至少一个被染黑并传上来的概率。</p>
<p>现在再来考虑在环上的点被染黑的概率，环上某个点的 <span class="math inline">\(f\)</span> 就是它被环外的点感染的概率，<span class="math inline">\(q_i\)</span> 表示 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(i+1\)</span> 的有向边存在的概率，设 <span class="math inline">\(g_i\)</span> 表示 <span class="math inline">\(i\)</span> 在环上被染黑的概率，先经典操作断环为链。</p>
<p>考虑边的存在情况，设 <span class="math inline">\(i\)</span> 前面第一条不存在的边是 <span class="math inline">\(j-1\)</span> 到 <span class="math inline">\(j\)</span> 的边，在这种情况下，<span class="math inline">\(j\)</span> 到 <span class="math inline">\(i-1\)</span> 中只要有一个被染黑，<span class="math inline">\(i\)</span> 就会被染黑，于是这部分的贡献是 <span class="math display">\[
\sum\limits_{j=i-n+1}^i\left(\left(1-\prod_{k=j}^{i}(1-f_k)\right)\left(\prod\limits_{k=j}^{i-1}q_k\right)(1-q_{j-1})\right)
\]</span></p>
<blockquote>
<p>最初不理解这里为什么是 <span class="math inline">\(\prod_{k=j}^{i-1}q_k\)</span>，即明明最前面的点可能没有被染黑，为什么需要所有边都存在，这样不会导致得到的概率改变么？实际上因为我们枚举了前面所有边的存在性，对于一个点 <span class="math inline">\(k\)</span> 作为最左边黑色的点，它前面的第一条被断开的边的概率被分开考虑了，也就是说我们把状态细化了，根据全概率公式，最终加起来得到的概率依然是正确的概率。不过注意到，我们这样依旧会缺少状态，即前面没有边被断开，这也就是为什么要考虑下面的式子。下面式子中的 <span class="math inline">\(\prod_{k=i-n+1}^{i-1}q_k\)</span> 也是同样的原因。</p>
</blockquote>
<p>如果环上的边全部存在的话，那么只要有任意一个点被染黑，点 <span class="math inline">\(i\)</span> 一定会被染黑，于是有贡献 <span class="math display">\[
\left(1-\prod\limits_{k=i-n+1}^i(1-f_k)\right)\left(\prod\limits_{k=i-n+1}^{i-1}q_k\right)
\]</span> 通过一系列过程，可以得到环上的一个点 <span class="math inline">\(i\)</span> 的完整的概率。于是只需要考虑 <span class="math inline">\(O(1)\)</span> 维护 <span class="math inline">\(\sum_{j=i-n+1}^i\left(\prod_{k=j}^i(1-f_k)\right)\)</span> 和 <span class="math inline">\(\sum_{j=i-n+1}^i\left((\prod_{k=j}^{i-1}q_k)(1-q_{j-1})\right)\)</span> 即可。</p>
<hr />
<p>以上是题解的做法，下面是我贺的神虎的做法。</p>
<p>考虑对于环上的一个点，显然当环上没有一个点被染黑时这个点一定不会被染黑，而这种情况的概率是 <span class="math inline">\(\prod_{i=1}^n(1-f_i)\)</span>，于是除去这种情况的总概率是 <span class="math display">\[
1-\prod\limits_{i=1}^n(1-f_i)
\]</span> 对于点 <span class="math inline">\(i\)</span>，我们考虑枚举最靠近它的黑点，这个总概率是 <span class="math display">\[
\sum\limits_{j=i-n+1}^{i-1}\left(f_j\cdot\prod\limits_{k=j+1}^{i}(1-f_k)\right)+f_i,
\]</span> 但是在这所有的情况中，显然只有最近的点 <span class="math inline">\(j\)</span> 到 <span class="math inline">\(i\)</span> 的路径上的所有边都存在时才有可能将 <span class="math inline">\(i\)</span> 染为黑色，于是这种情况的概率是 <span class="math display">\[
\sum\limits_{j=i-n+1}^{i-1}\left(f_jq_j\cdot\prod\limits_{k=j+1}^{i}q_{k-1}(1-f_k)\right)+f_i,
\]</span> 于是对于点 <span class="math inline">\(i\)</span> 的答案就是 <span class="math display">\[
1-\sum\limits_{j=i-n+1}^{i-1}\left(f_j\cdot\prod\limits_{k=j+1}^{i}(1-f_k)\right)-f_i+\sum\limits_{j=i-n+1}^{i-1}\left(f_jq_j\cdot\prod\limits_{k=j+1}^{i}q_{k-1}(1-f_k)\right)+f_i-\prod\limits_{i=1}^n(1-f_i)
\]</span></p>
<hr />
<p>本来<del>贺</del>写到这就结束了，但是突然意识到 <span class="math display">\[
\sum\limits_{j=i-n+1}^{i-1}\left(f_jq_j\cdot\prod\limits_{k=j+1}^{i}q_{k-1}(1-f_k)\right)+f_i,
\]</span> 就是环上的答案，不需要额外多算其他的部分。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, fa[N], t[N], vis[N], lst[N], inc[N];</span><br><span class="line">ll p[N], q[N], f[N], part1[N], g[N], m[N];</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; trees[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) (res *= x) %= MOD;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>, (x *= x) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span> (x != fa[x]) x = fa[x] = fa[fa[x]]; <span class="keyword">return</span> x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> que[N], frt, tal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector &lt;<span class="keyword">int</span>&gt; &amp;tree)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*Get the ring on the tree.*/</span></span><br><span class="line">    <span class="keyword">int</span> now = tree[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (!vis[now]) vis[now] = <span class="literal">true</span>, now = t[now];</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; <span class="built_in">ring</span>(<span class="number">0</span>); <span class="keyword">int</span> nnow = now;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ring.<span class="built_in">push_back</span>(nnow);</span><br><span class="line">        inc[nnow] = <span class="literal">true</span>; nnow = t[nnow];</span><br><span class="line">    &#125; <span class="keyword">while</span> (nnow != now);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ring.<span class="built_in">size</span>(); ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = (i + <span class="number">1</span>) % ring.<span class="built_in">size</span>();</span><br><span class="line">        lst[ring[j]] = ring[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Use queue to run DP on the tree.*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : tree) vis[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : tree) ++ vis[t[u]];</span><br><span class="line">    frt = <span class="number">0</span>; tal = <span class="number">-1</span>; <span class="keyword">for</span> (<span class="keyword">auto</span> u : tree) f[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : tree) <span class="keyword">if</span> (!vis[u]) que[++ tal] = u;</span><br><span class="line">    <span class="keyword">while</span> (frt &lt;= tal) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que[frt ++];</span><br><span class="line">        <span class="keyword">if</span> (!inc[t[x]] &amp;&amp; !(-- vis[t[x]])) que[++ tal] = t[x];</span><br><span class="line">        f[x] = f[x] * (MOD + <span class="number">1</span> - p[x]) % MOD;</span><br><span class="line">        f[x] = (MOD + <span class="number">1</span> - f[x]) % MOD;</span><br><span class="line">        (f[t[x]] *= (MOD + <span class="number">1</span> - q[x] * f[x] % MOD)) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : ring) &#123;</span><br><span class="line">        f[u] = f[u] * (MOD + <span class="number">1</span> - p[u]) % MOD;</span><br><span class="line">        (f[u] = MOD + <span class="number">1</span> - f[u]) %= MOD;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/*Calculate the answers on the ring.*/</span></span><br><span class="line">    ll M = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : ring) &#123;</span><br><span class="line">        m[u] = (MOD + <span class="number">1</span> - f[u]) * q[lst[u]] % MOD,</span><br><span class="line">        (M *= m[u]) %= MOD;</span><br><span class="line">    &#125;	</span><br><span class="line">    now = ring[<span class="number">0</span>]; ll ans0 = <span class="number">0</span>, tim = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        (ans0 += tim * f[now]) %= MOD;</span><br><span class="line">        tim = tim * m[now] % MOD; now = lst[now];</span><br><span class="line">    &#125; <span class="keyword">while</span>(now != ring[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : ring) &#123;</span><br><span class="line">        g[u] = ans0; ans0 = ans0 * m[t[u]] % MOD;</span><br><span class="line">        ans0 = ans0 - M * f[t[u]] + f[t[u]];</span><br><span class="line">        ans0 = ((ans0 % MOD) + MOD) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : ring) f[u] = g[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a), <span class="built_in">read</span>(b);</span><br><span class="line">        p[i] = <span class="number">1ll</span> * a * <span class="built_in">fpow</span>(b, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(t[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a), <span class="built_in">read</span>(b);</span><br><span class="line">        q[i] = <span class="number">1ll</span> * a * <span class="built_in">fpow</span>(b, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">find</span>(i) != <span class="built_in">find</span>(t[i]))</span><br><span class="line">        fa[fa[i]] = fa[t[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      trees[<span class="built_in">find</span>(i)].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (trees[i].<span class="built_in">size</span>()) <span class="built_in">solve</span>(trees[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-删边方案">#T4 删边方案</h2>
<blockquote>
<p>Time Limit: 5s Memory Limit: 256MiB</p>
</blockquote>
<h3 id="题意简述-3">#题意简述</h3>
<p>给定一张 <span class="math inline">\(n(\leq18)\)</span> 个点 <span class="math inline">\(m(m\leq n(n-1))\)</span> 条边的有向图，问有多少种不同的删边方案得到的图依旧存在环。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>直接计算答案比较困难，考虑补集转化，我们求删边后得到 DAG（有向无环图）的方案数。</p>
<p>设 <span class="math inline">\(f_S\)</span> 表示点集 <span class="math inline">\(S\)</span> 删边得到 DAG 的方案数，直接计算依旧存在难度，考虑容斥。设 <span class="math inline">\(q_T\)</span> 为我们令 <span class="math inline">\(S\)</span> 的子集 <span class="math inline">\(T\)</span> 中的点的入度都是 <span class="math inline">\(0\)</span> ，<span class="math inline">\(S\)</span> 中可能存在其他入度为 <span class="math inline">\(0\)</span> 的点的方案数，考虑到 <span class="math inline">\(T\to S-T\)</span> 的边可以连也可以不连， <span class="math inline">\(S-T\to T\)</span> 的边一定不连，于是有： <span class="math display">\[
q_T=2^{ways(T,S-T)}\times f_{S-T},
\]</span> 我们设 <span class="math inline">\(p_T\)</span> 为仅有 <span class="math inline">\(T(T\subseteq S)\)</span> 中的点是入度为 <span class="math inline">\(0\)</span> 的点时的方案数，显然有： <span class="math display">\[
q_T=\sum\limits_{T\subseteq R\subseteq S}p_R
\]</span> 于是根据二项式反演的集合形式有 <span class="math display">\[
p_T=\sum\limits_{T\subseteq R\subseteq S}(-1)^{|R|-|T|}q_R,
\]</span> 于是我们所求的答案便是 <span class="math display">\[
\begin{aligned}
f_S&amp;=\sum\limits_{T\subseteq S,T\ne\varnothing}p_T=\sum\limits_{T\subseteq S,T\ne\varnothing}\sum\limits_{T\subseteq R\subseteq S}(-1)^{|R|-|T|}q_R\\
&amp;=\sum\limits_{R\subseteq S,R\ne\varnothing}q_R\sum\limits_{T\subseteq R,T\ne\varnothing}(-1)^{|R|-|T|}\\
&amp;=\sum\limits_{R\subseteq S,R\ne\varnothing}q_R\sum\limits_{k=1}^{|R|}(-1)^{|R|-k}\dbinom{|R|}{k}\\
&amp;=\sum\limits_{R\subseteq S,R\ne\varnothing}q_R\sum\limits_{k=1}^{|R|-1}(-1)^{k}\dbinom{|R|}{k}\\
&amp;=\sum\limits_{R\subseteq S,R\ne\varnothing}q_R\left(\sum\limits_{k=1}^{|R|}(-1)^{k}\dbinom{|R|}{k}-(-1)^{|R|}\right)\\
\end{aligned}
\]</span> 我们知道有这样一条定理（证明见<a href="#sup-prove">补充证明</a>）： <span class="math display">\[
\sum\limits_{k=1}^{|S|}(-1)^{k}\dbinom{|S|}{k}=[S=\varnothing],
\]</span> 于是我们可以得到 <span class="math inline">\(f\)</span> 的转移 <span class="math display">\[
\begin{aligned}
f_S&amp;=\sum\limits_{R\subseteq S,R\ne\varnothing}q_R\left(\sum\limits_{k=1}^{|R|}(-1)^{k}\dbinom{|R|}{k}-(-1)^{|R|}\right)\\
&amp;=\sum\limits_{T\subseteq S,T\ne\varnothing}(-1)^{|T|-1}q_T\\
&amp;=\sum\limits_{T\subseteq S,T\ne\varnothing}(-1)^{|T|-1}2^{ways(T,S-T)}\times f_{S-T},
\end{aligned}
\]</span> <span class="math inline">\(ways(T,S-T)\)</span> 可以通过 <span class="math inline">\(ways(T-lowbit(T))\)</span> 进行 <span class="math inline">\(O(1)\)</span> 转移，然后直接干就完了。时间复杂度 <span class="math inline">\(O(3^n)\)</span>.</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, u, v, e[<span class="number">20</span>], re[<span class="number">20</span>]; ll pw[<span class="number">310</span>], f[N], num[N], lb[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(m); pw[<span class="number">0</span>] = <span class="number">1</span>; f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) pw[i] = (pw[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++ i) cnt[i] = cnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++ i) lb[i] = (i &amp; <span class="number">1</span> ? <span class="number">1</span> : lb[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), e[u] |= (<span class="number">1</span> &lt;&lt; v - <span class="number">1</span>), re[v] |= (<span class="number">1</span> &lt;&lt; u - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = (i - <span class="number">1</span> &amp; i), j = i - t; ; t = (t - <span class="number">1</span> &amp; i), j = i - t) &#123;</span><br><span class="line">            num[j] = num[j - (j &amp; -j)] - cnt[re[lb[j]] &amp; j] + cnt[e[lb[j]] &amp; i - j];</span><br><span class="line">            (f[i] += ((cnt[j] &amp; <span class="number">1</span> ? <span class="number">1</span> : MOD - <span class="number">1</span>) * pw[num[j]]) % MOD * f[i - j]) %= MOD;</span><br><span class="line">            <span class="keyword">if</span> (!t) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (pw[m] - f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] + MOD) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div id="sup-prove">

</div>
<h2 id="补充证明">#补充证明</h2>
<h3 id="part.-1">#Part. 1</h3>
<p>我们要求的结论： <span class="math display">\[
\sum\limits_{k=1}^{|S|}(-1)^{k}\dbinom{|S|}{k}=[S=\varnothing],
\]</span> <strong>证明：</strong>考虑这样一个问题：从 <span class="math inline">\([n]\)</span> 到 <span class="math inline">\(\{y_1,y_2,\dots,y_k\}\)</span> 的满射有多少个？</p>
<p>设 <span class="math inline">\(S\)</span> 为所有 <span class="math inline">\([n]\)</span> 到 <span class="math inline">\(\{y_1,y_2,\dots,y_k\}\)</span> 的映射的集合，则 <span class="math inline">\(|S|=k^n\)</span>，定义性质 <span class="math inline">\(P_i\)</span> 表示“<span class="math inline">\(y_i\)</span> 不是映射的像”，<span class="math inline">\(A_i\)</span> 为满足性质 <span class="math inline">\(P_i(1\leq i\leq k)\)</span> 的所有从 <span class="math inline">\([n]\)</span> 到 <span class="math inline">\(\{y_1,y_2,\dots,y_k\}\)</span> 的集合，显然对于任意 <span class="math inline">\(1\leq i\leq k\)</span> 有 <span class="math display">\[
|A_i|=(k-1)^n,
\]</span> 同样的，对于任意 <span class="math inline">\(1\leq i_1&lt;i_2&lt;\cdots&lt;i_j\leq k\)</span> 有 <span class="math display">\[
|A_{i_1}\cap\cdots\cap A_{i_j}|=(k-j)^n,
\]</span> 于是，根据容斥原理所求满设的个数为 <span class="math display">\[
\begin{aligned}
&amp;|\overline{A_1}\cap\overline{A_2}\cap\cdots\cap\overline{A_k}|\\
=&amp;|S|-\sum_i|A_i|+\sum_{i&lt;j}|A_i\cap A_j|-\cdots+(-1)^k|A_1\cap\cdots\cap A_k|\\
=&amp;\sum_{j=0}^k(-1)^j\dbinom{k}{j}(k-j)^n=\sum_{j=0}^k(-1)^{k-j}\dbinom{k}{j}j^n,
\end{aligned}
\]</span> 再考虑原题的组合意义，可以知道，若 <span class="math inline">\(k&gt;n\)</span>，则一定不存在满射，若 <span class="math inline">\(k=n\)</span>，则满射的个数是 <span class="math inline">\(n!=k!\)</span>，于是有 <span class="math display">\[
\sum_{j=0}^k(-1)^{k-j}\dbinom{k}{j}j^n=\begin{cases}0,&amp;k&gt;n,\\n!,&amp;k=n.\end{cases}
\]</span> 上式中 <span class="math inline">\(n=0\)</span> 时即得所求结论（定义 <span class="math inline">\(0!=1\)</span>）。</p>
<div data-align="right">
证毕.
</div>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-CSP7连-DAY7 总结</title>
    <url>/2021/10/17/ZROI-21-CSP-DAY7/</url>
    <content><![CDATA[<h2 id="t1-字符串">#T1 字符串</h2>
<blockquote>
<p>Time Limit: 1s Memory Limit: 512MB</p>
</blockquote>
<h3 id="题意简述">#题意简述</h3>
<p>给定长度为 <span class="math inline">\(n(n\leq10^4)\)</span> 的字符串 <span class="math inline">\(A_0\)</span> 和长度为 <span class="math inline">\(m(m\leq10^4)\)</span> 的字符串 <span class="math inline">\(B_0\)</span>，它们都只包含大小写字母。</p>
<p>对于任意整数 <span class="math inline">\(i\geq1\)</span>，令 <span class="math inline">\(A_i\)</span> 是由 <span class="math inline">\(A_{i−1}\)</span> 与 <span class="math inline">\(B_{i−1}\)</span> 拼接而成的字符串，<span class="math inline">\(B_i\)</span> 是由 <span class="math inline">\(B_{i−1}\)</span> 与 <span class="math inline">\(A_{i−1}\)</span> 拼接而成的字符串。</p>
<p>有 <span class="math inline">\(T(T\leq10^4)\)</span> 个询问，每个询问给定 <span class="math inline">\(x(x\leq10^{15})\)</span>，你需要输出 <span class="math inline">\(A_{935}\)</span> 中的第 <span class="math inline">\(x\)</span> 个字符是什么。</p>
<h3 id="大体思路">#大体思路</h3>
<p>因为 <span class="math inline">\(2^{50}&gt;10^{15}\)</span>，而且不难发现 <span class="math inline">\(A_i\)</span>/<span class="math inline">\(B_i\)</span> 的长度是 <span class="math inline">\(2^{i-1}(n+m)\)</span>，所以我们可以提前预处理出来所有层的长度。可以发现如果当前的 <span class="math inline">\(x\)</span> 在当前层的 <span class="math inline">\(k\)</span> 串（<span class="math inline">\(0\)</span> 是 <span class="math inline">\(A\)</span>，<span class="math inline">\(1\)</span> 是 <span class="math inline">\(B\)</span>），且大于一半的长度，那么在上一层一定是在 <span class="math inline">\(k\text{ xor }1\)</span> 串，且 <span class="math inline">\(x\)</span> 减去对应的长度，否则一切不变。</p>
<p>按以上思路硬干就完了，时间复杂度 <span class="math inline">\(O(935\cdot T)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> ll LIMIT = <span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, T, sum; ll len[N];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; ++ i) &#123;</span><br><span class="line">        len[i] = <span class="number">1ll</span> &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (len[i] &gt; LIMIT) len[i] = LIMIT + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (LIMIT / sum &lt; len[i]) len[i] = LIMIT + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> len[i] = len[i] * sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">51</span>; i &lt;= <span class="number">935</span>; ++ i) len[i] = LIMIT + <span class="number">1</span>;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(T); sum = n + m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s[<span class="number">0</span>] + <span class="number">1</span>, s[<span class="number">1</span>] + <span class="number">1</span>); <span class="built_in">prework</span>();</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        ll x; <span class="built_in">read</span>(x); <span class="keyword">int</span> op = <span class="number">0</span>, now = <span class="number">935</span>;</span><br><span class="line">        <span class="keyword">while</span> (now &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; len[now - <span class="number">1</span>])</span><br><span class="line">              op ^= <span class="number">1</span>, x -= len[now - <span class="number">1</span>];</span><br><span class="line">            now --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;<span class="keyword">if</span> (x &gt; m) x -= m, op ^= <span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="keyword">if</span> (x &gt; n) x -= n, op ^= <span class="number">1</span>;&#125;</span><br><span class="line">        <span class="built_in">putchar</span>(s[op][x]); <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-区间">#T2 区间</h2>
<blockquote>
<p>Time Limit: 1s Memory Limit: 512MB</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>现在有 <span class="math inline">\(n(n\leq10^5)\)</span> 个区间，分别是 <span class="math inline">\([l_1,r_1],[l_2,r_2],\cdots,[l_n,r_n]\)</span>，保证 <span class="math inline">\(1\leq l_i&lt;r_i\leq10^{13}\)</span>。</p>
<p>现在要对区间进行操作，每次操作都可以选择一个整数 <span class="math inline">\(x\)</span> 作为操作基准，这个操作对所有满足 <span class="math inline">\(l_i&lt;x&lt;r_i\)</span> 的区间生效。</p>
<p>在这个操作以后，区间 <span class="math inline">\([l_i,r_i]\)</span> 会变成 <span class="math inline">\([l_i,x]\)</span> 和 <span class="math inline">\([x,r_i]\)</span> 。</p>
<p>你可以进行 <span class="math inline">\(m(m\leq10^{18})\)</span> 次这样的操作，要求在操作以后，区间的数量尽可能的多，你需要给出最多可能的区间数量。多组数据 <span class="math inline">\(T\leq100\)</span>.</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>显然，产生贡献的情况可以在离散化以后，分成一块一块的。 对于区间所有的左右端点离散以后，一个区间一个区间中的贡献都是相同的，其中端点处的贡 献需要单独考虑，端点出的贡献要去掉包含的区间。 这样就可以用左右端点标记的方式，从前往后扫直接处理出每一个区间的贡献，记录下来以后 排序，从高到低依次去考虑操作就可以。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, x;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> : l(l), r(r), x(x) &#123;</span> &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x &gt; b.x;&#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, tal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, lst = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : Map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now == <span class="number">0</span>) &#123;</span><br><span class="line">            now = p.second; lst = p.first;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[++ tal] = <span class="built_in">Node</span>(lst, p.first - <span class="number">1</span>, now);</span><br><span class="line">        lst = p.first; now += p.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + tal + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tal; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = a[i].r - a[i].l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; m) &#123;ans += m * a[i].x; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;ans += len * a[i].x; m -= len;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(n); <span class="built_in">read</span>(m); Map.<span class="built_in">clear</span>(); tal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r; <span class="built_in">read</span>(l); <span class="built_in">read</span>(r);</span><br><span class="line">            <span class="keyword">if</span> (r == l + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ++ Map[l + <span class="number">1</span>]; -- Map[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%lld: %lld\n&quot;</span>, i, <span class="built_in">Solve</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-构树">#T3 构树</h2>
<blockquote>
<p>Time Limit: 1s Memory Limit: 512MB</p>
</blockquote>
<h3 id="题意简述-2">#题意简述</h3>
<p>给定整数 <span class="math inline">\(n(n\leq800)\)</span>，设 <span class="math inline">\(M=\dfrac{n(n−1)}2\)</span>，显然 <span class="math inline">\(n\)</span> 个点的完全图包含 <span class="math inline">\(M\)</span> 条边。</p>
<p>现给定一个包含 <span class="math inline">\(n\)</span> 个点的树 <span class="math inline">\(T\)</span>，点编号为 <span class="math inline">\(1,\dots,n\)</span> 边有边权，保证边权是 <span class="math inline">\([1,M]\)</span> 中互不相同的整数。</p>
<p>你需要在树的基础上添加 <span class="math inline">\(M−n+1\)</span> 条边，形成一个边有权值的完全图 <span class="math inline">\(G\)</span>，并且满足：</p>
<ul>
<li><span class="math inline">\(T\)</span> 是 <span class="math inline">\(G\)</span> 的一棵最小生成树；</li>
<li><span class="math inline">\(G\)</span> 中所有边的边权是 <span class="math inline">\([1,M]\)</span> 中互不相同的整数。</li>
</ul>
<p>请你首先求出符合条件的 <span class="math inline">\(G\)</span> 的数量，答案对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p>此外，如果存在符合条件的 <span class="math inline">\(G\)</span>，则你需要再构造出一种这样的 <span class="math inline">\(G\)</span>。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>首先不难发现，当我们将给定的边按边权从小到大逐条加入最初边集为空的图时，显然我们考虑一条按边权从小到大额外加入的边，它必然不应能将当前图中的任意连通块相连，否则给定的树一定不是最小生成树，所以当前权值的额外边只能在连通块内部进行连接，每条边的方案数可以用并查集进行维护，然后求积即可，时间复杂度为 <span class="math inline">\(O(n^2)\)</span>.</p>
<p>下面来考虑构造。考虑最小生成树的性质，对于两个点 <span class="math inline">\(u,v\)</span>，<span class="math inline">\(V(u,v)\)</span> 表示它们在最小生成树 <span class="math inline">\(T\)</span> 上简单路径上的最大边权，<span class="math inline">\(w(u,v)\)</span> 表示完全图 <span class="math inline">\(G\)</span> 中边 <span class="math inline">\((u,v)\)</span> 的边权，那么显然应当有 <span class="math inline">\(V(u,v)\leq w(u,v)\)</span>，否则一定可以将对应的最大的边换成边 <span class="math inline">\((u,v)\)</span>，与 <span class="math inline">\(T\)</span> 是最小生成树矛盾。于是我们可以用树上倍增在 <span class="math inline">\(\log\)</span> 的时间复杂度内得到任意一条边的最小边权限制，按此限制进行排序，依次赋值即可。时间复杂度 <span class="math inline">\(O(n^2\log n)\)</span>.</p>
<blockquote>
<p>PS: 本题 std 可以做到 <span class="math inline">\(O(n^2)\)</span>，以上思路及 Code 是本人在赛时想到的 sb 做法。</p>
</blockquote>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">810</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500000</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> w &lt; b.w;&#125;</span><br><span class="line">&#125; e[N], ne[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TEdge</span> &#123;</span><span class="keyword">int</span> u, v, w, nxt;&#125; te[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, fa[N], siz[N], nowans, c[N][N], ncnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ecnt</span><span class="params">(<span class="number">1</span>)</span>, head[N], dep[N], f[21][N], mx[21][N]</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span> (x != fa[x]) x = fa[x] = fa[fa[x]]; <span class="keyword">return</span> x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">    ll tmp = siz[u] * (siz[u] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    tmp += siz[v] * (siz[v] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (siz[u] &gt; siz[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    fa[u] = v; siz[v] += siz[u]; nowans -= tmp;</span><br><span class="line">    nowans += siz[v] * (siz[v] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    te[ecnt].u = u, te[ecnt].v = v, te[ecnt].w = w;</span><br><span class="line">    te[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][x] = fa, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++ i)</span><br><span class="line">      f[i][x] = f[i - <span class="number">1</span>][f[i - <span class="number">1</span>][x]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++ i)</span><br><span class="line">      mx[i][x] = <span class="built_in">Max</span>(mx[i - <span class="number">1</span>][x], mx[i - <span class="number">1</span>][f[i - <span class="number">1</span>][x]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = te[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (te[i].v != fa) &#123;</span><br><span class="line">          mx[<span class="number">0</span>][te[i].v] = te[i].w; <span class="built_in">dfs</span>(te[i].v, x);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_limit</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; ~i; -- i)</span><br><span class="line">      <span class="keyword">if</span> (dep[f[i][u]] &gt;= dep[v])</span><br><span class="line">        res = <span class="built_in">Max</span>(res, mx[i][u]), u = f[i][u];</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; ~i; -- i)</span><br><span class="line">      <span class="keyword">if</span> (f[i][u] != f[i][v]) &#123;</span><br><span class="line">          res = <span class="built_in">Max</span>(res, mx[i][u]), u = f[i][u];</span><br><span class="line">          res = <span class="built_in">Max</span>(res, mx[i][v]), v = f[i][v];</span><br><span class="line">      &#125;</span><br><span class="line">    res = <span class="built_in">Max</span>(res, <span class="built_in">Max</span>(mx[<span class="number">0</span>][u], mx[<span class="number">0</span>][v]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); m = (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(e[i].u), <span class="built_in">read</span>(e[i].v), <span class="built_in">read</span>(e[i].w);</span><br><span class="line">        <span class="built_in">add_edge</span>(e[i].u, e[i].v, e[i].w);</span><br><span class="line">        <span class="built_in">add_edge</span>(e[i].v, e[i].u, e[i].w);</span><br><span class="line">        c[e[i].u][e[i].v] = e[i].w;</span><br><span class="line">        c[e[i].v][e[i].u] = e[i].w;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">sort</span>(e + <span class="number">1</span>, e + n); <span class="keyword">int</span> nowedge = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) siz[i] = <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nowedge &lt; n &amp;&amp; e[nowedge].w == i) &#123;</span><br><span class="line">            <span class="built_in">connect</span>(e[nowedge].u, e[nowedge].v);</span><br><span class="line">            ++ nowedge; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (ans *= (nowans - i + <span class="number">1</span>)) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); nowedge = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ans) <span class="keyword">return</span> <span class="number">0</span>; <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">        <span class="keyword">if</span> (!c[i][j])  &#123;</span><br><span class="line">            ne[++ ncnt].u = i, ne[ncnt].v = j;</span><br><span class="line">            ne[ncnt].w = <span class="built_in">get_limit</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ne + <span class="number">1</span>, ne + ncnt + <span class="number">1</span>); <span class="keyword">int</span> necnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nowedge &lt; n &amp;&amp; e[nowedge].w == i) &#123;++ nowedge; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        c[ne[necnt].u][ne[necnt].v] = i; c[ne[necnt].v][ne[necnt].u] = i; ++ necnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="t4-字典树">#T4 字典树</h2>
<blockquote>
<p>Time Limit: 1s Memory Limit: 512MB</p>
</blockquote>
<h3 id="题意简述-3">#题意简述</h3>
<p>给定 <span class="math inline">\(n(n\leq10)\)</span> 个数字串 <span class="math inline">\(S_1,\dots,S_n\)</span>，每个串的长度都为 <span class="math inline">\(m(m\leq100)\)</span>。</p>
<p>然而，现在每个字符串内部的字符顺序都可能出现随机的调换，例如若 <span class="math inline">\(S_i=012\)</span>，那么调换后 <span class="math inline">\(S_i\)</span> 会等概率随机成为 <span class="math inline">\(012,021,102,120,201,210\)</span> 中的一种。</p>
<p>现要把调换后的 <span class="math inline">\(n\)</span> 个数字串全部插入一棵字典树中（调换的结果是等概率随机的），问这个字典树结点数量的期望是多少，答案对 <span class="math inline">\(998244353\)</span> 取模。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>考虑字典树的实际含义：给定字符串集合中的任意一个字符串的任意一个前缀都会对应一个字 典树结点。</p>
<p>因此我们可以枚举字符串 <span class="math inline">\(T\)</span>，判断 <span class="math inline">\(T\)</span> 出现在字典树上的概率是多少，也就是 <span class="math inline">\(T\)</span> 是至少一个给定串的前缀的概率是多少。 设 <span class="math inline">\(T\)</span> 中包含 <span class="math inline">\(t_0\)</span> 个 <span class="math inline">\(0\)</span>，<span class="math inline">\(t_1\)</span> 个 <span class="math inline">\(1\)</span>，<span class="math inline">\(\dots\)</span>，<span class="math inline">\(t_9\)</span> 个 <span class="math inline">\(9\)</span>，再设 <span class="math inline">\(S_x\)</span> 中包含 <span class="math inline">\(s_0\)</span> 个 <span class="math inline">\(0\)</span>，<span class="math inline">\(s_1\)</span> 个 <span class="math inline">\(1\)</span>，<span class="math inline">\(\dots\)</span>，<span class="math inline">\(s_9\)</span> 个 <span class="math inline">\(9\)</span>，那 么 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(S_x\)</span> 前缀的概率应当是： <span class="math display">\[
\dfrac{\prod(s_j^{\underline{t_i}})}{(\sum s_i)^{\underline{(\sum t_i)}}}
\]</span> 其中 <span class="math inline">\(x^{\underline m}=x\times(x-1)\times\cdots\times(x-m+1)\)</span>.</p>
<p>对这个式子的一个简单说明：分母表示从 <span class="math inline">\(\sum s_i\)</span> 个数中挑出 <span class="math inline">\(\sum t_i\)</span> 个数构成一个前缀的方案数， 分子则是对每个位置具体限定其等于 <span class="math inline">\(T\)</span> 中对应位置的方案数。 设这个概率为 <span class="math inline">\(p(T, x)\)</span>，那么可知 <span class="math inline">\(T\)</span> 是至少一个 <span class="math inline">\(S_x\)</span> 的前缀的概率（记为 <span class="math inline">\(P(T)\)</span>）为： <span class="math display">\[
P(T)=1-\prod\limits_{x=1}^n(1-p(T,x)),
\]</span> 而我们要求的答案就是所有 <span class="math inline">\(P(T)\)</span> 的总和。注意到 <span class="math inline">\(p(T,x)\)</span> 只与 <span class="math inline">\(t_0,t_1,\dots,t_9\)</span> 的大小有关，而与怎样排列无关，于是 <span class="math inline">\(P(T)\)</span> 也可以记为 <span class="math inline">\(P(t_0,t_1,\dots,t_9)\)</span> 再考虑到构成 <span class="math inline">\(T\)</span> 的方案数，可知答案为 <span class="math display">\[
\sum\limits_{t_0,t_1\dots,t_9}\left(\dfrac{(\sum t_i)!}{\prod(t_i!)}\cdot P(t_0,t_1,\dots,t_9)\right),
\]</span> 直接计算的时间复杂度为 <span class="math inline">\(O(m^{10}\times n)\)</span>，无法接受，注意到 <span class="math inline">\(n\)</span> 很小，考虑将 <span class="math inline">\(P(T)\)</span> 进行变幻得到： <span class="math display">\[
P(T)=\sum\limits_{\varnothing\ne S\subseteq\{1,2,\dots,n\}}\left((-1)^{|S|-1}\prod\limits_{i\in S}p(T,i)\right),
\]</span> 其实就是将原本的连乘的式子展开了，变成了容斥的形式，于是答案变为 <span class="math display">\[
\begin{aligned}
&amp;\sum\limits_{t_0,t_1\dots,t_9}\left(\dfrac{(\sum t_i)!}{\prod(t_i!)}\cdot P(t_0,t_1,\dots,t_9)\right)\\
=&amp;\sum\limits_{t_0,t_1\dots,t_9}\left(\dfrac{(\sum t_i)!}{\prod(t_i!)}\cdot \sum\limits_{\varnothing\ne S\subseteq\{1,2,\dots,n\}}\left((-1)^{|S|-1}\prod\limits_{i\in S}p(T,i)\right)\right)\\
=&amp;\sum\limits_{\varnothing\ne S\subseteq\{1,2,\dots,n\}}(-1)^{|S|-1}\cdot\left(\sum\limits_{t_0,t_1\dots,t_9}\left(\dfrac{(\sum t_i)!}{\prod(t_i!)}\cdot\prod\limits_{i\in S}p(T,i)\right)\right)\\
=&amp;\sum\limits_{\varnothing\ne S\subseteq\{1,2,\dots,n\}}(-1)^{|S|-1}\cdot\left(\sum\limits_{t_0,t_1\dots,t_9}\left(\dfrac{(\sum t_i)!}{\prod(t_i!)}\cdot\prod\limits_{k\in S}\dfrac{\prod(s_{k,j}^{\underline{t_i}})}{(\sum s_{k,j})^{\underline{(\sum t_i)}}}\right)\right)
\end{aligned}
\]</span></p>
<p>于是我们先考虑后半部分式子的贡献，注意到 <span class="math inline">\(\prod(t_i)!\)</span> 与 <span class="math inline">\(\prod(s_{k,j}^{\underline{t_i}})\)</span> 都只与 <span class="math inline">\(t_i\)</span> 有关，于是我们可以单独拿出来做背包，具体地，从 <span class="math inline">\(t_0\)</span> 到 <span class="math inline">\(t_9\)</span> 依次进行背包 DP，加入 <span class="math inline">\(t_i =y\)</span> 时对答案的贡献是其红色部分的乘积，也 就是 <span class="math inline">\(\dfrac{\prod\limits_{j\in S}s^{\underline y}_{s_{j,i}}}{y!}\)</span>，其中 <span class="math inline">\(s_{j,i}\)</span> 是 <span class="math inline">\(S_j\)</span> 中 <span class="math inline">\(i\)</span> 的出现次数。最后再考虑补充上 <span class="math inline">\(\sum t_i\)</span> 的贡献。考虑上枚举 <span class="math inline">\(S\)</span>，时间复杂度为 <span class="math inline">\(O(2^nm^2)\)</span>.</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, m; ll ans, vec[N], dm[N][N], cnt[N][<span class="number">10</span>], w[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) (res *= x) %= MOD;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>, (x *= x) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">          ++ cnt[i][s[j] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        dm[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">          dm[i][j] = dm[i][j - <span class="number">1</span>] * (i - j + <span class="number">1</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>; ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) </span><br><span class="line">          <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) vec[++ tot] = j + <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) f[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++ j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= m; ++ l) &#123;</span><br><span class="line">                 w[l] = <span class="built_in">fpow</span>(dm[l][l], MOD - <span class="number">2</span>);</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tot; ++ k)</span><br><span class="line">                    w[l] = w[l] * dm[cnt[vec[k]][j]][l] % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = m; l &gt;= <span class="number">0</span>; -- l)</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = l - <span class="number">1</span>; k &gt;= <span class="number">0</span>; -- k)</span><br><span class="line">                (f[l] += f[k] * w[l - k] % MOD) %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            ll tmp = f[j] * dm[j][j] % MOD;</span><br><span class="line">            ll prod = <span class="built_in">fpow</span>(dm[m][j], MOD - <span class="number">2</span>);</span><br><span class="line">            (sum += tmp * <span class="built_in">fpow</span>(prod, tot) % MOD) %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tot &amp; <span class="number">1</span>) (ans += sum) %= MOD;</span><br><span class="line">        <span class="keyword">else</span> ans = (ans - sum + MOD) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP冲刺-TEST3 总结</title>
    <url>/2021/10/15/ZROI-21-NOIP-SP-TEST3/</url>
    <content><![CDATA[<h2 id="t1-史上最简洁的题面">#T1 史上最简洁的题面</h2>
<h3 id="题意简述">#题意简述</h3>
<p>给定一个 <span class="math inline">\(n(n\leq 25)\)</span> 个点 <span class="math inline">\(m(m\leq\frac{n(n-1)}{2})\)</span> 条边的无向图，对于每一个在 <span class="math inline">\([0,m]\)</span> 内的 <span class="math inline">\(i\)</span>，求有多少中黑白染色方案使得有 <span class="math inline">\(i\)</span> 条边两端的点都是黑色的。</p>
<h3 id="大体思路">#大体思路</h3>
<p>考虑枚举当前图中被染黑的点，计算这张图中的黑边（两段点都是黑点的边）的个数，注意到如果被染黑的点确定，那么不管最后被染黑的点是哪一个，最终黑边的个数都是一定的。</p>
<p>以二进制状态表示当前哪些点染黑了、哪些点没被染黑，设当前状态为 <span class="math inline">\(x\)</span>，不妨令该图中最后一个被染黑的点是 <span class="math inline">\(u=pos(lowbit(x))\)</span>，<span class="math inline">\(pos(x)\)</span> 表示 <span class="math inline">\(x\)</span> 在二进制表示下的位数；再来考虑会有哪些边被染成黑色：<span class="math inline">\((u,v)\in E\)</span> 且 <span class="math inline">\(v\)</span> 已经被染黑；我们容易得到 <span class="math inline">\(u\)</span> 的连边情况，用二进制表示出来，与 <span class="math inline">\(x\)</span> 做 <span class="math inline">\(\text{and}\)</span> 运算得到的结果的 <span class="math inline">\(1\)</span> 的个数就是新加入的边的个数，转移即可。可以用 <code>bitset</code> 进行优化，时间复杂度为 <span class="math inline">\(O(\dfrac{n\cdot2^n}w)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">4e7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bitset &lt;30&gt; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt[N], f[M], pos[M];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (-(x)&amp;(x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">      pos[(<span class="number">1</span> &lt;&lt; i)] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        p[u][v] = <span class="number">1</span>, p[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) p[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>; cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = i, lt = pos[<span class="built_in">lowbit</span>(i)];</span><br><span class="line">        bitset &lt;30&gt; <span class="built_in">bt</span>(t);</span><br><span class="line">        bt &amp;= p[lt]; t -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">        f[i] = f[t] + bt.<span class="built_in">count</span>(); ++ cnt[f[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cnt[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-史上第二简洁的题面">#T2 史上第二简洁的题面</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定一个长度为 <span class="math inline">\(n(n\leq10^5)\)</span> 的序列 <span class="math inline">\(a(a_i\leq10^5)\)</span>，给定 <span class="math inline">\(m(m\leq10^5)\)</span> 个询问 <span class="math inline">\(l,r,x\)</span>，求 <span class="math inline">\(a_l,a_{l+1},\dots,a_r\)</span> 中有多少个数与 <span class="math inline">\(x(x\leq10^5)\)</span> 互质。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>考虑莫比乌斯反演： <span class="math display">\[
[(a_i,x)=1]=\sum\limits_{d|(a_i,x)}\mu(d)=\sum\limits_{d|a_i,d|x}\mu(d),
\]</span> 于是有 <span class="math display">\[
\begin{aligned}
&amp;\sum\limits_{i=l}^r[(a_i,x)=1]=\sum\limits_{i=l}^r\sum\limits_{d|a_i,d|x}\mu(d)=\sum\limits_{d|x}\mu(d)\sum\limits_{i=l}^r[d|a_i]\\
=&amp;\sum\limits_{d|x}\mu(d)\cdot(sum_r-sum_{l-1})=\sum\limits_{d|x}\mu(d)\cdot sum_{d,r}-\sum\limits_{d|x}\mu(d)\cdot sum_{d,l-1}
\end{aligned}
\]</span> 其中 <span class="math inline">\(sum_{d,x}\)</span> 表示 <span class="math inline">\(a_1,a_2,\dots,a_x\)</span> 中 <span class="math inline">\(d\)</span> 的倍数的个数。</p>
<p>于是我们可以将原本的一个询问拆成两个，然后将这 <span class="math inline">\(2m\)</span> 个询问按右端点排序，依次处理。时间复杂度为 <span class="math inline">\(O((n+m)\sqrt{a_{MAX}})=O(n\sqrt n)\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span><span class="keyword">int</span> op, r, x, id;&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], mu[N], prm[N], pcnt, nprm[N], sum[N], ans[N];</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; P[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nprm[i]) prm[++ pcnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prm[j] * i &gt; x) <span class="keyword">break</span>;</span><br><span class="line">            nprm[prm[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prm[j]) mu[i * prm[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query x, Query y)</span> </span>&#123;<span class="keyword">return</span> x.r &lt; y.r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pbk(x) push_back(x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_list</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (P[x].<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= x; ++ i) <span class="keyword">if</span> (!(x % i)) &#123;</span><br><span class="line">        P[x].<span class="built_in">pbk</span>(i); <span class="keyword">if</span> (i != x / i) P[x].<span class="built_in">pbk</span>(x / i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(m); <span class="built_in">euler</span>(N &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, x; <span class="built_in">read</span>(l), <span class="built_in">read</span>(r), <span class="built_in">read</span>(x);</span><br><span class="line">        q[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>] = (Query)&#123;<span class="number">-1</span>, l - <span class="number">1</span>, x, i&#125;;</span><br><span class="line">        q[(i &lt;&lt; <span class="number">1</span>)] = (Query)&#123;<span class="number">1</span>, r, x, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + (m &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= m &lt;&lt; <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= n &amp;&amp; j &lt;= q[i].r; ++ j) &#123;</span><br><span class="line">            <span class="built_in">get_list</span>(a[j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k : P[a[j]]) ++ sum[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">get_list</span>(q[i].x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k : P[q[i].x])</span><br><span class="line">          ans[q[i].id] += q[i].op * mu[k] * sum[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-史上第三简洁的题面">#T3 史上第三简洁的题面</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>有 <span class="math inline">\(n(n\leq 2000)\)</span> 个人排成一排，从左到右编号为 <span class="math inline">\(1,\dots,n\)</span>，接下来你每次可以指定两个相邻的人战斗，输的一方将会离开队伍，直到最后只有一个人留在队伍里，这个人将会称为最后的赢家。你知道任意两个人打谁会赢，求哪些人可能会成为最后的赢家。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>考虑一个人 <span class="math inline">\(x\)</span> 在 <span class="math inline">\([l,r]\)</span> 能获胜当且仅当能在 <span class="math inline">\([l, x]\)</span> 获胜且能在 <span class="math inline">\([x,r]\)</span> 获胜。</p>
<p>设 <span class="math inline">\(lasL_x\)</span> 表示在当前区间长度下，<span class="math inline">\(x\)</span> 作为左端点，作为右端点可以获胜的点的集合，<span class="math inline">\(lasR_x\)</span> 意义类似。设当前区间为 <span class="math inline">\([l,r]\)</span>，则该区间内可以获胜的人是 <span class="math inline">\(lasL_l\cap lasR_R\)</span>.</p>
<p>每次将当前区间向左/右扩展一位，维护转移即可。时间复杂度 <span class="math inline">\(O(n^3)\)</span>，发现转移可以用 <code>bitset</code> 优化，时间复杂度为 <span class="math inline">\(O(\dfrac {n^3} w)\)</span>.</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line">bitset &lt;N&gt; mp[N], beat[N], res, lasL[N], lasR[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">          beat[i][j] = s[j] ^ <span class="number">48</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      lasL[i][i] = <span class="number">1</span>, lasR[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; ++ len)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = len; r &lt;= n; ++ l, ++ r) &#123;</span><br><span class="line">          res = lasL[l] &amp; lasR[r];</span><br><span class="line">          <span class="keyword">if</span> (r != n &amp;&amp; (beat[r + <span class="number">1</span>] &amp; res).<span class="built_in">any</span>())</span><br><span class="line">            lasL[l][r + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; (beat[l - <span class="number">1</span>] &amp; res).<span class="built_in">any</span>())</span><br><span class="line">            lasR[r][l - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    res = lasL[<span class="number">1</span>] &amp; lasR[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (res[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-史上第四简洁的题面">#T4 史上第四简洁的题面</h2>
<h3 id="题意简述-3">#题意简述</h3>
<p>给定一张 <span class="math inline">\(n(n\leq10^6)\)</span> 个点 <span class="math inline">\(m(m\leq2\times10^6)\)</span> 条带权边 <span class="math inline">\((w_i\leq10^9)\)</span> 的无向图，指定一个终点 <span class="math inline">\(V\)</span>，有一条边不能通行，但不知道是哪一条，问对于图中的所有点，在最优策略下最坏情况到达 <span class="math inline">\(v\)</span> 经过边的边权和。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>“最优策略”即为走最短路，于是“最坏情况”一定是不能通行的边是最短路树上的边，于是我们可以求得断掉最短路树上 <span class="math inline">\(x\)</span> 向父亲的边时的最短路径 <span class="math inline">\(val_x\)</span>，设答案为 <span class="math inline">\(f_x\)</span>，那么有 <span class="math display">\[
\begin{aligned}
f_v&amp;=\max\{val_v,\min\limits_{(u,v)\in E}\{f_u+w(i,v)\}\}\\
&amp;=\min\limits_{(u,v)\in E}\{\max\{val_v,f_u+w(i,w)\}\},
\end{aligned}
\]</span> 这个式子类似于求最短路的式子，用类似 dijkstra 的算法处理一下就可以得到。</p>
<p>我们的复杂度瓶颈是求 <span class="math inline">\(val_x\)</span>，直接断开最短路树上的边计算的时间复杂度是 <span class="math inline">\(O(n^2\log n)\)</span>，考虑优化。</p>
<p>我们考虑最短路树，当从多条边到 <span class="math inline">\(x\)</span> 得到的距离都是最小距离时，只保存一条作为树边。不难发现，断掉 <span class="math inline">\(x\)</span> 向父亲的边后，<span class="math inline">\(x\)</span> 的最短路最多只经过一条非树边，于是我们可以考虑对于每一条非树边 <span class="math inline">\((u,v)\)</span>，有哪些点会在向父亲的边被断开后将 <span class="math inline">\((u,v)\)</span> 作为惟一的非树边经过。注意到 <span class="math inline">\(x\)</span> 经过非树边 <span class="math inline">\((u,v)\)</span> 的后距离是 <span class="math inline">\(dis_u+dis_v+w(u,v)-dis_x\)</span>，且 <span class="math inline">\(x\)</span> 必然在 <span class="math inline">\(u\)</span> 从最短路树上到 <span class="math inline">\(v\)</span> 的路径上，且不是 LCA，于是我们设计出一下维护方法：</p>
<p>对于非树边 <span class="math inline">\((u,v)\)</span>，我们将 <span class="math inline">\(dis_u+dis_v+w(u,v)\)</span> 作为它的新的权值，从小到大排序，在最短路树上对 <span class="math inline">\(u\to v\)</span> 的路径进行并查集合并，同时修改对应的 <span class="math inline">\(val\)</span>，注意不能更新 LCA 的 <span class="math inline">\(val\)</span>，每个点最多被更新一次，时间复杂度为 <span class="math inline">\(O(n)\)</span>.</p>
<p>于是总体时间复杂度为 <span class="math inline">\(O((n+m)\log n)\)</span>.</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plli pair <span class="meta-string">&lt;long long, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt, tag; ll w, val;&#125; e[M &lt;&lt; <span class="number">1</span>], et[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, head[N], <span class="built_in">ecnt</span>(<span class="number">2</span>), <span class="built_in">ect2</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v, e[ecnt].w = w;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;plli &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[N]; ll dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mset</span>(vis, <span class="number">0</span>); <span class="built_in">mset</span>(dis, <span class="number">0x3f</span>);</span><br><span class="line">    dis[u] = <span class="number">0</span>; q.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>, u));</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>; vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">          <span class="keyword">if</span> (dis[e[i].v] &gt; dis[x] + e[i].w) &#123;</span><br><span class="line">              dis[e[i].v] = dis[x] + e[i].w;</span><br><span class="line">              q.<span class="built_in">push</span>(<span class="built_in">mp</span>(-dis[e[i].v], e[i].v));</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fath[N], dep[N], fa[N]; ll val[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">while</span> (x != fa[x]) x = fa[x] = fa[fa[x]]; <span class="keyword">return</span> x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_info</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    fath[x] = father, dep[x] = dep[father] + <span class="number">1</span>, vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[e[i].v] || dis[e[i].v] != dis[x] + e[i].w) <span class="keyword">continue</span>;</span><br><span class="line">        e[i].tag = <span class="number">1</span>; <span class="built_in">get_info</span>(e[i].v, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">return</span> dis[e[k].u] + dis[e[k].v] + e[k].w;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = et[k].u, v = et[k].v; ll w = et[k].val;</span><br><span class="line">    <span class="keyword">if</span> (!dep[u] || !dep[v]) <span class="keyword">return</span>;</span><br><span class="line">    u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">while</span> (u != v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        val[u] = w, fa[u] = fath[u]; u = <span class="built_in">find</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">mset</span>(vis, <span class="number">0</span>); <span class="built_in">mset</span>(f, <span class="number">0x3f</span>);</span><br><span class="line">    f[u] = <span class="number">0</span>; q.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>, u));</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>; vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) <span class="keyword">if</span> (!vis[e[i].v])</span><br><span class="line">          <span class="keyword">if</span> (f[e[i].v] &gt; <span class="built_in">Max</span>(val[e[i].v], f[x] + e[i].w)) &#123;</span><br><span class="line">              f[e[i].v] = <span class="built_in">Max</span>(val[e[i].v], f[x] + e[i].w);</span><br><span class="line">              q.<span class="built_in">push</span>(<span class="built_in">mp</span>(-f[e[i].v], e[i].v));</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st; <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; ll w; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(w);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v, w), <span class="built_in">add_edge</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(st); <span class="built_in">mset</span>(vis, <span class="number">0</span>); <span class="built_in">get_info</span>(st, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; ecnt; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].tag || e[i ^ <span class="number">1</span>].tag) <span class="keyword">continue</span>;</span><br><span class="line">        et[ect2] = e[i]; et[ect2 ++].val = <span class="built_in">calc</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](Edge x, Edge y)&#123;<span class="keyword">return</span> x.val &lt; y.val;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(et + <span class="number">1</span>, et + ect2, cmp); <span class="built_in">mset</span>(val, <span class="number">0x3f</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ect2; ++ i) <span class="built_in">mark</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) val[i] -= dis[i];</span><br><span class="line">    <span class="built_in">get_ans</span>(st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, f[i] &gt; INF / <span class="number">10</span> ? <span class="number">-1</span> : f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP冲刺-TEST2 总结</title>
    <url>/2021/10/15/ZROI-21-NOIP-SP-TEST2/</url>
    <content><![CDATA[<h2 id="t1-幻方">#T1 幻方</h2>
<h3 id="题意简述">#题意简述</h3>
<p>给定⼀个 <span class="math inline">\(3\times 3\)</span> 矩阵，矩阵中恰好有 <span class="math inline">\(1-9\)</span> 这 <span class="math inline">\(9\)</span> 个整数。 你可以进⾏若⼲次操作，每次操作交换其中相邻的两个数，操作完后使得：</p>
<ul>
<li>矩阵每⼀⾏的和为 <span class="math inline">\(15\)</span>；</li>
<li>矩阵每⼀列的和为 <span class="math inline">\(15\)</span>；</li>
<li>矩阵两条对⻆线的和为 <span class="math inline">\(15\)</span>；</li>
</ul>
<p>问最少需要⼏次操作。多组数据，<span class="math inline">\(T\leq50\)</span>.</p>
<h3 id="大体思路">#大体思路</h3>
<p>合法的情况很少，只有 <span class="math inline">\(8\)</span> 种，而所有的状态只有 <span class="math inline">\(9!=362880\)</span> 种，每次变换只有 <span class="math inline">\(12\)</span> 种，直接 BFS 即可，注意需要记忆化，所以需要写 Hash 表。时间复杂度 <span class="math inline">\(O(T\cdot9!)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">3000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">2908361</span>;</span><br><span class="line"><span class="keyword">const</span> ll std_block[<span class="number">8</span>] = &#123;</span><br><span class="line">    <span class="number">276951438</span>, <span class="number">294753618</span>, <span class="number">438951276</span>, <span class="number">492357816</span>,</span><br><span class="line">    <span class="number">618753294</span>, <span class="number">672159834</span>, <span class="number">816357492</span>, <span class="number">834159672</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span>ll val; <span class="keyword">int</span> cnt;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[M], nxt[N], cnt, val[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;cnt = <span class="number">0</span>; <span class="built_in">mset</span>(head, <span class="number">0</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> H = x % MOD; val[++ cnt] = x;</span><br><span class="line">        nxt[cnt] = head[H], head[H] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> H = x % MOD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[H]; i; i = nxt[i])</span><br><span class="line">          <span class="keyword">if</span> (val[i] == x) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; hsh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, T, vis[N]; ll p[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">change</span><span class="params">(ll x, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) p1 = <span class="number">1</span>, p2 = <span class="number">2</span>; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) p1 = <span class="number">2</span>, p2 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) p1 = <span class="number">1</span>, p2 = <span class="number">4</span>; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) p1 = <span class="number">2</span>, p2 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) p1 = <span class="number">3</span>, p2 = <span class="number">6</span>; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) p1 = <span class="number">4</span>, p2 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">7</span>) p1 = <span class="number">5</span>, p2 = <span class="number">6</span>; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">8</span>) p1 = <span class="number">4</span>, p2 = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">9</span>) p1 = <span class="number">5</span>, p2 = <span class="number">8</span>; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">10</span>) p1 = <span class="number">6</span>, p2 = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">11</span>) p1 = <span class="number">7</span>, p2 = <span class="number">8</span>; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">12</span>) p1 = <span class="number">8</span>, p2 = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = x % p[p1] / p[p1 - <span class="number">1</span>], n2 = x % p[p2] / p[p2 - <span class="number">1</span>];</span><br><span class="line">    x -= n1 * p[p1 - <span class="number">1</span>] + n2 * p[p2 - <span class="number">1</span>];</span><br><span class="line">    x += n1 * p[p2 - <span class="number">1</span>] + n2 * p[p1 - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status q[N]; <span class="keyword">int</span> frt, tal, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++ i) a[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">362880</span> - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        ll val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++ j)</span><br><span class="line">          val *= <span class="number">10</span>, val += a[j];</span><br><span class="line">        hsh.<span class="built_in">insert</span>(val);</span><br><span class="line">        <span class="built_in">next_permutation</span>(a + <span class="number">1</span>, a + <span class="number">9</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(ll st)</span> </span>&#123;</span><br><span class="line">    frt = <span class="number">0</span>, tal = <span class="number">-1</span>; q[++ tal] = (Status)&#123;st, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (frt &lt;= tal) &#123;</span><br><span class="line">        ll now = q[frt].val; <span class="keyword">int</span> sp = q[frt ++].cnt;</span><br><span class="line">        <span class="keyword">if</span> (vis[hsh.<span class="built_in">find</span>(now)] == <span class="number">-1</span>) <span class="keyword">return</span> sp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; ++ i) &#123;</span><br><span class="line">            ll ns = <span class="built_in">change</span>(now, i), hns = hsh.<span class="built_in">find</span>(ns);</span><br><span class="line">            <span class="keyword">if</span> (vis[hns] == <span class="number">-1</span>) <span class="keyword">return</span> sp + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[hns] != T) &#123;</span><br><span class="line">                q[++ tal] = (Status)&#123;ns, sp + <span class="number">1</span>&#125;;</span><br><span class="line">                vis[hns] = T;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hsh.<span class="built_in">init</span>(); p[<span class="number">0</span>] = <span class="number">1</span>; <span class="built_in">read</span>(t); <span class="built_in">prework</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++ i)</span><br><span class="line">      p[i] = p[i - <span class="number">1</span>] * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++ i)</span><br><span class="line">      vis[hsh.<span class="built_in">find</span>(std_block[i])] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (T = <span class="number">1</span>; T &lt;= t; ++ T) &#123;</span><br><span class="line">        ll x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++ i)</span><br><span class="line">          <span class="built_in">read</span>(y), x = x * <span class="number">10</span> + y;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">bfs</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-数集">#T2 数集</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>维护一个一开始为空的集合 <span class="math inline">\(S\)</span>，有总共 <span class="math inline">\(q(q\leq2^{20})\)</span> 次以下三种操作：</p>
<ul>
<li>加入一个数 <span class="math inline">\(x\)</span>；</li>
<li>询问 <span class="math inline">\(\max_{y\in S}x\text{ xor }y,\max_{y\in S}x\text{ and }y,\max_{y\in S}x\text{ or }y\)</span>；</li>
<li>询问 <span class="math inline">\(\max_{y\in S}x\text{ xor }y\)</span>；</li>
</ul>
<p>其中 <span class="math inline">\(x\leq2^{20}\)</span>.</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>最大异或和可以直接用 01 trie 维护，下面讨论 and/or 的维护。</p>
<ul>
<li>对于 <span class="math inline">\(\text{and}\)</span>，显然我们希望自高到低位的 1 尽可能被选上；</li>
<li>对于 <span class="math inline">\(\text{or}\)</span>，显然我们希望自高到低位的 <span class="math inline">\(0\)</span> 尽可能被补成 1；</li>
</ul>
<p>再来考虑一个数 <span class="math inline">\(x\)</span> 的贡献，显然它所有的子集都是可以通过选择 <span class="math inline">\(x\)</span> 得到，于是每插入一个 <span class="math inline">\(x\)</span> 就对它的子集进行标记，查询时按上面的思路进行贪心即可。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lg[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ch[<span class="number">2</span>], val, s;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    Node p[N]; <span class="keyword">int</span> rt, cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;rt = cnt = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; ~i; -- i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p[now].ch[k])</span><br><span class="line">              p[now].ch[k] = ++ cnt;</span><br><span class="line">            now = p[now].ch[k];</span><br><span class="line">        &#125;</span><br><span class="line">        p[now].val = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query_xor</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; ~i; -- i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = !((x &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!p[now].ch[k])</span><br><span class="line">              now = p[now].ch[!k];</span><br><span class="line">            <span class="keyword">else</span> now = p[now].ch[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[now].val ^ x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q, marked[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    marked[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; -- i)</span><br><span class="line">      <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span> &amp;&amp; !marked[x ^ (<span class="number">1</span> &lt;&lt; i)])</span><br><span class="line">        <span class="built_in">mark</span>(x ^ (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) t.<span class="built_in">insert</span>(x), <span class="built_in">mark</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t.<span class="built_in">query_xor</span>(x));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t.<span class="built_in">query_xor</span>(x)); </span><br><span class="line">            <span class="keyword">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; -- i)</span><br><span class="line">              <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span> &amp;&amp; marked[res1 | (<span class="number">1</span> &lt;&lt; i)])</span><br><span class="line">                res1 |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; -- i)</span><br><span class="line">              <span class="keyword">if</span> (!(x &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; marked[res2 | (<span class="number">1</span> &lt;&lt; i)])</span><br><span class="line">                res2 |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, res1 &amp; x, res2 | x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-染色">#T3 染色</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>⼀棵 <span class="math inline">\(n(n\leq3\times10^5)\)</span> 个点的树上有两个⿊点 ，其余都是⽩点。 接下来，每过⼀个单位时间，树上的每个⿊点可以选择⼀个它相邻的点染⿊。 请问，在最优策略的情况下，⾄少要经过多少个单位时间，才能把整棵树染⿊。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>显然最优策略是所需时间最长的子树尽可能先选，我们可以在原树上二分，将原树分为两棵树，尽可能让分出来的答案接近一定是最优的。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, b, head[N], <span class="built_in">ecnt</span>(<span class="number">2</span>), pre[N], op = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> g[N], pass[N], pcnt, f[N], gcnt, tag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_path</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == b) &#123;op = <span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i &amp;&amp; op; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        pre[e[i].v] = i, <span class="built_in">get_path</span>(e[i].v, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">get_path</span>(a, <span class="number">0</span>); <span class="keyword">int</span> now = b;</span><br><span class="line">    <span class="keyword">while</span> (e[pre[now]].u != a)</span><br><span class="line">      pass[++ pcnt] = pre[now], now = e[pre[now]].u;</span><br><span class="line">   pass[++ pcnt] = pre[now];</span><br><span class="line">   <span class="built_in">reverse</span>(pass + <span class="number">1</span>, pass + pcnt + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (e[i].v != fa &amp;&amp; i != tag &amp;&amp; (i ^ <span class="number">1</span>) != tag)</span><br><span class="line">        <span class="built_in">dp</span>(e[i].v, x);</span><br><span class="line">    gcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (e[i].v != fa &amp;&amp; i != tag &amp;&amp; (i ^ <span class="number">1</span>) != tag)</span><br><span class="line">        g[++ gcnt] = f[e[i].v];</span><br><span class="line">    <span class="keyword">if</span> (!gcnt) <span class="keyword">return</span>; <span class="built_in">sort</span>(g + <span class="number">1</span>, g + gcnt + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= gcnt; ++ i)</span><br><span class="line">      f[x] = <span class="built_in">Max</span>(f[x], g[i] + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pii <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    tag = pass[x]; <span class="built_in">dp</span>(a, <span class="number">0</span>), <span class="built_in">dp</span>(b, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(f[a], f[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(pii x)</span> </span>&#123;<span class="keyword">return</span> x.first &lt;= x.second;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(a), <span class="built_in">read</span>(b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v), <span class="built_in">add_edge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">connect</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = pcnt, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(<span class="built_in">solve</span>(mid)))</span><br><span class="line">          l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pii ans1 = <span class="built_in">solve</span>(ans), ans2 = <span class="built_in">mp</span>(-INF, INF);</span><br><span class="line">    <span class="keyword">if</span> (ans + <span class="number">1</span> &lt;= pcnt) ans2 = <span class="built_in">solve</span>(ans + <span class="number">1</span>);</span><br><span class="line">    ans = <span class="built_in">Min</span>(<span class="built_in">Max</span>(ans1.first, ans1.second), <span class="built_in">Max</span>(ans2.first, ans2.second));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-电路板">#T4 电路板</h2>
<p><del>因为临近考试，但涉及到了新的科技，就先咕咕咕罢</del></p>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP冲刺-TEST1 总结</title>
    <url>/2021/10/12/ZROI-21-NOIP-SP-TEST1/</url>
    <content><![CDATA[<h2 id="t1-数字变换">#T1 数字变换</h2>
<h3 id="题意简述">#题意简述</h3>
<p>对于有序二元组 <span class="math inline">\((a,b)\)</span> 及质数 <span class="math inline">\(p\)</span>，有如下两种变化操作：</p>
<ul>
<li>变为 <span class="math inline">\((2a \bmod p,(b+p-a)\bmod p)\)</span>；</li>
<li>变为 <span class="math inline">\(((a+p-b)\bmod p, 2b\bmod p)\)</span>；</li>
</ul>
<p>现给定 <span class="math inline">\((a,b),(c,d),p\)</span>，问 <span class="math inline">\((a,b)\)</span> 经过多少次操作可以得到 <span class="math inline">\((c,d)\)</span>。</p>
<p>有 <span class="math inline">\(p\leq10^9+7,0\leq a,b,c,d\leq p-1\)</span>，多组数据，<span class="math inline">\(q\leq10^5\)</span>。</p>
<h3 id="大体思路">#大体思路</h3>
<p><strong>性质 1.</strong> <span class="math inline">\((a,b)\)</span> 可以变化为 <span class="math inline">\((c,d)\)</span> 的充分必要条件是 <span class="math display">\[
(a+b)\bmod p=(c+d)\bmod p.
\]</span> 这一点可以归纳证明。不妨设 <span class="math inline">\((a+b)\bmod p\)</span> 为 <span class="math inline">\(sum\)</span>，于是我们只需要将 <span class="math inline">\(a\)</span> 变为 <span class="math inline">\(c\)</span> 即可。</p>
<p>不难发现对于任何可以表示成如下结构 <span class="math inline">\(2^ka-sum\cdot t\)</span> 的数，其中 <span class="math inline">\(k\in[0,w],t\in[0,2^k)\)</span>，<span class="math inline">\(w\)</span> 为 <span class="math inline">\(p\)</span> 在二进制表示下的位数，都一定可以由 <span class="math inline">\(a\)</span> 通过给定变化得到，于是我们只需要枚举 <span class="math inline">\(k\)</span>，看 <span class="math inline">\(\dfrac{2^k-c} {sum}\)</span> 在 <span class="math inline">\(\bmod p\)</span> 意义下是否是二进制表示下位数小于 <span class="math inline">\(k\)</span> 即可。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll p, q, a, b, c, d, w;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll y, ll c)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) (res *= x) %= c;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>, (x *= x) %= c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_digit</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">while</span> (x) ++ res, x &gt;&gt;= <span class="number">1</span>; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(p); <span class="built_in">read</span>(q); w = <span class="built_in">get_digit</span>(p);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a); <span class="built_in">read</span>(b); <span class="built_in">read</span>(c); <span class="built_in">read</span>(d);</span><br><span class="line">        <span class="keyword">if</span> ((a + b) % p != (c + d) % p) &#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        ll sum = (a + b) % p, inv = <span class="built_in">fpow</span>(sum, p - <span class="number">2</span>, p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= w; ++ i) &#123;</span><br><span class="line">            ll now = ((<span class="number">1ll</span> &lt;&lt; i) * a % p - c + p) % p * inv % p;</span><br><span class="line">            <span class="keyword">int</span> now_cnt = <span class="built_in">get_digit</span>(now);</span><br><span class="line">            <span class="keyword">if</span> (now_cnt &lt;= i) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, i); <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-均分财产">#T2 均分财产</h2>
<blockquote>
<p>一道挺有意思的乱搞题。</p>
</blockquote>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定 <span class="math inline">\(n(n\leq2\times10^5)\)</span> 个数 <span class="math inline">\(a_i\leq W=2\times10^5\)</span>，任意删除不超过 <span class="math inline">\(k(\min(25,n-2)\leq k\leq n-2)\)</span> 个数，要求将剩下的数分为两个和相等的可重集，给出方案。数据随机。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>当 <span class="math inline">\(n\leq25\)</span> 时，枚举所有子集，找到两个元素和相等的集合 <span class="math inline">\(A,B\)</span> 即可，最终答案为 <span class="math inline">\(A&#39;=A-A\cap B,B&#39;=B-A\cap B\)</span>，时间复杂度 <span class="math inline">\(O(2^n)\)</span>.</p>
<p>否则，将前 <span class="math inline">\(n-25\)</span> 个元素贪心地分类，若当前元素 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(t&lt;0\)</span> 则分到 <span class="math inline">\(A\)</span>，<span class="math inline">\(t\)</span> 加上 <span class="math inline">\(a_i\)</span>，否则分到 <span class="math inline">\(B\)</span>，<span class="math inline">\(t\)</span> 减去 <span class="math inline">\(b_i\)</span>，这样最后得到的 <span class="math inline">\(t\in[0,W)\)</span>。对于剩下的 <span class="math inline">\(25\)</span> 个元素，只需要枚举所有的子集，找到两个差为 <span class="math inline">\(t\)</span> 的即可。时间复杂度 <span class="math inline">\(O(n+2^{25})\)</span>.</p>
<p>对于 <span class="math inline">\(25\)</span> 个元素的所有子集，一定有元素和小于等于 <span class="math inline">\(25W\)</span>，而一共有 <span class="math inline">\(2^{25}\)</span> 个子集，比 <span class="math inline">\(26W\)</span> 大许多，由于是随机数据，几乎一定会出现两个集合元素差为 <span class="math inline">\(x(x\in[0,W))\)</span>。</p>
<p>这里枚举子集的部分直接用的 <span class="math inline">\(O(3^n)\)</span> 的爆搜+剪枝，也可以过。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, k, a[N], ans = <span class="number">-1</span>, s[N], LMT, st[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> tot, <span class="keyword">int</span> lsum, <span class="keyword">int</span> rsum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (~ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (t == LMT + <span class="number">1</span>) &#123;<span class="keyword">if</span> (lsum - rsum == T) ans = <span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (tot &lt; k &amp;&amp; !(~ans)) s[t] = <span class="number">0</span>, <span class="built_in">dfs</span>(t + <span class="number">1</span>, tot + <span class="number">1</span>, lsum, rsum);</span><br><span class="line">    <span class="keyword">if</span> (!(~ans)) s[t] = <span class="number">1</span>, <span class="built_in">dfs</span>(t + <span class="number">1</span>, tot, lsum + a[t], rsum);</span><br><span class="line">    <span class="keyword">if</span> (!(~ans)) s[t] = <span class="number">2</span>, <span class="built_in">dfs</span>(t + <span class="number">1</span>, tot, lsum, rsum + a[t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(k); LMT = <span class="built_in">min</span>(n, <span class="number">25</span>);</span><br><span class="line">    <span class="keyword">int</span> tot[<span class="number">3</span>]; tot[<span class="number">0</span>] = tot[<span class="number">1</span>] = tot[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">26</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (T &gt; <span class="number">0</span>) T -= a[i], st[++ st[<span class="number">0</span>][<span class="number">1</span>]][<span class="number">1</span>] = i;</span><br><span class="line">        <span class="keyword">else</span> T += a[i], st[++ st[<span class="number">0</span>][<span class="number">2</span>]][<span class="number">2</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(~ans)) &#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LMT; ++ i) ++ tot[s[i]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tot[<span class="number">1</span>] + st[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= st[<span class="number">0</span>][<span class="number">1</span>]; ++ i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, st[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LMT; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (s[i] == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d &quot;</span>, tot[<span class="number">2</span>] + st[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= st[<span class="number">0</span>][<span class="number">2</span>]; ++ i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, st[i][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LMT; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (s[i] == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-查询工资">#T3 查询工资</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>给定一棵以 <span class="math inline">\(1\)</span> 为根，有 <span class="math inline">\(n(n\leq 8\times 10^5)\)</span> 个节点的树，给定参数 <span class="math inline">\(k(2\leq k\leq10^5)\)</span>，每个点上有一个权值（不给出），有以下两种可行的询问方式：</p>
<ul>
<li>对于点 <span class="math inline">\(x\)</span>，如果它的儿子个数不少于 <span class="math inline">\(k\)</span> 个，那么可以得到它所有儿子的权值和；</li>
<li>对于点 <span class="math inline">\(x\)</span>，如果它的子树中的点的个数不少于 <span class="math inline">\(k+1\)</span> 个，那么可以得到它所有的子孙（不包括自己）的权值和；</li>
</ul>
<p>如果一个点是叶子节点，那么它可以被删去，删除操作可以做任意多次。</p>
<p>问在合适的删除操作后，可以通过给定的询问方式得到权值的点的个数。</p>
<p>多组数据，<span class="math inline">\(\sum n\leq4\times10^6\)</span>.</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>发现一个点可以被查到，那么它一定没有兄弟，否则这些点一定都一起出现，无法区分。</p>
<ol type="1">
<li><p>如果点 <span class="math inline">\(x\)</span> 的子树大小大于等于 <span class="math inline">\(k+1\)</span>，那么它可以用父亲子树-自己子树得到对应权值；</p></li>
<li><p>如果点 <span class="math inline">\(x\)</span> 的子树大小小于等于 <span class="math inline">\(k\)</span>，那么它和它子树中的点一定同时出现，当且仅当 <span class="math inline">\(x\)</span> 是叶子才能被区分；</p>
<p>这时求它的权值一定是其父亲的父亲的子树和减去他的所有儿子再减去它的其他儿子的子树，于是要求：</p>
<ul>
<li><span class="math inline">\(x\)</span> 是叶子；</li>
<li><span class="math inline">\(x\)</span> 没有兄弟；</li>
<li><span class="math inline">\(x\)</span> 父亲的父亲至少有 <span class="math inline">\(k\)</span> 个儿子；</li>
<li><span class="math inline">\(x\)</span> 父亲的父亲的其他子树要么是叶子，要么子树大小不小于 <span class="math inline">\(k+1\)</span>；</li>
</ul></li>
</ol>
<p>考虑设计 DP，设 <span class="math inline">\(f_x\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树（不包括自己）可以得到的最大数量；</p>
<p>对于情况 1.，如果存在一个儿子 <span class="math inline">\(v\)</span> 的子树大小不小于 <span class="math inline">\(k+1\)</span>，那么考虑用 <span class="math inline">\(f_v+1\)</span> 更新；</p>
<p>对于情况 2.，需要有一个子树大小小于等于 <span class="math inline">\(k\)</span> 的儿子，且 <span class="math inline">\(x\)</span> 有大于等于 <span class="math inline">\(k\)</span> 个儿子，可以将它删成子树大小为 <span class="math inline">\(2\)</span>，那么可以将所有子树大小不足 <span class="math inline">\(k+1\)</span> 的儿子删为叶子，那么此时可以用所有儿子的 <span class="math inline">\(f\)</span> 之和加 <span class="math inline">\(1\)</span> 进行更新。</p>
<p>时间复杂度为 <span class="math inline">\(O(n)\)</span>.</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, k, head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>), f[N], siz[N], son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>; son[x] = <span class="number">0</span>, f[x] = <span class="number">0</span>; <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="built_in">get_ans</span>(e[i].v); f[x] += f[e[i].v];</span><br><span class="line">        siz[x] += siz[e[i].v]; ++ son[x];</span><br><span class="line">        <span class="keyword">if</span> (!f[e[i].v] &amp;&amp; siz[e[i].v] &gt; <span class="number">1</span>) t = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x] &gt;= k &amp;&amp; t) ++ f[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (siz[e[i].v] &gt;= k + <span class="number">1</span>)</span><br><span class="line">        f[x] = <span class="built_in">max</span>(f[x], f[e[i].v] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        ecnt = <span class="number">1</span>; <span class="built_in">mset</span>(head, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">read</span>(n), <span class="built_in">read</span>(k); <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="built_in">read</span>(x), <span class="built_in">add_edge</span>(x, i);</span><br><span class="line">        <span class="built_in">get_ans</span>(<span class="number">1</span>); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-多项式题">#T4 多项式题</h2>
<blockquote>
<p>诈骗题，虽然题名叫“多项式题”，但与多项式一点关系也没有。</p>
</blockquote>
<h3 id="题意简述-3">#题意简述</h3>
<p>给定一个长度为 <span class="math inline">\(n(n\leq2\times10^5)\)</span> 的数串，可以划分为任意段，每一段可以看作一个十进制数，每种划分的价值是所有段上的数之积。问所有划分的积之和。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>设 <span class="math inline">\(f_i\)</span> 表示将前 <span class="math inline">\(i\)</span> 位划分为若干段的价值和，根据乘法分配律可得 <span class="math display">\[
f_i=\sum\limits_{j=0}^{i-1}val_{j+1,i}\cdot f_j,
\]</span> 直接计算时间复杂度为 <span class="math inline">\(O(n^2)\)</span>，考虑优化。 <span class="math display">\[
\begin{aligned}
f_i=&amp;\sum\limits_{j=0}^{i-1}(Val_i-Val_j\cdot10^{i-j})f_j\\
=&amp;Val_i\sum\limits_{j=0}^{i-1}f_j-10^i\sum\limits_{j=0}^{i-1}10^{-j}\cdot Val_j\cdot f_j\\
=&amp;Val_i\cdot g_{i-1}-10^i\cdot h_{i-1},\\
g_i=&amp;g_{i-1}+f_i,\\
h_i=&amp;h_{i-1}+10^{-i}\cdot Val_i\cdot f_i.
\end{aligned}
\]</span> 其中 <span class="math inline">\(f,g,h\)</span> 都可以线性维护，于是时间复杂度为 <span class="math inline">\(O(n)\)</span>.</p>
<p>由于我对逆元的了解不深，所以预处理逆元的时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>，不过正解好像可以做到整体 <span class="math inline">\(O(n)\)</span>.</p>
<p>群里某位大佬的思路：</p>
<p><img src="https://pic.imgdb.cn/item/616545882ab3f51d91ea95dd.png" /></p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n; ll val[N], b[N], inv[N], f[N], h[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) (res *= x) %= MOD;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>, (x *= x) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s); b[<span class="number">0</span>] = f[<span class="number">0</span>] = g[<span class="number">0</span>] = <span class="number">1</span>, val[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      val[i] = (val[i - <span class="number">1</span>] * <span class="number">10</span> % MOD + s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) b[i] = b[i - <span class="number">1</span>] * <span class="number">10</span> % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) inv[i] = <span class="built_in">fpow</span>(b[i], MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        f[i] = (val[i] * g[i - <span class="number">1</span>] % MOD - b[i] * h[i - <span class="number">1</span>] % MOD + MOD) % MOD;</span><br><span class="line">        g[i] = (g[i - <span class="number">1</span>] + f[i]) % MOD;</span><br><span class="line">        h[i] = (h[i - <span class="number">1</span>] + val[i] * f[i] % MOD * inv[i] % MOD) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-CSP7连-DAY6 总结</title>
    <url>/2021/10/10/ZROI-21-CSP-DAY6/</url>
    <content><![CDATA[<h2 id="t1-聚会">#T1 聚会</h2>
<h3 id="题意简述">#题意简述</h3>
<p>给定一个长度为 <span class="math inline">\(n(n\leq5\times10^5)\)</span> 的 01 串，一个位置 <span class="math inline">\(x\)</span> 的价值为 <span class="math inline">\(x\)</span> 到离它最近 1 的距离，问价值和。多组数据。</p>
<h3 id="大体思路">#大体思路</h3>
<p>从两个方向分别扫一遍即可。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> t, n, a[N]; ll f[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, i);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s); ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">          a[i + <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ll lst = -INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]) lst = i;</span><br><span class="line">            f[i] = <span class="built_in">min</span>(f[i], (ll)i - lst);</span><br><span class="line">        &#125;</span><br><span class="line">        lst = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]) lst = i;</span><br><span class="line">            f[i] = <span class="built_in">min</span>(f[i], lst - (ll)i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          ans += f[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-跳房子">#T2 跳房子</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>一个长为 <span class="math inline">\(n(n\leq1000)\)</span> 的严格递增的序列 <span class="math inline">\(\{x_i\}(x_i\leq10^{18})\)</span>，当且仅当 <span class="math inline">\(i&lt;j\)</span> 且 <span class="math inline">\(x_i|x_j\)</span> 时由 <span class="math inline">\(i\)</span> 向 <span class="math inline">\(j\)</span> 连边，得到一个有向无环图，每条边边可以染成三种不同的颜色，要求不允许出现连续的长度大于 <span class="math inline">\(3\)</span> 的相同颜色的边出现，输出染色方案。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>定义函数 <span class="math inline">\(f(x)\)</span>，有 <span class="math inline">\(2^{f(x)}\leq x&lt;2^{f(x)+1}\)</span>，按如下方式进行染色：</p>
<ul>
<li>如果有 <span class="math inline">\(\left\lfloor\dfrac {f(x_i)} 4\right\rfloor=\left\lfloor\dfrac {f(x_j)} 4\right\rfloor\)</span>，那么将 <span class="math inline">\(i\to j\)</span> 标为 <span class="math inline">\(1\)</span>；</li>
<li>如果有 <span class="math inline">\(\left\lfloor\dfrac {f(x_i)} {16}\right\rfloor=\left\lfloor\dfrac {f(x_j)} {16}\right\rfloor\)</span>，那么将 <span class="math inline">\(i\to j\)</span> 标为 <span class="math inline">\(2\)</span>；</li>
<li>其余的标为 <span class="math inline">\(3\)</span>。</li>
</ul>
<p>正确性从二进制考虑，显然这样分，就是每四位分为一小组，每四小组分为一大组，总共 <span class="math inline">\(4\)</span> 大组，每一小组内的最长路径经过不超过 <span class="math inline">\(4\)</span> 个点，同样的，最长的、将四个大组全部相连的路径长度不超过 <span class="math inline">\(3\)</span>。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, f[N], x[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[a] / <span class="number">4</span> == f[b] / <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f[a] / <span class="number">16</span> == f[b] / <span class="number">16</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(x[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1ll</span> &lt;&lt; f[i]) &lt;= x[i]) ++ f[i];</span><br><span class="line">        -- f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">calc</span>(j, i));</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-人结">#T3 人结</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>圆上有 <span class="math inline">\(n(3\leq n\leq500)\)</span> 个点，顺时针编号为 <span class="math inline">\(1,2,\dots,n\)</span>，每个点与两个点相连，要求通过移动点在圆上的位置，使得最终的边没有交叉的<strong>一个</strong>环。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>注意到当且仅当原图不联通时无解；而当有解时最终得到的环的形态是唯一的，又注意到操作的可逆性，于是转化为将一个 <span class="math inline">\(n\)</span>-排列环变成顺时针方向为 <span class="math inline">\(1,2,\dots,n\)</span> 的环。</p>
<p>考虑复制一遍断环为链，然后为保证次数最少，一定是一次就把一个不在自己位置上的数放到自己位置上，于是就变为在 <span class="math inline">\(2n\)</span> 长度的序列上选中长度为 <span class="math inline">\(n\)</span> 的段，求这一段的最长上升子序列长度，取最大值即可。</p>
<p>由于不能保证最开始得到的环是顺时针方向，所以需要反转后在求一遍。时间复杂度 <span class="math inline">\(O(n^2\log n)\)</span>.</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>), vis[N], tot, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ring</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>; a[++ tot] = x; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (!vis[e[i].v]) <span class="built_in">get_ring</span>(e[i].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(t, l, x) lower_bound(t + 1, t + l + 1, x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[N], st[N], stp; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i + n] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">mset</span>(f, <span class="number">0</span>); <span class="built_in">mset</span>(st, <span class="number">0</span>); stp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= i + n - <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; st[stp]) st[++ stp] = a[j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="built_in">lb</span>(st, stp, a[j]) - st;</span><br><span class="line">                st[pos] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            f[j - i + <span class="number">1</span>] = stp;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">Max</span>(ans, f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">read</span>(n); <span class="keyword">if</span> (!n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">mset</span>(head, <span class="number">0</span>); ecnt = <span class="number">1</span>, tot = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y; <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">            <span class="built_in">add_edge</span>(i, x); <span class="built_in">add_edge</span>(i, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">mset</span>(vis, <span class="number">0</span>); <span class="built_in">mset</span>(a, <span class="number">0</span>); <span class="built_in">get_ring</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tot != n) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Not solvable.\n&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Knot solvable.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">get_ans</span>(); <span class="built_in">reverse</span>(a + <span class="number">2</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">get_ans</span>(); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-辣椒">#T4 辣椒</h2>
<h3 id="题意简述-3">#题意简述</h3>
<p>将一棵 <span class="math inline">\(n(n\leq2\times10^5)\)</span> 个点的树通过断掉两条边变为三部分，定义差值为三部分中的最大大小减去最小大小，求最小差值。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>先来考虑 <span class="math inline">\(O(n^2)\)</span> 做法，即枚举两个点 <span class="math inline">\(x,y\)</span>，表示将这两个点向父亲的边断掉，则三部分的大小有以下两种情况（记 <span class="math inline">\(siz_x\)</span> 为以 <span class="math inline">\(x\)</span> 为根的子树大小）：</p>
<ul>
<li><span class="math inline">\(y\)</span> 是 <span class="math inline">\(x\)</span> 的祖先，那么大小分别为 <span class="math inline">\(siz_x,siz_y-siz_x,n-siz_y\)</span>；</li>
<li><span class="math inline">\(y\)</span> 与 <span class="math inline">\(x\)</span> 无祖孙关系，那么大小分别为 <span class="math inline">\(siz_x,siz_y,n-siz_x-siz_y\)</span>；</li>
</ul>
<p>直接进行维护即可。</p>
<p>来考虑优化，假如当前选择的点为 <span class="math inline">\(x\)</span>，那么考虑从根到 <span class="math inline">\(x\)</span> 路径上的点，需要在其中找到一个点 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(|siz_y-\dfrac{n+siz_x}2|\)</span> 最小，这个点集可以用 <code>set</code> 维护，然后直接 <code>lower_bound()</code> 查找即可，当从某个点向下深入时需要将该点加入该集合；</p>
<p>同样的，维护一个已经处理过但不是 <span class="math inline">\(x\)</span> 的祖先的点集，需要在其中找到一个点 <span class="math inline">\(y\)</span> 使得 <span class="math inline">\(|siz_y-\dfrac{n-siz_x}2|\)</span> 尽可能小，同样可用 <code>set</code> 维护，注意当从一个点退出时，需要将该点从直系集合中取出，加入旁系集合。</p>
<p>时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">abs</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>), siz[N], ans = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Max</span>(x, <span class="built_in">Max</span>(y, z)) - <span class="built_in">Min</span>(x, <span class="built_in">Min</span>(y, z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">get_size</span>(e[i].v, x);</span><br><span class="line">        siz[x] += siz[e[i].v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set &lt;<span class="keyword">int</span>&gt; lineal, colla, neg_lineal, neg_colla;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lineal.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = *lineal.<span class="built_in">lower_bound</span>((n + siz[x]) / <span class="number">2</span>);</span><br><span class="line">        ans = <span class="built_in">Min</span>(ans, <span class="built_in">calc</span>(n - pos, siz[x], pos - siz[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!colla.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = *colla.<span class="built_in">lower_bound</span>((n - siz[x]) / <span class="number">2</span>);</span><br><span class="line">        ans = <span class="built_in">Min</span>(ans, <span class="built_in">calc</span>(siz[x], pos, n - siz[x] - pos));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!neg_lineal.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = -(*neg_lineal.<span class="built_in">lower_bound</span>(-(n + siz[x]) / <span class="number">2</span>));</span><br><span class="line">        ans = <span class="built_in">Min</span>(ans, <span class="built_in">calc</span>(n - pos, siz[x], pos - siz[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!neg_colla.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = -(*neg_colla.<span class="built_in">lower_bound</span>(-(n - siz[x]) / <span class="number">2</span>));</span><br><span class="line">        ans = <span class="built_in">Min</span>(ans, <span class="built_in">calc</span>(siz[x], pos, n - siz[x] - pos));</span><br><span class="line">    &#125;</span><br><span class="line">    lineal.<span class="built_in">insert</span>(siz[x]); neg_lineal.<span class="built_in">insert</span>(-siz[x]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (e[i].v != f) <span class="built_in">solve</span>(e[i].v, x);</span><br><span class="line">    lineal.<span class="built_in">erase</span>(siz[x]); neg_lineal.<span class="built_in">erase</span>(-siz[x]);</span><br><span class="line">    colla.<span class="built_in">insert</span>(siz[x]); neg_colla.<span class="built_in">insert</span>(-siz[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v); <span class="built_in">add_edge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_size</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">solve</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-十一集训-赠送赛 总结</title>
    <url>/2021/10/09/ZROI-21-1001-EXTRA/</url>
    <content><![CDATA[<h2 id="t1-有趣的数">#T1 有趣的数</h2>
<h3 id="题意简述">#题意简述</h3>
<p>定义一个整数 <span class="math inline">\(N\)</span> 是有趣的，当且仅当 <span class="math inline">\(N\)</span> 满足：</p>
<ul>
<li><span class="math inline">\(0\leq N\leq10^{18}\)</span>；</li>
<li>在 <span class="math inline">\(B_1\)</span> 进制下有 <span class="math inline">\(K_1\)</span> 位，在 <span class="math inline">\(B_2\)</span> 进制下有 <span class="math inline">\(K_2\)</span> 位；</li>
</ul>
<p>其中 <span class="math inline">\(2\leq B_1,B_2\leq100\)</span>，<span class="math inline">\(1\leq K_1,K_2\leq20\)</span>。</p>
<h3 id="大体思路">#大体思路</h3>
<p>不难发现在 <span class="math inline">\(B_1,K_1\)</span> 给定的情况下，可能的有趣的数是一个区间，上下界可以用快速幂得到，<span class="math inline">\(B_2,K_2\)</span> 同理，于是求区间交即可。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll LMT = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">ll b1, d1, b2, d2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_limit</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res *= a;</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= LMT + <span class="number">1</span> || res &lt;= <span class="number">0</span>) <span class="keyword">return</span> LMT + <span class="number">1</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; <span class="keyword">if</span> (b) a *= a;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= LMT + <span class="number">1</span> || a &lt;= <span class="number">0</span>) <span class="keyword">return</span> LMT + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;b1, &amp;d1, &amp;b2, &amp;d2);</span><br><span class="line">    ll ul1 = <span class="built_in">get_limit</span>(b1, d1);</span><br><span class="line">    ll ll1 = <span class="built_in">get_limit</span>(b1, d1 - <span class="number">1</span>);</span><br><span class="line">    ll ul2 = <span class="built_in">get_limit</span>(b2, d2);</span><br><span class="line">    ll ll2 = <span class="built_in">get_limit</span>(b2, d2 - <span class="number">1</span>);</span><br><span class="line">    ll ul = <span class="built_in">min</span>(ul1, ul2), lo = <span class="built_in">max</span>(ll1, ll2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ul &gt; lo ? ul - lo : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-木棒">#T2 木棒</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定十二根木棒的长度 <span class="math inline">\(l_i(l_i\leq10^9)\)</span>，问最多能同时得到多少个三角形。</p>
<p>多组数据，数组组数 <span class="math inline">\(t\)</span> 满足 <span class="math inline">\(1\leq t\leq6000.\)</span></p>
<h3 id="大体思路-1">#大体思路</h3>
<p>发现选择状态数极少，可以考虑状压 DP，但是直接转移颇具难度，考虑用更加容易理解的记忆化搜索。</p>
<p>每次找到一个最短的、未被考虑的木棍，他只有两种选择：</p>
<ul>
<li>丢掉；</li>
<li>再找两根与其配对；</li>
</ul>
<p>进行记忆化搜索即可。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> init_S = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, T, l[N], f[(<span class="number">1</span> &lt;&lt; N) + <span class="number">10</span>], vis[(<span class="number">1</span> &lt;&lt; N) + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[S] == T || !S) <span class="keyword">return</span> f[S];</span><br><span class="line">    <span class="keyword">int</span> now; f[S] = <span class="number">0</span>, vis[S] = T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line">      <span class="keyword">if</span> ((S &gt;&gt; i) &amp; <span class="number">1</span>) &#123;now = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">    f[S] = <span class="built_in">dfs</span>(S ^ (<span class="number">1</span> &lt;&lt; now));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = now + <span class="number">1</span>; i &lt; N; ++ i) <span class="keyword">if</span> ((S &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; ++ j) <span class="keyword">if</span> ((S &gt;&gt; j) &amp; <span class="number">1</span> &amp;&amp; l[now] + l[i] &gt; l[j])</span><br><span class="line">        f[S] = <span class="built_in">max</span>(f[S], <span class="built_in">dfs</span>(S ^ (<span class="number">1</span> &lt;&lt; now) ^ (<span class="number">1</span> &lt;&lt; i) ^ (<span class="number">1</span> &lt;&lt; j)) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f[S];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">for</span> (T = <span class="number">1</span>; T &lt;= t; ++ T) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i) <span class="built_in">read</span>(l[i]);</span><br><span class="line">        <span class="built_in">sort</span>(l, l + N); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dfs</span>(init_S));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-装饰">#T3 装饰</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>一棵 <span class="math inline">\(n(n\leq10^5)\)</span> 个节点、以 <span class="math inline">\(1\)</span> 为根的树，每个节点上有两个参数 <span class="math inline">\(c_i,t_i\)</span>，分别表示以 <span class="math inline">\(i\)</span> 为根的子树中至少被选择 <span class="math inline">\(c_i(1\leq c_i\leq10^7)\)</span> 次，节点 <span class="math inline">\(i\)</span> 被选一次的代价是 <span class="math inline">\(t_i(1\leq t_i\leq100)\)</span>，求最小总代价。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>考虑如果一棵子树上当前所选的数量不足，为了代价最小，应当选择整棵子树上代价最小的节点，按此思路进行树上 DP（树上贪心？）即可。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,<span class="built_in">ecnt</span>(<span class="number">1</span>), head[N], siz[N];</span><br><span class="line">ll c[N], t[N], mn[N], f[N], tot[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nowtot = <span class="number">0</span>; siz[x] = <span class="number">1</span>, mn[x] = t[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="built_in">solve</span>(e[i].v); siz[x] += siz[e[i].v];</span><br><span class="line">        tot[x] += tot[e[i].v]; f[x] += f[e[i].v];</span><br><span class="line">        mn[x] = <span class="built_in">Min</span>(mn[x], mn[e[i].v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tot[x] &lt; c[x]) &#123;f[x] += mn[x] * (c[x] - tot[x]), tot[x] = c[x];&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>, &amp;x, &amp;c[i], &amp;t[i]);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="built_in">add_edge</span>(x, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>); <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-翻转硬币">#T4 翻转硬币</h2>
<h3 id="题意简述-3">#题意简述</h3>
<p>一个长度为 <span class="math inline">\(n(n\leq300)\)</span> 的 01 串 <span class="math inline">\(s\)</span>，给定参数 <span class="math inline">\(m(1\leq m\leq n)\)</span>，要求通过以下两种操作：</p>
<ul>
<li>将一个位置取反；</li>
<li>将前 <span class="math inline">\(k\cdot m(k\in Z)\)</span> 位取反（若 <span class="math inline">\(k\cdot m&gt;n\)</span> 则整体取反）；</li>
</ul>
<p>使得 <span class="math inline">\(s\)</span> 最终满足 <span class="math inline">\(s_1=s_{m+1},s_2=s_{m+2},\dots,s_{n-m}=s_{n}\)</span>，问最小操作数。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>注意到一个位置单个、整体各最多被取反一次，否则没有意义。</p>
<p>通过简单画图不难发现，最终状态满足将原串从头开始划分为长度为 <span class="math inline">\(m\)</span> 的 <span class="math inline">\(\left\lceil\dfrac n m\right\rceil\)</span> 小段（最后一段长度可能小于 <span class="math inline">\(m\)</span>），其中前 <span class="math inline">\(\left\lfloor\dfrac {n - m} m\right\rfloor\)</span> 段的每一段都相等，最后一点不足 <span class="math inline">\(m\)</span> 的小段也与完整的小段的前部对应相等。</p>
<p>当 <span class="math inline">\(m&gt;\sqrt n\)</span> 时，段数极少，极限数据下不超过 <span class="math inline">\(17\)</span> 段，于是可以考虑枚举每一段是否被翻转，然后贪心地考虑每一位选什么直接统计。</p>
<p>否则，考虑枚举每一段是什么样子，然后 DP 即可，每次转移的时候贪心地选择这一段是否要翻转即可。</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ca[N];</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], id[N], sub[N][<span class="number">2</span>], bcnt, f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) id[i] = (i - <span class="number">1</span>) / m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id[n]; ++ i)</span><br><span class="line">      sub[i][<span class="number">0</span>] = (i - <span class="number">1</span>) * m + <span class="number">1</span>, sub[i][<span class="number">1</span>] = i * m;</span><br><span class="line">    sub[id[n]][<span class="number">1</span>] = <span class="built_in">min</span>(sub[id[n]][<span class="number">1</span>], n); bcnt = id[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bitcnt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="keyword">while</span> (x) x -= x &amp; (-x), ++ cnt; <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; bcnt; ++ s) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, lst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bcnt; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">          <span class="keyword">if</span> ((s &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span> != lst) ++ cnt, lst ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c[<span class="number">2</span>]; c[<span class="number">0</span>] = c[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += m)</span><br><span class="line">              ++ c[a[j] ^ (s &gt;&gt; (id[j] - <span class="number">1</span>)) &amp; <span class="number">1</span>];</span><br><span class="line">            cnt += <span class="built_in">min</span>(c[<span class="number">0</span>], c[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">min</span>(res, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; m; ++ s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bcnt; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt[<span class="number">2</span>]; cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sub[i][<span class="number">0</span>]; j &lt;= sub[i][<span class="number">1</span>]; ++ j)</span><br><span class="line">              ++ cnt[a[j] ^ (s &gt;&gt; (j - sub[i][<span class="number">0</span>]) &amp; <span class="number">1</span>)];</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][<span class="number">0</span>] + cnt[<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">1</span>] + cnt[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][<span class="number">1</span>] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][<span class="number">1</span>] + cnt[<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">0</span>] + cnt[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">min</span>(f[bcnt][<span class="number">0</span>], f[bcnt][<span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ca); n = <span class="built_in">strlen</span>(ca); <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) a[i + <span class="number">1</span>] = ca[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">divide</span>(); <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, m &gt; <span class="built_in">sqrt</span>(n) ? <span class="built_in">solve_1</span>() : <span class="built_in">solve_2</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-CSP7连-DAY5 总结</title>
    <url>/2021/09/27/ZROI-21-CSP-DAY5/</url>
    <content><![CDATA[<h2 id="t1-游戏">#T1 游戏</h2>
<h3 id="题意简述">#题意简述</h3>
<p>给定 <span class="math inline">\(n(n\leq10^{100000})\)</span>，输出将 <span class="math inline">\(n\)</span> 的数位重排列可以得到的最大的 <span class="math inline">\(30\)</span> 的倍数。</p>
<h3 id="大体思路">#大体思路</h3>
<p>直接判有没有 <span class="math inline">\(0\)</span>、可不可以被 <span class="math inline">\(3\)</span> 整除，若可以，直接排序即可。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n, cnt, sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">      sum += s[i] - <span class="string">&#x27;0&#x27;</span>, cnt += (s[i] == <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!cnt || sum % <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">sort</span>(s, s + n, cmp), <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-排列">#T2 排列</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定一个 <span class="math inline">\(1\dots n(n\leq10^4)\)</span> 的排列 <span class="math inline">\(P\)</span>，问对于 <span class="math inline">\(x\in[1,n]\)</span>，<span class="math inline">\(P\)</span> 是否是 <span class="math inline">\(x\)</span>-排列，用长度为 <span class="math inline">\(n\)</span> 的 01 串表示答案。</p>
<p>定义一个排列 <span class="math inline">\(P\)</span> 为 <span class="math inline">\(m\)</span>-排列当且仅当存在一个长度为 <span class="math inline">\(m\)</span> 的子段 <span class="math inline">\(Q\)</span>，<span class="math inline">\(\forall x\in[1,m]\)</span>，有 <span class="math inline">\(x\in Q\)</span>.</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>考虑 <span class="math inline">\(P\)</span> 一定是 <span class="math inline">\(1\)</span>-排列，注意到如果 <span class="math inline">\(P\)</span> 是 <span class="math inline">\(x\)</span>-排列，对应的子段为 <span class="math inline">\(Q_1\)</span>，那么如果 <span class="math inline">\(P\)</span> 是 <span class="math inline">\((x+1)\)</span>-排列，对应子段为 <span class="math inline">\(Q_2\)</span>，那么一定有 <span class="math inline">\(Q_1\subset Q_2\)</span>，所以可以考虑枚举 <span class="math inline">\(x\)</span>，用双指针维护 <span class="math inline">\(Q\)</span>，每次考虑当前 <span class="math inline">\(|Q|\)</span> 是否等于 <span class="math inline">\(x\)</span> 得到答案。时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], ans[N], pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span>) pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = pos, r = pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; <span class="number">1</span> &amp;&amp; a[l - <span class="number">1</span>] &lt;= i) -- l;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; a[r + <span class="number">1</span>] &lt;= i) ++ r;</span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt;= i) ans[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-照明">#T3 照明</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>给定一张 <span class="math inline">\(n(n\leq5\times10^4)\)</span> 个点 <span class="math inline">\(m(m\leq2\times10^5)\)</span> 条边的有向无环图，可以将每条边任意染成 <code>R</code>、<code>G</code>、 <code>B</code> 三种颜色。要求不允许出现一条长度大于等于 <span class="math inline">\(42\)</span> 的路径颜色相同，给出一种染色方案。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>一道挺有意思的构造题。注意到 <span class="math inline">\(42^3&gt;5\times10^4\)</span>，于是我们将所有点按照拓扑序排序，将连续的 <span class="math inline">\(42\)</span> 个点分为一小组，<span class="math inline">\(42\)</span> 个连续的小组分为一大组，每一小组中任意两点之间的边染为 <code>R</code>，在同一大组中但不在同一小组的点之间的边染 <code>G</code>，将大组与大组之间的边染 <code>B</code>，由于每一小组中的最长路径小于等于 <span class="math inline">\(41\)</span>，每一大组中的最长相同颜色路径长度小于等于 <span class="math inline">\(41\)</span>，大组的数量一定小于 <span class="math inline">\(42\)</span>，所以构造得到的边的颜色一定满足题意。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N], ae[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ecnt</span><span class="params">(<span class="number">1</span>)</span>, icnt[N], head[N]</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v, ++ icnt[v];</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q[N], frt, tal, T1, T2, T3, type[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Use topo to divide the node to different groups.*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    frt = <span class="number">0</span>, tal = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (!icnt[i]) q[++ tal] = i;</span><br><span class="line">    <span class="keyword">while</span> (frt &lt;= tal) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q[frt ++]; (++ T1) %= <span class="number">42</span>;</span><br><span class="line">        <span class="keyword">if</span> (T1 % <span class="number">42</span> == <span class="number">1</span>) ++ T2; <span class="keyword">if</span> (T2 % <span class="number">42</span> == <span class="number">1</span>) ++ T3;</span><br><span class="line">        type[now][<span class="number">2</span>] = T3, type[now][<span class="number">1</span>] = T2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = e[i].nxt)</span><br><span class="line">          <span class="keyword">if</span> (!(-- icnt[e[i].v])) q[++ tal] = e[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;ae[i].u, &amp;ae[i].v);</span><br><span class="line">        <span class="built_in">add_edge</span>(ae[i].u, ae[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = ae[i].u, v = ae[i].v;</span><br><span class="line">        <span class="keyword">if</span> (type[u][<span class="number">1</span>] == type[v][<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">&quot;R\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type[u][<span class="number">2</span>] == type[v][<span class="number">2</span>]) <span class="built_in">printf</span>(<span class="string">&quot;G\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;B\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-相交">#T4 相交</h2>
<blockquote>
<p>期望得分 <span class="math inline">\(30pts\)</span> 的 <span class="math inline">\(O(n^4)\)</span> 做法可拿到 <span class="math inline">\(95pts\)</span>（你永远可以相信蟹老板的数据.jpg</p>
</blockquote>
<h3 id="题意简述-3">#题意简述</h3>
<p>给定平面直角坐标系中 <span class="math inline">\(n(n\leq10^3)\)</span> 个点的坐标 <span class="math inline">\((x_i,y_i)(-10^9\leq x_i,y_i\leq10^9)\)</span>，保证不存在三点共线，问有多少条线段不与其他任意一条线段相交（端点相同不算相交）。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>首先，发现合法的边即是在所有点形成的封闭图形（可能是凹多边形）的所有三角剖分中都出现的边，于是直接通过加边维护，随意求出一组三角剖分的时间复杂度为 <span class="math inline">\(O(n^3)\)</span>，再依次判断每条边是否可行的时间复杂度为 <span class="math inline">\(O(n^3)\)</span>，不可接受。</p>
<p>先考虑优化求得三角剖分的过程。首先我们可以先得到整张图的凸包，通过向对角线连边得到最初的三角形集合，再用不在凸包边界上的点将已有的三角形进行分割得到完整的三角剖分。维护凸包的时间复杂度是 <span class="math inline">\(O(n^2)\)</span> 的（当然也可以做到 <span class="math inline">\(O(n\log n)\)</span>，初始三角形的个数是 <span class="math inline">\(O(n)\)</span> 级别的，于是分割三角形的时间复杂度也可以做到 <span class="math inline">\(O(n^2)\)</span>，总体时间复杂度是 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>然后来优化判定相交的部分。考虑一个线段 <span class="math inline">\(PQ\)</span>，不失一般性地假设直线 <span class="math inline">\(PQ\)</span> 是垂直的，且 <span class="math inline">\(P\)</span> 在 <span class="math inline">\(Q\)</span> 之上，将所有其他点分为 <span class="math inline">\(A,B\)</span> 两个集合，其中对于 <span class="math inline">\(A_i\in A\)</span>，都在 <span class="math inline">\(PQ\)</span> 左部，按 <span class="math inline">\(\angle A_iPQ\)</span> 降序排序，对于 <span class="math inline">\(B_i\in B\)</span>，都在 <span class="math inline">\(PQ\)</span> 右部，按 <span class="math inline">\(\angle PQB_i\)</span> 降序排序。</p>
<p>对于某个点 <span class="math inline">\(A_i\)</span>，令 <span class="math inline">\(f(i)\)</span> 表示最大的 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(\angle A_iPB_j&lt;\pi\)</span>（如果存在），显然这样的 <span class="math inline">\(f(i)\)</span> 是非严格递增的，可以通过双指针得到。令 <span class="math inline">\(g(j)\)</span> 表示按 <span class="math inline">\(\angle PQB_j\)</span> 降序排序后 <span class="math inline">\(B_j\)</span> 的新的编号。</p>
<p>我们发现，如果 <span class="math inline">\(\exists j&#39;\)</span> 使得 <span class="math inline">\(PQ\)</span> 与 <span class="math inline">\(A_iB_{j&#39;}\)</span> 相交，那么 <span class="math inline">\(A_iB_{j&#39;}\)</span> 一定在直线 <span class="math inline">\(A_iP\)</span> 之下，<span class="math inline">\(A_{i}Q\)</span> 之上，于是令 <span class="math inline">\(j&#39;=\arg\max_{1\leq j\leq f(i)}g(j)\)</span>，显然如果 <span class="math inline">\(A_iB_{j&#39;}\)</span> 与 <span class="math inline">\(PQ\)</span> 都没有交点，显然不会再有任何一条 <span class="math inline">\(A_iB_j\)</span> 与 <span class="math inline">\(PQ\)</span> 相交了。排序、求出 <span class="math inline">\(g(j)\)</span> 的时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>，所以总体时间复杂度为 <span class="math inline">\(O(n^2\log n)\)</span>.</p>
<h3 id="亿些细节">#亿些细节</h3>
<p>这里介绍一个很有用的函数 <span class="math inline">\(ccw(A,B,C)\)</span>，并说明如何用它来解决上面大部分的比较和判断。<span class="math inline">\(ccw\)</span> 的定义如下： <span class="math display">\[
ccw(A,B,C)=x_A\cdot(y_B-y_C)+x_B\cdot(y_C-y_A)+x_C\cdot(y_A-y_B),
\]</span> 于是我们不难发现，当 <span class="math inline">\(A,B,C\)</span> 在平面中是逆时针顺序排列时，<span class="math inline">\(sign(ccw(A,B,C))=1\)</span>，如果为顺时针排列则有 <span class="math inline">\(sign(ccw(A,B,C))=-1\)</span>（<span class="math inline">\(sign(x)\)</span> 表示取符号），利用这条性质，可以直接解决很多判断和比较。</p>
<ol type="1">
<li>判断两线段相交；</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/6151bd492ab3f51d91b01ad4.jpg" /></p>
<p>不难发现应当有 <span class="math inline">\(ccw(A,B,C)&gt;0,ccw(A,B,D)&lt;0\)</span> 以及 <span class="math inline">\(ccw(C,D,A)&lt;0,ccw(C,D,B)&gt;0\)</span>，于是可以直接判断。</p>
<ol start="2" type="1">
<li>维护凸包；</li>
</ol>
<p>发现凸包边界从最左下角 <span class="math inline">\(P_0\)</span> 开始顺时针方向应当有任意边界点 <span class="math inline">\(ccw(P_0,P_x,P_{x+k})&lt;0(k&gt;0)\)</span>，如果有一点使得 <span class="math inline">\(ccw&gt;0\)</span>，那么一定不在凸包边界上；</p>
<ol start="3" type="1">
<li>判断在三角形三边同侧；</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/6151bf152ab3f51d91b277de.jpg" /></p>
<p>如图，当 <span class="math inline">\(D\)</span> 在 <span class="math inline">\(\Delta ABC\)</span> 内部时，应当有 <span class="math display">\[
\begin{cases}
ccw(D,A,C)&gt;0,\\
ccw(D,C,B)&gt;0,\\
ccw(D,B,A)&gt;0,
\end{cases}
\]</span></p>
<ol start="4" type="1">
<li>按照角度大小排序；</li>
</ol>
<p>这一点在代码的 <code>cmp()</code> 中有体现，利用相对位置即可。</p>
<p><strong>更多细节见代码及注释</strong>。</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sign</span><span class="params">(T x)</span> </span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Traingle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Traingle &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a == x.a ? (b == x.b ? c &lt; x.c : b &lt; x.b) : a &lt; x.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line"></span><br><span class="line">    Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (Point)&#123;x - b.x, y - b.y&#125;;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (Point)&#123;x + b.x, y + b.y&#125;;&#125;</span><br><span class="line">    <span class="keyword">inline</span> ll <span class="keyword">operator</span> * (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125;</span><br><span class="line">    <span class="keyword">inline</span> ll <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x == b.x &amp;&amp; y == b.y;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x == b.x ? y &lt; b.y : x &lt; b.x;&#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CCW</span><span class="params">(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b, <span class="keyword">const</span> Point &amp;c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Sign</span>(a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">INTERSECT</span><span class="params">(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b, <span class="keyword">const</span> Point &amp;c, <span class="keyword">const</span> Point &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b || a == c || a == d || b == c || b == d || c == d) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CCW</span>(a, b, c) != <span class="built_in">CCW</span>(a, b, d) &amp;&amp; <span class="built_in">CCW</span>(c, d, a) != <span class="built_in">CCW</span>(c, d, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ccw</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">CCW</span>(p[i], p[j], p[k]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">intersect</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="keyword">int</span> o)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">INTERSECT</span>(p[i], p[j], p[k], p[o]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cmp_std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ccw</span>(cmp_std, a, b) == <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, on_border[N];</span><br><span class="line"></span><br><span class="line">vector &lt;pii &gt; edges;</span><br><span class="line">set &lt;Traingle&gt; traingles;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Find the convex hull, and get the initial traingles at the same time.*/</span></span><br><span class="line"><span class="comment">/*Notice: We have no necessary to save the convex hull, it&#x27;s useless.*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traingles_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = <span class="number">0</span>; <span class="keyword">if</span> (!lst) nxt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*If Starting from the initial point, all points on the boundary </span></span><br><span class="line"><span class="comment">          should be arranged in a clockwise direction.*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">ccw</span>(lst, nxt, i) == <span class="number">1</span>) nxt = i;</span><br><span class="line">        <span class="comment">/*Add the edge and the traingle to the set.*/</span></span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;lst, nxt&#125;);</span><br><span class="line">        <span class="keyword">if</span> (lst &amp;&amp; nxt) traingles.<span class="built_in">insert</span>(&#123;<span class="number">0</span>, nxt, lst&#125;);</span><br><span class="line">        on_border[lst] = <span class="literal">true</span>; lst = nxt;</span><br><span class="line">    &#125; <span class="keyword">while</span> (lst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Use the points which are not on the boundary to try to divide the traingles.*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traingles_divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (on_border[i]) <span class="keyword">continue</span>;</span><br><span class="line">        Traingle target;</span><br><span class="line">        <span class="comment">/*If the point is on the same side for all three sides of a triangle, </span></span><br><span class="line"><span class="comment">         * it must be included by this triangle. We use clockwise and counter-</span></span><br><span class="line"><span class="comment">         * clockwise directions to judge whether it is on the same side*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : traingles)</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">ccw</span>(it.a, it.b, i) == <span class="number">1</span> </span><br><span class="line">              &amp;&amp; <span class="built_in">ccw</span>(it.b, it.c, i) == <span class="number">1</span> </span><br><span class="line">              &amp;&amp; <span class="built_in">ccw</span>(it.c, it.a, i) == <span class="number">1</span>) &#123;</span><br><span class="line">              target = it; <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">/*After find the corresponding traingle, delete it from the set,</span></span><br><span class="line"><span class="comment">         * and add the new traingles and edges to the set.*/</span></span><br><span class="line">        traingles.<span class="built_in">erase</span>(target);</span><br><span class="line">        traingles.<span class="built_in">insert</span>(&#123;target.a, target.b, i&#125;);</span><br><span class="line">        traingles.<span class="built_in">insert</span>(&#123;target.b, target.c, i&#125;);</span><br><span class="line">        traingles.<span class="built_in">insert</span>(&#123;target.c, target.a, i&#125;);</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;i, target.a&#125;);</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;i, target.b&#125;);</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;i, target.c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e.first, v = e.second;</span><br><span class="line">        vector &lt;<span class="keyword">int</span>&gt; a, b; cmp_std = u;</span><br><span class="line">        <span class="comment">/*Divide the points to two groups.*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ccw</span>(u, v, i) == <span class="number">-1</span>) a.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ccw</span>(u, v, i) == +<span class="number">1</span>) b.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        vector &lt;<span class="keyword">int</span>&gt; c = b; cmp_std = v;</span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        vector &lt;<span class="keyword">int</span>&gt; <span class="built_in">pos</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)c.<span class="built_in">size</span>(); ++ i) pos[c[i]] = i;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/*use two-pointers to get the answer.*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)a.<span class="built_in">size</span>(); ++ i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; (<span class="keyword">int</span>)b.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">ccw</span>(a[i], u, b[j]) == <span class="number">-1</span>)</span><br><span class="line">              k = <span class="built_in">max</span>(k, pos[b[j]]), ++ j;</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="number">-1</span>) ok &amp;= !<span class="built_in">intersect</span>(u, v, a[i], c[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ok) ++ res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">read</span>(p[i].x), <span class="built_in">read</span>(p[i].y);</span><br><span class="line">    <span class="built_in">sort</span>(p, p + n); <span class="built_in">raingles_init</span>(); <span class="built_in">raingles_divide</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">get_ans</span>()); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-CSP7连-DAY4 总结</title>
    <url>/2021/09/23/ZROI-21-CSP-DAY4/</url>
    <content><![CDATA[<h2 id="t1-扫雷">#T1 扫雷</h2>
<h3 id="题意简述">#题意简述</h3>
<p>一个 <span class="math inline">\(n\times m(n,m\leq200)\)</span> 的网格，每个格子中的数字表示以该格子为中心的 <span class="math inline">\(3\times3\)</span> 的方格中地雷的数量，问总共有多少个地雷。</p>
<h3 id="大体思路">#大体思路</h3>
<p>我们不需要知道地雷具体怎么摆放，所以只要找到一组点各自的势力范围能恰好覆盖整张地图即可，于是我们可以直接上下、左右各相隔三个进行选点。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N][N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="comment">/*特别注意填充开始的边界*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n % <span class="number">3</span> ? <span class="number">1</span> : <span class="number">2</span>; i &lt;= n; i += <span class="number">3</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = m % <span class="number">3</span> ? <span class="number">1</span> : <span class="number">2</span>; j &lt;= m; j += <span class="number">3</span>)</span><br><span class="line">        ans += a[i][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-翻转">#T2 翻转</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>有一个 <span class="math inline">\(n\times m(n,m\leq100)\)</span> 的 01 矩阵，现在需要将所有位置变为 <span class="math inline">\(1\)</span>，改变的规则如下：</p>
<ul>
<li>对于 <span class="math inline">\((a,b)\)</span>，若 <span class="math inline">\(\exists x\in[1,n],y\in[1,m]\)</span>，其中 <span class="math inline">\((a,y),(x,b),(x,y)\)</span> 均为 <span class="math inline">\(1\)</span>，那么修改 <span class="math inline">\((a,b)\)</span> 的代价为 <span class="math inline">\(3\)</span>，否则为 <span class="math inline">\(4\)</span>.</li>
</ul>
<p>问最小代价。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>考虑如何判断是否 <span class="math inline">\(\exists x\in[1,n],y\in[1,m]\)</span>，其中 <span class="math inline">\((a,y),(x,b),(x,y)\)</span> 均为 <span class="math inline">\(1\)</span>，不难发现，如果将 <span class="math inline">\((i,j)=1\)</span> 看作将第 <span class="math inline">\(i\)</span> 行（<span class="math inline">\(L.i\)</span>）和第 <span class="math inline">\(j\)</span> 列（<span class="math inline">\(A.j\)</span>）连接的话，那么意味着 <span class="math inline">\(L.a,L.x,A.b,A.y\)</span> 应当在同一连通块内，而最终的状态一定有全图为一个连通块，于是我们一定需要将所有初始连通块连成一块，这需要以 <span class="math inline">\(4\)</span> 的代价修改连通块数量减 <span class="math inline">\(1\)</span> 个点，最后剩下的点的修改代价都为 <span class="math inline">\(3\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用并查集维护连通块信息*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> siz[N], f[N], tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        tot = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= x; ++ i)</span><br><span class="line">          f[i] = i, siz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) x = f[x] = f[f[x]];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (siz[x] &gt; siz[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        f[x] = y, siz[y] += siz[x], -- tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; dsu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, tcnt, ans; <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; dsu.<span class="built_in">init</span>(n + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">        cin &gt;&gt; c; <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) dsu.<span class="built_in">merge</span>(i, j + n), ++ tcnt;</span><br><span class="line">      &#125;</span><br><span class="line">    ans = (dsu.tot - <span class="number">1</span>) * <span class="number">4</span> + (n * m - tcnt - dsu.tot + <span class="number">1</span>) * <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; ans; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-斜率">#T3 斜率</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>平面直角坐标系上 <span class="math inline">\(n(n\leq10^6)\)</span> 个点，可任选 <span class="math inline">\(2\)</span> 个点连直线，找到斜率最接近 <span class="math inline">\(\frac P Q\)</span> 的直线的斜率。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>我们考虑有一条斜率为 <span class="math inline">\(\frac PQ\)</span> 的直线在坐标系上平移，我们可以得到所有点按此方向在 <span class="math inline">\(x\)</span> 轴上的投影，不难发现，斜率最接近 <span class="math inline">\(\frac PQ\)</span> 的两个点的投影一定相邻，这一点简单画图不难发现，于是我们直接按照投影位置进行排序即可。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> db INF = <span class="number">1e10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">ABS</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> </span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> tana, ans_gap = INF;</span><br><span class="line"><span class="keyword">int</span> n; ll p, q, nx, ny;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point &amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x * p + y * q &lt; -b.x * p + b.y * q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;<span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">calc</span><span class="params">(Point x, Point y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x == y.x ? INF : (db)(x.y - y.y) / (db)(x.x - y.x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>, &amp;n, &amp;p, &amp;q);</span><br><span class="line">    tana = (db)p / (db)q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        db now_gap = <span class="built_in">ABS</span>(<span class="built_in">calc</span>(a[i], a[i + <span class="number">1</span>]) - tana);</span><br><span class="line">        <span class="keyword">if</span> (now_gap &lt; ans_gap) &#123;</span><br><span class="line">            ans_gap = now_gap;</span><br><span class="line">            nx = <span class="built_in">ABS</span>(a[i].x - a[i + <span class="number">1</span>].x);</span><br><span class="line">            ny = <span class="built_in">ABS</span>(a[i].y - a[i + <span class="number">1</span>].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll g = <span class="built_in">gcd</span>(ny, nx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>, ny / g, nx / g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-任务">#T4 任务</h2>
<h3 id="题意简述-3">#题意简述</h3>
<p>有 <span class="math inline">\(n(n\leq 350)\)</span> 个人和 <span class="math inline">\(n\)</span> 个<strong>不同的</strong>任务，第 <span class="math inline">\(i\)</span> 个人高兴当且仅当他被分到 <span class="math inline">\(i\)</span> 个任务，问将所有任务都分配下去后至少有一个人高兴的方案数（<span class="math inline">\(\bmod10^9+7\)</span>）。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>这种计数问题还是要去尝试 DP，设 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个人分 <span class="math inline">\(j\)</span> 个任务，至少有 <span class="math inline">\(1\)</span> 个人高兴的方案数，考虑第 <span class="math inline">\(i\)</span> 个人是否高兴。</p>
<p>第 <span class="math inline">\(i\)</span> 个人高兴，则可以挑出 <span class="math inline">\(i\)</span> 个直接给第 <span class="math inline">\(i\)</span> 个人，剩下的 <span class="math inline">\(j-i\)</span> 个可以随意的给 <span class="math inline">\(i-1\)</span> 个人，于是方案总数为 <span class="math inline">\(\dbinom ji\cdot(i-1)^{j-i}\)</span></p>
<p>如果第 <span class="math inline">\(i\)</span> 个人不高兴，那么设给了第 <span class="math inline">\(i\)</span> 个人 <span class="math inline">\(k(k\ne i)\)</span> 个任务，那么此时的方案数为前 <span class="math inline">\(i-1\)</span> 个人分 <span class="math inline">\(j-k\)</span> 个的方案数，于是该情况的总方案数为 <span class="math display">\[
\sum\limits_{k=1}^n[k\ne i]\dbinom jkf_{i-1,j-k},
\]</span></p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; ll C[N][N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_C</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= x; ++ i) C[i][<span class="number">0</span>] = C[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">        C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= MOD;</span><br><span class="line">        (a *= a) %= MOD, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="built_in">init_C</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">          <span class="keyword">if</span> (j &gt;= i) f[i][j] = <span class="built_in">fpow</span>(i - <span class="number">1</span>, j - i) * C[j][i] % MOD;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; ++ k) &#123;</span><br><span class="line">              <span class="keyword">if</span> (k == i) <span class="keyword">continue</span>;</span><br><span class="line">              (f[i][j] += f[i - <span class="number">1</span>][j - k] * C[j][k] % MOD) %= MOD;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-CSP7连-EXTRA1 总结</title>
    <url>/2021/09/18/ZROI-21-CSP-EXTRA1/</url>
    <content><![CDATA[<h2 id="t1-str">#T1 Str</h2>
<h3 id="题意简述">#题意简述</h3>
<p>定义两个字符串相似为各个字符数相等；给定一个长度为 <span class="math inline">\(n(n\leq10^5)\)</span> 的字符串 <span class="math inline">\(s\)</span>，求一个尽可能短的前缀 <span class="math inline">\(t\)</span> 满足可以将 <span class="math inline">\(s\)</span> 分为大于等于 <span class="math inline">\(2\)</span> 段，要求每段长度相同，除第一段与 <span class="math inline">\(t\)</span> 相等外，其余段与 <span class="math inline">\(t\)</span> 相似。</p>
<h3 id="大体思路">#大体思路</h3>
<p><span class="math inline">\(n\)</span> 的因数最多只有 <span class="math inline">\(O(\sqrt n)\)</span> 个，可以暴力枚举 <span class="math inline">\(n\)</span> 的小于等于 <span class="math inline">\(\dfrac n 2\)</span> 的因数，直接进行判断，一个极为宽松的时间复杂度为 <span class="math inline">\(O(n\sqrt n)\)</span>，或者也可以看作循环 <span class="math inline">\(n\)</span> 次，每个循环里 <span class="math inline">\(O(\dfrac{1}k)\)</span>，整体为 <span class="math inline">\(O(n\log n)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n, cnt[N][<span class="number">26</span>], standard[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (cnt[r][i] - cnt[l - <span class="number">1</span>][i] != standard[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">      ++ cnt[i + <span class="number">1</span>][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++ j)</span><br><span class="line">        cnt[i][j] += cnt[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n &gt;&gt; <span class="number">1</span>; ++ l) <span class="keyword">if</span> (!(n % l)) &#123;</span><br><span class="line">        <span class="keyword">int</span> is_answer = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line">          standard[i] = cnt[l][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= n; i += l)</span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">check</span>(i, i + l - <span class="number">1</span>)) &#123;</span><br><span class="line">              is_answer = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_answer) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++ i)</span><br><span class="line">              <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-subset">#T2 Subset</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>给出一个长度为 <span class="math inline">\(n(1\leq n\leq10^5)\)</span> 的序列 <span class="math inline">\(A\)</span> ，求 <span class="math inline">\(A\)</span> 的所有长度为 <span class="math inline">\(k(1\leq k\leq50)\)</span> 的子序列的最大值之和 <span class="math inline">\(\bmod 10^9+7\)</span>。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>我们来直接考虑元素 <span class="math inline">\(x\)</span> 造成的贡献，显然只有当子序列中的数 <span class="math inline">\(b_i(1\leq i\leq k)\)</span> 都小于等于 <span class="math inline">\(x\)</span> 时才会造成 <span class="math inline">\(x\)</span> 的贡献，于是不难想到将序列自小到大排序，于是 <span class="math inline">\(a_i(1\leq i\leq n)\)</span> 的贡献为 <span class="math inline">\(\dbinom{i-1}{k-1}\cdot a_i\)</span>。时间复杂度为 <span class="math inline">\(O(nk)\)</span>，瓶颈为预处理组合数，当然也可以采用线性求阶乘、逆元的方式优化到 <span class="math inline">\(O(n\log n)\)</span>，此时时间复杂度瓶颈为快速排序。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k; ll C[N][<span class="number">55</span>], a[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_C</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= x; ++ i) C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= y; ++ j) &#123;</span><br><span class="line">          <span class="keyword">if</span> (j == i) &#123;C[i][j] = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">          C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(k); <span class="built_in">init_C</span>(n, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; ++ i)</span><br><span class="line">      (ans += C[i - <span class="number">1</span>][k - <span class="number">1</span>] * a[i] % MOD) %= MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-pair">#T3 Pair</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>给出一个整数 <span class="math inline">\(n(n\leq20)\)</span> ，求满足 <span class="math inline">\(\forall(a,b)\in S,1\leq a&lt;b\leq n\)</span> 且 <span class="math inline">\(\gcd(a,b)=1\)</span> ，并且<strong>不存在</strong>一个划分的集合 <span class="math inline">\(S\)</span> 的数量 <span class="math inline">\(\bmod 10^9\)</span>.</p>
<p>定义一个集合 <span class="math inline">\(S\)</span> 存在划分为 <span class="math inline">\(\exists x\in[2,n]\)</span>，<span class="math inline">\(\forall(a,b)\in S\)</span> 要么满足 <span class="math inline">\(a&lt;x\text{ and }b&lt;x\)</span>，要么满足 <span class="math inline">\(a\geq x\text{ and }b\geq x\)</span>.</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>首先不难发现这样的数对最多有 <span class="math inline">\(n^2\)</span> 个，于是显然可以预处理得到。</p>
<p>发现一个集合不存在划分，即意味着对于集合 <span class="math inline">\(S=\{(a_1,b_1),(a_2,b_2),\dots,(a_k,b_k)\}\)</span>，应当有 <span class="math display">\[
\bigcup\limits_{i=1}^k[a_i,b_i]=[1,n],
\]</span> 考虑设计 DP 解决计数问题。假设我们已经得到了所有 <span class="math inline">\(m\)</span> 个可行的数对（按先 <span class="math inline">\(a\)</span> 后 <span class="math inline">\(b\)</span> 的顺序从小到大排序），设 <span class="math inline">\(f_{i,j}\)</span> 表示考虑了前 <span class="math inline">\(i\)</span> 个二元组，并集为 <span class="math inline">\([1,j]\)</span> 的方案数，最终答案为 <span class="math inline">\(f_{m,n}\)</span>.</p>
<p>来考虑如何转移，如果不选新加入的二元组，那么方案数为 <span class="math inline">\(f_{i-1,j}\)</span>，即具有转移 <span class="math inline">\(f_{i-1,j}\to f_{i,j}\)</span>，如果新加入的二元组 <span class="math inline">\((a,b)\)</span> 满足 <span class="math inline">\(a\leq j\)</span>，意味着将其并入得到的集合不会存在划分，新得到的并集应当为 <span class="math inline">\([1,\max\{j,b\}]\)</span>，于是具有转移 <span class="math inline">\(f_{i-1,j}\to f_{i,\max\{j,b\}}\)</span>。一个极为宽松的时间复杂度上界为 <span class="math inline">\(O(n^3)\)</span>.</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, npr[N][<span class="number">2</span>], cnt; ll f[N][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;<span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gcd</span>(i, j) == <span class="number">1</span>) npr[++ cnt][<span class="number">0</span>] = i, npr[cnt][<span class="number">1</span>] = j;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">          f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][j]) % MOD;</span><br><span class="line">          <span class="keyword">if</span> (npr[i][<span class="number">0</span>] &lt;= j)</span><br><span class="line">            (f[i][<span class="built_in">max</span>(npr[i][<span class="number">1</span>], j)] += f[i - <span class="number">1</span>][j]) %= MOD;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[cnt][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-match">#T4 Match</h2>
<h3 id="题意简述-3">#题意简述</h3>
<p>给定 <span class="math inline">\(n(n\leq10^5)\)</span> 个字符串 <span class="math inline">\(S_i\)</span>，有 <span class="math inline">\(m(m\leq10^5)\)</span> 个询问，每次给出一个前缀 <span class="math inline">\(T_1\)</span> 和一个后缀 <span class="math inline">\(T_2\)</span>，问有多少个串 <span class="math inline">\(S_i\)</span> 满足 <span class="math inline">\(S_i=T_1RT_2(|R|\geq0)\)</span>。</p>
<p>数据范围满足 <span class="math inline">\(\sum|S_i|+\sum|T|\leq10^6\)</span>.</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>先考虑将所有字符串插入一棵 trie 中，先考虑前缀要求 <span class="math inline">\(T_1\)</span>，假设得到 <span class="math inline">\(T_1\)</span> 的结束点为 <span class="math inline">\(x\)</span>， 这限制了所有答案的 <span class="math inline">\(T_2\)</span> 的起始点一定在 <span class="math inline">\(x\)</span> 的子树中，于是我们现在的目标就是得到 <span class="math inline">\(x\)</span> 的子树中能作为 <span class="math inline">\(T_2\)</span> 的起始点的点的个数，发现不好进行解决，不妨将其转化为能作为 <span class="math inline">\(T_2\)</span> 的起始点的点中 dfn 大于等于 <span class="math inline">\(dfn_x\)</span> 小于等于 <span class="math inline">\(end\_dfn_x\)</span> 的点的个数。</p>
<p>于是我们可以这样解决：在插入每个串时，在每个经过的点上增加一个当前剩余的后缀（的 Hash 值），在递归求 dfn 时将每个点上的串与该点的 dfn 结合加入一个序列中，最后将该序列按照先 Hash 值后 dfn 的顺序进行排序，得到的序列中同样的串所在位置连续，于是用 <code>lower_bound()</code> 和 <code>upper_bound()</code> 结合即可得到答案。</p>
<p>由于不同字符串的数量可能很大，这里采用双 Hash 防止冲突。</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(a, b) make_pair(a, b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BAS1 = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BAS2 = <span class="number">13331</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD1 = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD2 = <span class="number">1004535809</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], endp[N], ch[N][<span class="number">30</span>], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> hash_val1[N], hash_val2[N], T;</span><br><span class="line"></span><br><span class="line">vector &lt;pii &gt; h[N]; <span class="comment">/*the hash values of each string belong the node.*/</span></span><br><span class="line">vector &lt;pair &lt;pii, <span class="keyword">int</span>&gt; &gt; v; <span class="comment">/*the list of all hash values with dfn.*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Insert a new string, and add the hash values of </span></span><br><span class="line"><span class="comment">the suffixes to the list of corresponding node.*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>;</span><br><span class="line">    hash_val1[len] = hash_val2[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*Get the hash value of each suffix.*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; ~i; -- i)</span><br><span class="line">      hash_val1[i] = (<span class="number">1ll</span> * hash_val1[i + <span class="number">1</span>] * BAS1 % MOD1 + s[i] - <span class="number">96</span>) % MOD1,</span><br><span class="line">      hash_val2[i] = (<span class="number">1ll</span> * hash_val2[i + <span class="number">1</span>] * BAS2 % MOD2 + s[i] - <span class="number">96</span>) % MOD2;</span><br><span class="line">    h[p].<span class="built_in">push_back</span>(<span class="built_in">mkp</span>(hash_val1[<span class="number">0</span>], hash_val2[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">/*Insert string and add the hash values.*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = s[i] - <span class="number">96</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ch[p][k]) &#123;ch[p][k] = ++ cnt;&#125; p = ch[p][k];</span><br><span class="line">        h[p].<span class="built_in">push_back</span>(<span class="built_in">mkp</span>(hash_val1[i + <span class="number">1</span>], hash_val2[i + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Get the dfn of each node, and add the hash</span></span><br><span class="line"><span class="comment">values with dfn to the list at the same time.*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++ T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : h[x]) v.<span class="built_in">push_back</span>(<span class="built_in">mkp</span>(<span class="built_in">mkp</span>(i.first, i.second), T));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++ i) <span class="keyword">if</span> (ch[x][i]) <span class="built_in">dfs</span>(ch[x][i]);</span><br><span class="line">    endp[x] = T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m; <span class="keyword">char</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(m); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a), <span class="built_in">insert</span>(a);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a); <span class="keyword">int</span> l = <span class="built_in">strlen</span>(a), p = <span class="number">1</span>, q = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*Get into the end node of T1.*/</span></span><br><span class="line">        <span class="keyword">while</span> (q &lt; l &amp;&amp; a[q] != <span class="string">&#x27;*&#x27;</span>) p = ch[p][a[q] - <span class="number">96</span>], ++ q;</span><br><span class="line">        <span class="comment">/*Get the hash value of T_2.*/</span></span><br><span class="line">        <span class="keyword">int</span> hv1 = <span class="number">0</span>, hv2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt; q; -- i)</span><br><span class="line">          hv1 = (<span class="number">1ll</span> * hv1 * BAS1 % MOD1 + a[i] - <span class="number">96</span>) % MOD1,</span><br><span class="line">          hv2 = (<span class="number">1ll</span> * hv2 * BAS2 % MOD2 + a[i] - <span class="number">96</span>) % MOD2;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ub</span>(<span class="built_in">mkp</span>(<span class="built_in">mkp</span>(hv1, hv2), endp[p])) - <span class="built_in">lb</span>(<span class="built_in">mkp</span>(<span class="built_in">mkp</span>(hv1, hv2), dfn[p])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>囸，当时在被 whk 蹂躏，不知道有 extra Round...</p>
</blockquote>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-CSP7连-DAY3 总结</title>
    <url>/2021/09/17/ZROI-21-CSP-DAY3/</url>
    <content><![CDATA[<h2 id="t1-斯诺克">#T1 斯诺克</h2>
<h3 id="题意简述">#题意简述</h3>
<p><span class="math inline">\(7\)</span> 种物品，第 <span class="math inline">\(i\)</span> 种物品的价值为 <span class="math inline">\(i\)</span>，有 <span class="math inline">\(a_i\)</span> 个，必须按照价值自小到大地选，特别的，必须将第 <span class="math inline">\(1\)</span> 种选完才能向后选，选第 <span class="math inline">\(1\)</span> 种时可以得到一个额外价值 <span class="math inline">\(x\)</span>，可以在当前 <span class="math inline">\(a_i&gt;0(i\ne1)\)</span> 的物品价值中任选。</p>
<h3 id="大体思路">#大体思路</h3>
<p>显然只要有就一定可以都选上，附加权值直接贪心的选最大的即可。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rcnt, a[<span class="number">8</span>], res, mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        res += a[i] * i;</span><br><span class="line">        <span class="keyword">if</span> (a[i]) mx = i;</span><br><span class="line">    &#125;</span><br><span class="line">    res += a[<span class="number">1</span>] * mx;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-翻转">#T2 翻转</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定一个 <span class="math inline">\(n\times m(n,m\leq17)\)</span> 的 <span class="math inline">\(01\)</span> 矩阵，每次操作可以将如下图范围的图形做异或操作，图形可以不全（在边界），但中心点必须位于矩阵中。</p>
<p>问至少需要操作多少次才能将矩阵全部变为 <span class="math inline">\(0\)</span>。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>不难发现</p>
<ul>
<li>对于一个位置最多被操作一次；</li>
<li>对于两个操作位置相同的操作聚合，结果相同；</li>
</ul>
<p>于是可以想到自上而下的确定情况，注意到如果将第一行的状态确定，每次只对已经确定的行的下一行进行操作，那么下面怎么变换都是确定的了，于是不难得到以下算法：用二进制枚举第一行的每个点的操作状态，对原图进行修改，并在改后的图上进行模拟/统计即可，时间复杂度为 <span class="math inline">\(O(nm\cdot2^m)\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans = INF, mp[<span class="number">20</span>][<span class="number">20</span>], tmp[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bitcount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) cnt += (x &amp; <span class="number">1</span>), x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_res</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        tmp[i][j] = mp[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">          tmp[<span class="number">1</span>][i + <span class="number">1</span>] ^= <span class="number">1</span>, tmp[<span class="number">1</span>][i] ^= <span class="number">1</span>;</span><br><span class="line">          tmp[<span class="number">1</span>][i + <span class="number">2</span>] ^= <span class="number">1</span>, tmp[<span class="number">2</span>][i + <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        <span class="keyword">if</span> (tmp[i][j]) &#123;</span><br><span class="line">            ++ res; tmp[i][j] ^= <span class="number">1</span>;</span><br><span class="line">            tmp[i + <span class="number">1</span>][j] ^= <span class="number">1</span>;</span><br><span class="line">            tmp[i + <span class="number">1</span>][j - <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">            tmp[i + <span class="number">1</span>][j + <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">            tmp[i + <span class="number">2</span>][j] ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= m; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (tmp[n][i]) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res + <span class="built_in">bitcount</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">          <span class="keyword">char</span> c; cin &gt;&gt; c;</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="string">&#x27;X&#x27;</span>) mp[i][j] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> mp[i][j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; ++ i)</span><br><span class="line">      ans = <span class="built_in">Min</span>(ans, <span class="built_in">get_res</span>(i));</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-数对">#T3 数对</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>给定两个数列 <span class="math inline">\(\{a_1,a_2,\dots,a_n\}\)</span> 和 <span class="math inline">\(\{b_1,b_2,\dots,b_m\}(n,m\leq10^5,1\leq a_i,b_i\leq2^30)\)</span>，问有多少数对 <span class="math inline">\((a_i,b_j)(1\leq i\leq n,1\leq j\leq m)\)</span>，满足 <span class="math inline">\(\text{bitcount}(a_i\text{ xor }b_j)=2\)</span>.</p>
<h3 id="大体思路-2">#大体思路</h3>
<p><span class="math inline">\(\text{bitcount}(a_i\text{ xor }b_j)=2\)</span> 意味着 <span class="math inline">\(a_i,b_j\)</span> 在二进制下只有两位不同，维护一个 Hash，每次枚举不同的位置中的一位 <span class="math inline">\(k\)</span>，先查询 Hash 中每个 <span class="math inline">\(b_j\text{ xor }2^k\)</span> 出现的次数，再将每个 <span class="math inline">\(a_i\text{ xor }2^k\)</span> 加入 Hash，不难发现这样统计每对数字刚好被统计一次，即得答案。时间复杂度 <span class="math inline">\(O(30\cdot n)\)</span>，<span class="math inline">\(30\)</span> 为枚举 <span class="math inline">\(k\)</span> 的复杂度。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span> &#123;</span><span class="keyword">int</span> val, tot, nxt;&#125; h[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], b[N], head[N], cnt;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hx = x % MOD, p = head[hx];</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; h[p].val != x) p = h[p].nxt;</span><br><span class="line">    <span class="keyword">if</span> (h[p].val == x) h[p].tot += c;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        h[++ cnt].val = x, h[cnt].tot = c;</span><br><span class="line">        h[cnt].nxt = head[hx], head[hx] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Count</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hx = x % MOD, p = head[hx];</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; h[p].val != x) p = h[p].nxt;</span><br><span class="line">    <span class="keyword">if</span> (h[p].val == x) <span class="keyword">return</span> h[p].tot;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">          ans += <span class="built_in">Count</span>(b[j] ^ k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">          <span class="built_in">insert</span>(a[j] ^ k, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-回文串">#T4 回文串</h2>
<h3 id="题意简述-3">#题意简述</h3>
<p>定义一个字符串的价值是它的回文子串的个数。现给定一字符串 <span class="math inline">\(s(|s|\leq10^5)\)</span>，可以任一改变一个字符，问可得到的最大价值。</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>考虑改变一个位置会造成的影响：失去一些回文子串、得到新的回文子串。</p>
<p>在考虑改变造成的影响前，我们需要先得到在每个位置的回文半径，可以用 Manacher 求，当然也可以用 Hash+二分完成，这里直接用的 Hash。然后，我们再来考虑造成的影响。</p>
<p>对于每个回文中心 <span class="math inline">\(i，j(i\leq j)\)</span> 和其对应的回文半径 <span class="math inline">\(r\)</span>，考虑得到新的回文子串时对应的改变位置要么是 <span class="math inline">\(x=i-r\)</span> 要么是 <span class="math inline">\(y=j+r\)</span>，且一定是改成对应的另一个的字符，否则对于这个回文中心，不会造成价值增加。</p>
<blockquote>
<p>对于奇回文，<span class="math inline">\(i=j\)</span>，对于偶回文，<span class="math inline">\(j=i+1\)</span>。</p>
</blockquote>
<p>之后同样可以用 Hash+二分求得不包括 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的新增半径（即为新增的回文子串的数量），用数组 <span class="math inline">\(f_{i,c}\)</span> 进行存储，其中 <span class="math inline">\(f\)</span> 的意义是 “将第 <span class="math inline">\(i\)</span> 个位置变为 <span class="math inline">\(c\)</span> 字符增加的回文子串的数量”。</p>
<p>下面来考虑修改 <span class="math inline">\(x\)</span> 失去的回文串数量，显然对于当前回文中心 <span class="math inline">\(i,j\)</span>，若 <span class="math inline">\(i-r+1\leq x\leq i\)</span>，那么减少的个数为 <span class="math inline">\(r-(i-x)=r-i+x\)</span>，若 <span class="math inline">\(j\leq x\leq j+r-1\)</span>，那么减少的个数为 <span class="math inline">\(j+r-1-(x-1)=j+r-x\)</span>，发现这两个贡献对于修改位置 <span class="math inline">\(x\)</span> 都可以拆分成两部分：<span class="math inline">\(r-i\)</span> 和 <span class="math inline">\(x\)</span>、<span class="math inline">\(r+j\)</span> 和 <span class="math inline">\(-x\)</span>，其中仅关于 <span class="math inline">\(i,j,r\)</span> 的部分与修改哪里无关，于是可以维护一个数组 <span class="math inline">\(fl_x\)</span>，记录这一部分的贡献，这里的区间加法可以用差分处理；再来看 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(-x\)</span>，同样可以维护差分数组 <span class="math inline">\(fk_x\)</span>，对 <span class="math inline">\(fk\)</span> 只做区间加 <span class="math inline">\(1\)</span> 与加 <span class="math inline">\(-1\)</span>，最后统计贡献可以统一乘上 <span class="math inline">\(x\)</span>。</p>
<p>综上我们对于修改的影响都已经解决了，最后枚举修改位置及修改后的字符，将贡献取最大值与初始价值相加即得答案。时间复杂度为 <span class="math inline">\(O(n\log n+26\cdot n)\)</span>.</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> ull BASE = <span class="number">9973</span>;</span><br><span class="line"><span class="keyword">const</span> ull MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p[N], h[N], hr[N]; <span class="keyword">char</span> s[N], sr[N];</span><br><span class="line">ll f[N][<span class="number">26</span>], fk[N], fl[N], init_val;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_hash</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">int</span> *H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(S); H[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)</span><br><span class="line">      H[i + <span class="number">1</span>] = (<span class="number">1ull</span> * H[i] * BASE % MOD + (ll)(S[i] - <span class="string">&#x27;a&#x27;</span>)) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">getHash</span><span class="params">(<span class="keyword">int</span>* H, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">1ull</span> * H[b + <span class="number">1</span>] - <span class="number">1ull</span> * H[a] * p[b - a + <span class="number">1</span>] % MOD) + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHash</span>(h, a, b) == <span class="built_in">getHash</span>(hr, n - d - <span class="number">1</span>, n - c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRadius</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = x, R = y, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(l - mid + <span class="number">1</span>, l, r, r + mid - <span class="number">1</span>))</span><br><span class="line">          res = mid, L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); n = <span class="built_in">strlen</span>(s); p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">      p[i + <span class="number">1</span>] = (<span class="number">1ull</span> * p[i] * BASE) % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">      sr[i] = s[n - i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">init_hash</span>(s, h); <span class="built_in">init_hash</span>(sr, hr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= i + <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">          <span class="keyword">int</span> r = <span class="number">0</span>; r = <span class="built_in">getRadius</span>(i, j, <span class="number">0</span>, <span class="built_in">Min</span>(i + <span class="number">1</span>, n - j));</span><br><span class="line">          <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">              fk[j + <span class="number">1</span>] += <span class="number">-1</span>, fk[j + r] -= <span class="number">-1</span>;</span><br><span class="line">              fl[j + <span class="number">1</span>] += j + r, fl[j + r] -= j + r;</span><br><span class="line">              fk[i - r + <span class="number">1</span>] += <span class="number">1</span>, fk[i] -= <span class="number">1</span>;</span><br><span class="line">              fl[i - r + <span class="number">1</span>] += -(i - r), fl[i] -= -(i - r);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              fk[j] += <span class="number">-1</span>, fk[j + r] -= <span class="number">-1</span>;</span><br><span class="line">              fl[j] += j + r, fl[j + r] -= j + r;</span><br><span class="line">              fk[i - r + <span class="number">1</span>] += <span class="number">1</span>, fk[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">              fl[i - r + <span class="number">1</span>] += -(i - r), fl[i + <span class="number">1</span>] -= -(i - r);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> x = i - r, y = j + r; init_val += r;</span><br><span class="line">          <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">          ++ r; r = <span class="built_in">getRadius</span>(x - <span class="number">1</span>, y + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Min</span>(i + <span class="number">1</span>, n - j) - r);</span><br><span class="line">          f[x][s[y] - <span class="string">&#x27;a&#x27;</span>] += r + <span class="number">1</span>;</span><br><span class="line">          f[y][s[x] - <span class="string">&#x27;a&#x27;</span>] += r + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    ll best_change = <span class="number">0</span>, k = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        k += fk[i], l += fl[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++ j)</span><br><span class="line">          <span class="keyword">if</span> (j + <span class="string">&#x27;a&#x27;</span> != s[i])</span><br><span class="line">            best_change = <span class="built_in">Max</span>(best_change, f[i][j] - (<span class="number">1ll</span> * i * k + l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, init_val + best_change);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」HDU6606 Distribution of books</title>
    <url>/2021/09/08/HDU6606/</url>
    <content><![CDATA[<h2 id="题意简述">#1.0 题意简述</h2>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的数列 <span class="math inline">\(\{a_i\}\)</span>，可以任意去掉尾部一段连续的数，将剩下数列分为 <span class="math inline">\(k\)</span> 段非空连续子段，问分成的子段中的子段和最大值最小是多少。<strong>多组数据</strong>。</p>
<p>其中数据组数 <span class="math inline">\(1\le T\le 10\)</span>，<span class="math inline">\(\sum n\le2\times10^5\)</span>，<span class="math inline">\(1\le k\le n\)</span>，<span class="math inline">\(-10^9\le a_i\le10^9\)</span>.</p>
<h2 id="大致思路">#2.0 大致思路</h2>
<p>首先看到“最大值最小”立刻想到二分答案，那么现在问题转化为对于 <span class="math inline">\(x\)</span>，是否存在一种分法使得最大的子段和小于等于 <span class="math inline">\(x\)</span>，再考虑转变一下这个问题，因为尾部可以丢掉任意长度的一段，于是考虑是否存在一种分法得到至少 <span class="math inline">\(k\)</span> 段子段和小于等于 <span class="math inline">\(x\)</span> 的子段。</p>
<p>考虑 DP，设 <span class="math inline">\(f_i\)</span> 表示前 <span class="math inline">\(i\)</span> 个数可以分成的最多的子段个数，不难得到转移方程： <span class="math display">\[
f_i=\max\limits_{0\leq j&lt;i}\{[sum_i-sum_j\leq x]\cdot(f_j+1)\},
\]</span> 其中，<span class="math inline">\(sum_i\)</span> 表示到 <span class="math inline">\(i\)</span> 的前缀和，显然直接处理上面的柿子的时间复杂度是 <span class="math inline">\(O(n^2)\)</span>，不能接受，考虑优化，将其中的艾弗森约定简单处理一下得到 <span class="math display">\[
f_i=\max\limits_{0\leq j&lt;i\ and\ sum_i-x\leq sum_j}\{f_j+1\},
\]</span> 于是我们可以将 <span class="math inline">\(sum\)</span> 作为下标，进行线段树优化。即将每一个处理得到的 <span class="math inline">\(f_j\)</span> 插入线段树下标为 <span class="math inline">\(sum_j\)</span> 的位置，查询时查询下标大于等于 <span class="math inline">\(sum_i-x\)</span> 的最大值即可，由于 <span class="math inline">\(sum\)</span> 可能很大，而空间限制很紧，于是可以将前缀和数组进行离散化处理。总体时间复杂度为 <span class="math inline">\(O(n\log^2n)\)</span>.</p>
<h2 id="code">#3.0 Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs, mx;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;ls = rs = mx = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;ls = rs = mx = <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    Node p[M]; <span class="keyword">int</span> cnt, rt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">SegmentTree</span><span class="params">()</span> </span>&#123;cnt = rt = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt) p[cnt --].<span class="built_in">del</span>();</span><br><span class="line">        cnt = rt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        p[k].mx = <span class="built_in">Max</span>(p[p[k].ls].mx, p[p[k].rs].mx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span> (!k) k = ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;p[k].mx = <span class="built_in">Max</span>(p[k].mx, x); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">insert</span>(p[k].ls, l, mid, pos, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(p[k].rs, mid + <span class="number">1</span>, r, pos, x);</span><br><span class="line">        <span class="built_in">pushup</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> p[k].mx;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) res = <span class="built_in">Max</span>(res, <span class="built_in">query</span>(p[k].ls, l, mid, x, y));</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; y) res = <span class="built_in">Max</span>(res, <span class="built_in">query</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, k, f[N], zero_pos, dcnt;</span><br><span class="line">ll mint, maxt, s[N], dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_pos</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + dcnt + <span class="number">1</span>, x) - dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mset</span>(f, <span class="number">-1</span>); t.<span class="built_in">reset</span>(); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    t.<span class="built_in">insert</span>(t.rt, <span class="number">1</span>, dcnt, zero_pos, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="built_in">get_pos</span>(s[i] - x), pos2 = <span class="built_in">get_pos</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (pos1 &gt; dcnt) <span class="keyword">continue</span>;</span><br><span class="line">        f[i] = t.<span class="built_in">query</span>(t.rt, <span class="number">1</span>, dcnt, pos1, dcnt) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[i] &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[i] &gt; <span class="number">0</span>) t.<span class="built_in">insert</span>(t.rt, <span class="number">1</span>, dcnt, pos2, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k); dcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]);</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>] + s[i];</span><br><span class="line">            dis[++ dcnt] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dis[++ dcnt] = <span class="number">0</span>; <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + dcnt + <span class="number">1</span>);</span><br><span class="line">        dcnt = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + dcnt + <span class="number">1</span>) - dis - <span class="number">1</span>;</span><br><span class="line">        zero_pos = <span class="built_in">get_pos</span>(<span class="number">0</span>);</span><br><span class="line">        ll l = -INF, r = INF, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">              ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」HDU6315 Naive Operations</title>
    <url>/2021/09/08/HDU6315/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=6315">题目链接</a></p>
</blockquote>
<h2 id="题意简述">#1.0 题意简述</h2>
<p>给定两个数列 <span class="math inline">\(\{a_i\}\)</span> 和 <span class="math inline">\(\{b_i\}\)</span>，其中 <span class="math inline">\(\{a_i\}\)</span> 初始全为 <span class="math inline">\(0\)</span>，有如下操作：</p>
<ul>
<li>给 <span class="math inline">\(a_i(i\in[l,r])\)</span> 加上 <span class="math inline">\(1\)</span>；</li>
<li>求 <span class="math inline">\(\sum_{i=l}^r\left\lfloor\frac{a_i}{b_i}\right\rfloor\)</span>；</li>
</ul>
<p><strong>多组数据</strong>。</p>
<h2 id="大致思路">#2.0 大致思路</h2>
<p>注意到每给 <span class="math inline">\(a_i\)</span> 加 <span class="math inline">\(b_i\)</span> 次答案才会增加一，而对于一个区间，当且仅当该区间内存在一个数被加了 <span class="math inline">\(b_i\)</span> 的倍数次才会对区间的答案作出贡献，于是可以直接记录当前区间内的区间加标记和至少还要加多少次才会更新，当次数变为 <span class="math inline">\(0\)</span> 时，递归地进行更新即可。</p>
<p><del>时间复杂度为 <span class="math inline">\(O(能过)\)</span>。</del>，考虑最多只会对答案造成 <span class="math inline">\(O(n\log n)\)</span> 级别的变化次数，每次更新答案均摊只有 <span class="math inline">\(O(\log n)\)</span> 的时间复杂度，于是总体时间复杂度为 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h2 id="code">#3.0 Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs, mn, lz, sum;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;ls = rs = mn = lz = sum = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;ls = rs = mn = lz = sum = <span class="number">0</span>;&#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, cnt, rt, b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) p[i].<span class="built_in">del</span>();</span><br><span class="line">    cnt = rt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p[k].ls || !p[k].rs) <span class="keyword">return</span>;</span><br><span class="line">    p[k].mn = <span class="built_in">Min</span>(p[p[k].ls].mn, p[p[k].rs].mn);</span><br><span class="line">    p[k].sum = p[p[k].ls].sum + p[p[k].rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = p[k].ls, rs = p[k].rs;</span><br><span class="line">    <span class="keyword">if</span> (p[k].lz) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ls) p[ls].lz += p[k].lz, p[ls].mn -= p[k].lz;</span><br><span class="line">        <span class="keyword">if</span> (rs) p[rs].lz += p[k].lz, p[rs].mn -= p[k].lz;</span><br><span class="line">        p[k].lz = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;++ p[k].sum, p[k].mn = b[l]; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k); <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p[p[k].ls].mn) <span class="built_in">update</span>(p[k].ls, l, mid);</span><br><span class="line">    <span class="keyword">if</span> (!p[p[k].rs].mn) <span class="built_in">update</span>(p[k].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    p[k].lz += c, p[k].mn -= c;</span><br><span class="line">    <span class="keyword">if</span> (!p[k].mn) <span class="built_in">pushdown</span>(k), <span class="built_in">update</span>(k, l, r), <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) k = ++ cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;p[k].mn = b[l]; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="built_in">build</span>(p[k].ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p[k].rs, mid + <span class="number">1</span>, r); <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;<span class="built_in">add</span>(k, l, r, c); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(p[k].ls, l, mid, x, y, c);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) <span class="built_in">modify</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y, c);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> p[k].sum;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>; <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) res += <span class="built_in">query</span>(p[k].ls, l, mid, x, y);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) res += <span class="built_in">query</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        <span class="built_in">Reset</span>(); <span class="built_in">build</span>(rt, <span class="number">1</span>, n); <span class="keyword">char</span> s[<span class="number">10</span>]; <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, s, &amp;l, &amp;r);</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span>) <span class="built_in">modify</span>(rt, <span class="number">1</span>, n, l, r, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(rt, <span class="number">1</span>, n, l, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」HDU5634 Rikka with Phi</title>
    <url>/2021/09/08/HDU5634/</url>
    <content><![CDATA[<h2 id="题意简述">#1.0 题意简述</h2>
<p>维护数列，三种操作：</p>
<ul>
<li>给定 <span class="math inline">\(l,r\)</span>，将 <span class="math inline">\(a_i(i\in[l,r])\)</span> 变为 <span class="math inline">\(\varphi(a_i)\)</span>；</li>
<li>给定 <span class="math inline">\(l,r,x\)</span>，将 <span class="math inline">\(a_i(i\in[l,r])\)</span> 变为 <span class="math inline">\(x\)</span>；</li>
<li>询问区间和；</li>
</ul>
<h2 id="大体思路">#2.0 大体思路</h2>
<p>发现所有的数都有归于<strong>统一</strong>（<del>五桶！</del>）的趋势，一个数在进行不超过 <span class="math inline">\(\log n\)</span> 次操作后会变为 <span class="math inline">\(1\)</span>，但是区间取 <span class="math inline">\(\varphi\)</span> 的操作显然不能直接区间维护，于是只能暴力修改，但是，注意到如果整个区间的数都相同，那么可以直接区间取 <span class="math inline">\(\varphi\)</span>，于是考虑维护一个区间是否相同的标记，如果相同，那么就直接区间取 <span class="math inline">\(\varphi\)</span> 就可以了，如果没有区间覆盖的操作，那么时间复杂度最差为 <span class="math inline">\(O(n\log^2n)\)</span>，即数各不相同，每次单点取 <span class="math inline">\(\varphi\)</span>，直到全部变为 <span class="math inline">\(1\)</span>。区间覆盖的存在不会影响整体的时间复杂度。</p>
<p>注意区间相同标记是自底向上维护和自顶向下维护并存。</p>
<h2 id="code">#3.0 Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">700010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs; ll sum, tag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;ls = rs = sum = tag = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;ls = rs = sum = tag = <span class="number">0</span>;&#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, cnt, phi[M], prm[N];</span><br><span class="line"><span class="keyword">int</span> rt, pcnt, nprm[M]; ll a[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Phi</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nprm[i]) prm[++ pcnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prm[j] * i &gt; x) &#123;<span class="keyword">break</span>;&#125; nprm[prm[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prm[j]) phi[prm[j] * i] = phi[i] * (prm[j] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;phi[prm[j] * i] = phi[i] * prm[j]; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) p[i].<span class="built_in">del</span>();</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = p[k].ls, rs = p[k].rs;</span><br><span class="line">    p[k].sum = p[ls].sum + p[rs].sum;</span><br><span class="line">    <span class="keyword">if</span> (p[ls].tag &amp;&amp; p[ls].tag == p[rs].tag)</span><br><span class="line">      p[k].tag = p[ls].tag;</span><br><span class="line">    <span class="keyword">else</span> p[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> k, ll x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    p[k].tag = x, p[k].sum = <span class="number">1ll</span> * (r - l + <span class="number">1</span>) * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = p[k].ls, rs = p[k].rs, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p[k].tag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ls) <span class="built_in">cover</span>(ls, p[k].tag, l, mid);</span><br><span class="line">        <span class="keyword">if</span> (rs) <span class="built_in">cover</span>(rs, p[k].tag, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) &#123;k = ++ cnt;&#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;p[k].tag = p[k].sum = a[l]; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p[k].ls, l, mid); <span class="built_in">build</span>(p[k].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, ll c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;<span class="built_in">cover</span>(k, c, l, r); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">recover</span>(p[k].ls, l, mid, x, y, c);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) <span class="built_in">recover</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y, c);</span><br><span class="line">    p[k].tag = <span class="number">0</span>; <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change_to_Phi</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y &amp;&amp; p[k].tag) &#123;</span><br><span class="line">        <span class="built_in">cover</span>(k, phi[p[k].tag], l, r); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">Change_to_Phi</span>(p[k].ls, l, mid, x, y);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) <span class="built_in">Change_to_Phi</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> p[k].sum;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; ll res = <span class="number">0</span>; <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) res += <span class="built_in">query</span>(p[k].ls, l, mid, x, y);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) res += <span class="built_in">query</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Get_Phi</span>(<span class="number">1e7</span>); <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">build</span>(rt, <span class="number">1</span>, n); <span class="keyword">int</span> id, l, r, x;</span><br><span class="line">        <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;id, &amp;l, &amp;r);</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">1</span>) <span class="built_in">Change_to_Phi</span>(rt, <span class="number">1</span>, n, l, r);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="built_in">recover</span>(rt, <span class="number">1</span>, n, l, r, x);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(rt, <span class="number">1</span>, n, l, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-CSP7连-DAY2 总结</title>
    <url>/2021/09/06/ZROI-21-CSP-DAY2/</url>
    <content><![CDATA[<h2 id="t1-ip-地址">#T1 IP 地址</h2>
<h3 id="题意简述">#题意简述</h3>
<p>一个合法的 IP 地址每位数字最小为 <span class="math inline">\(0\)</span>，最大为 <span class="math inline">\(255\)</span>，且不含前导零。每位数字中间有一个 "." 隔开。</p>
<p>给定一个文本串，其中最多包含 <span class="math inline">\(4\)</span> 个整数（可能极大），问是否是合法的 IP 地址，如果不合法请更正为合法 IP，数字大于 <span class="math inline">\(255\)</span> 则修改为 <span class="math inline">\(255\)</span>.</p>
<h3 id="大体思路">#大体思路</h3>
<p>把快读魔改一下就好了，但是一定要注意细节，比如快读实际会向后多读一个字符，可以借此判断最后是否有多余字符。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_not_ip</span><span class="params">(<span class="number">0</span>)</span>, cnt</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span> || cnt &gt; <span class="number">3</span>) is_not_ip |= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; ; c = <span class="built_in">getchar</span>())  &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) is_not_ip |= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (++ cnt &gt; <span class="number">3</span>) is_not_ip |= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span> &amp;&amp; x == <span class="number">0</span>) is_not_ip |= <span class="number">1</span>;</span><br><span class="line">        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">255</span>) x = <span class="number">255</span>, is_not_ip |= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">if</span> (is_not_ip) <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-字符串">#T2 字符串</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的字符串，其中一共包含两种字符：<code>A</code> 和 <code>P</code>，其中，<code>AP</code> 和 <code>PP</code> 可以消去，消去后剩下两段字符串会拼在一起，问经过若干次消除后能得到的最小字符串长度为多少。</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>注意到 <code>A</code> 只能由 <code>AP</code> 消去，而 <code>P</code> 可以由 <code>PP</code> 消去，考虑贪心：当前的 <code>A</code> 要么在后面被消去，要么无法消去，而多出来的 <code>P</code> 对答案的贡献最多是 <span class="math inline">\(1\)</span>，所以优先消掉 <code>A</code> 一定是最优的选择。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, pcnt, acnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;A&#x27;</span>) ++ acnt;</span><br><span class="line">        <span class="keyword">else</span> acnt ? -- acnt : ++ pcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, acnt + (pcnt &amp; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-继承类">#T3 继承类</h2>
<h3 id="题意简述-2">#题意简述</h3>
<blockquote>
<p>实在不好概述，这里直接粘来原题面。</p>
</blockquote>
<p>现在发明了一种类似于 C++ 的面向对象编程语言中的类声明。</p>
<p>每个类声明的格式为 "<span class="math inline">\(K : P_1\ P_2\ \dots\ P_K;\)</span>"</p>
<p>其中 <span class="math inline">\(K\)</span> 是要声明的新类的名称，<span class="math inline">\(P_1\)</span> 、<span class="math inline">\(P_2\)</span> 、<span class="math inline">\(\dots\)</span> 、<span class="math inline">\(P_k\)</span> 类 <span class="math inline">\(K\)</span> 继承的类的名称。</p>
<p>例如，"<strong>shape : ;</strong>" 是不继承任何其他类的类 “shape” 的声明，而 “<strong>square : shape rectangle;</strong>” 是继承类 “shape” 和 “rectangle” 的类 “square” 的声明。</p>
<p>如果类 <span class="math inline">\(K_1\)</span> 继承类 <span class="math inline">\(K_2\)</span> ，类 <span class="math inline">\(K_2\)</span> 继承类 <span class="math inline">\(K_3\)</span> ，依此类推，直到类 <span class="math inline">\(K_{m−1}\)</span> 继承类 <span class="math inline">\(K_m\)</span> ，那么我们说所有类 <span class="math inline">\(K_1,K_2,\dots,K_{m−1}\)</span> 派生自类 <span class="math inline">\(K_m\)</span> 。</p>
<p>编程语言的规则禁止循环定义，因此不允许从自身派生一个类。换句话说，类层次结构形成了一个有向无环图。此外，不允许在类层次结构中出现所谓的菱形。一个菱形由四个不同的类 <span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>、<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span> 组成，而且它满足（如下图所示）：</p>
<ul>
<li>类 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 派生自 <span class="math inline">\(A\)</span>。</li>
<li>类 <span class="math inline">\(B\)</span> 派生自 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span>。</li>
<li>类 <span class="math inline">\(X\)</span> 不是从 <span class="math inline">\(Y\)</span> 派生的，类 <span class="math inline">\(Y\)</span> 也不是从 <span class="math inline">\(X\)</span> 派生的。</li>
</ul>
<figure>
<img src="https://pic.imgdb.cn/item/6136037244eaada739e72677.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>现在你会获得 <span class="math inline">\(n(n\le 1000)\)</span> 个要按顺序处理的类声明，并确定每个类声明是否是正确声明。</p>
<p>正确声明的类被添加到层次结构中，而错误的类被丢弃。声明 “<span class="math inline">\(K : P_1\ P_2\ \dots\ P_K;\)</span>” 如果满足以下条件，则认为是正确声明：</p>
<ol type="1">
<li>类 <span class="math inline">\(K\)</span> 尚未声明。</li>
<li>所有类别 <span class="math inline">\(P_1,P_2,\dots,P_k\)</span> 之前已经声明过。请注意，此条件可确保类永远不会从其自身派生，或者类层次结构中不能存在循环。</li>
<li>通过添加继承了 <span class="math inline">\(P_1,P_2,\dots,P_k\)</span> 的类 <span class="math inline">\(K\)</span> 以后，类层次结构保持有序，即没有形成任何菱形。</li>
</ol>
<p>现在需要你分别处理上述声明并确定每个声明的正确性。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>直接考虑性质三：简单分析“菱形”的性质，不难发现不存在菱形的前提是所有的 <span class="math inline">\(P_i\)</span> 要么是严格的祖孙关系，要么毫无关系，总之不能为旁系亲属，发现如果当前语句合法，那么所有的 <span class="math inline">\(P_i\)</span> 的旁系亲属都是当前 <span class="math inline">\(K\)</span> 的旁系亲属，很好维护，但是直接用 <code>bool</code> 数组维护关系的话时间复杂度为 <span class="math inline">\(O(n^3)\)</span>，不能接受，又发现维护的值要么是 <span class="math inline">\(0\)</span> 要么是 <span class="math inline">\(1\)</span>，且支持位运算，直接上 <code>bitset</code>，时间复杂度优化到 <span class="math inline">\(O(\dfrac{n^3}{w})\)</span>，可以艹过去了。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line">string s, t;</span><br><span class="line"><span class="keyword">int</span> n, cnt, tcnt, q[N];</span><br><span class="line"></span><br><span class="line">map &lt;string, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">bitset &lt;1010&gt; f[N], b[N], tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tmp.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tcnt; ++ i)</span><br><span class="line">      tmp[q[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tcnt; ++ i)</span><br><span class="line">      <span class="keyword">if</span> ((tmp &amp; b[q[i]]).<span class="built_in">any</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n; <span class="keyword">int</span> is_wrong = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        is_wrong = tcnt = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; s; cin &gt;&gt; t; cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mp[t]) is_wrong |= <span class="number">1</span>;</span><br><span class="line">            q[++ tcnt] = mp[t]; cin &gt;&gt; t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>()) is_wrong |= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_wrong || mp[s]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;greska\n&quot;</span>; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ok\n&quot;</span>; mp[s] = ++ cnt;</span><br><span class="line">        f[cnt][cnt] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tcnt; ++ j)</span><br><span class="line">          f[cnt] |= f[q[j]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cnt; ++ j)</span><br><span class="line">          <span class="keyword">if</span> (!f[cnt][j] &amp;&amp; (f[j] &amp; f[cnt]).<span class="built_in">any</span>()) &#123;</span><br><span class="line">              b[cnt][j] = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-子图">#T4 子图</h2>
<h3 id="题意简述-3">#题意简述</h3>
<blockquote>
<p>依旧是不好简述，上原题面。</p>
</blockquote>
<p>Cuber QQ 的研究兴趣是在图 <span class="math inline">\(G=(V(G),E(G))\)</span> 中找到最好的 <span class="math inline">\(k\)</span>-degree 子图。</p>
<p>子图 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(G\)</span> 的 <span class="math inline">\(k\)</span>-degree 子图需要满足以下要求：</p>
<ul>
<li>每个顶点 <span class="math inline">\(v(v\in S)\)</span> 在 <span class="math inline">\(S\)</span> 中至少有 <span class="math inline">\(k\)</span> 度；</li>
<li><span class="math inline">\(S\)</span> 是连通的 ;</li>
<li><span class="math inline">\(S\)</span> 是极大的，即 <span class="math inline">\(S\)</span> 的任何超图都不是 <span class="math inline">\(k\)</span>-degree 子图，除了 <span class="math inline">\(S\)</span> 本身。</li>
</ul>
<figure>
<img src="https://pic.imgdb.cn/item/6136098b44eaada739f1ee29.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>然后 Cuber QQ 定义子图 <span class="math inline">\(S\)</span> 的分数。在定义分数之前，他首先定义：</p>
<ul>
<li><span class="math inline">\(n(S)\)</span>：子图 <span class="math inline">\(S\)</span> 中的顶点数，即 <span class="math inline">\(n(S)=|V(S)|\)</span>；</li>
<li><span class="math inline">\(m(S)\)</span>：子图 <span class="math inline">\(S\)</span> 的边数，即 <span class="math inline">\(m(S)=|E(S)|\)</span>；</li>
<li><span class="math inline">\(b(S)\)</span>：子图 <span class="math inline">\(S\)</span> 中的边界边数，<span class="math inline">\(b(S)=|{(u,v)|(u,v)∈E(G),u∈V(S),v∉V(S),v∈V(G)}|\)</span>;</li>
</ul>
<p>他定义一个子图的分数为 <span class="math inline">\(score(S)=M\cdot m(S)−N\cdot n(S)+B\cdot b(S)\)</span>，其中 <span class="math inline">\(M,N,B\)</span> 是给定的常数。</p>
<p>子图的分数越高，Cuber QQ 认为它越好。你需要在图 <span class="math inline">\(G\)</span> 中找到最好的 <span class="math inline">\(k\)</span>-degree 子图。如果有许多 <span class="math inline">\(k\)</span>-degree 子图的分数相同，则应最大化 <span class="math inline">\(k\)</span>。输出最大的分数及对应的 <span class="math inline">\(k\)</span>.</p>
<h3 id="大体思路-3">#大体思路</h3>
<p>首先，如果不考虑连通性问题，那么 <span class="math inline">\((k+1)\)</span>-degree 一定是 <span class="math inline">\(k\)</span>-degree 的子图，于是我们可以先求得一个<strong>标记</strong>，如果一个点属于 <span class="math inline">\(k\)</span>-degree 而不属于 <span class="math inline">\(k+1\)</span>-degree，那么该点标记为 <span class="math inline">\(k\)</span>，求得这个标记的过程可以通过像剥卷心菜一样将原图层层剥开，具体细节我们留到后面去说；</p>
<p>假设我们已经求得了每个点的标记，再来考虑通过将<del>卷心菜</del>原图一层层还原回去得到每个 <span class="math inline">\(k\)</span>-degree 的 score；显然我们是通过加入标记为 <span class="math inline">\(k\)</span> 的点得到 <span class="math inline">\(k\)</span>-degree，考虑单个新加入的点，他们对 <span class="math inline">\(n,m,b\)</span> 的贡献分别是什么。</p>
<p>先来引入一些新记号：</p>
<ul>
<li><span class="math inline">\(E(u,&gt;)\)</span> 表示 <span class="math inline">\(u\)</span> 的边中另一个点标记比 <span class="math inline">\(u\)</span> 大的边的集合；</li>
<li><span class="math inline">\(E(u,&lt;)\)</span> 表示 <span class="math inline">\(u\)</span> 的边中另一个点标记比 <span class="math inline">\(u\)</span> 小的边的集合；</li>
<li><span class="math inline">\(E(u,=)\)</span> 表示 <span class="math inline">\(u\)</span> 的边中另一个点 <span class="math inline">\(v\)</span> 标记与 <span class="math inline">\(u\)</span> 相等但 <span class="math inline">\(v&gt;u\)</span> 的边的集合；</li>
</ul>
<p>现在不难写出新的贡献：</p>
<ul>
<li><span class="math inline">\(\Delta n=1\)</span>；</li>
<li><span class="math inline">\(\Delta m=|E(u,&gt;)|+|E(u,=)|\)</span>；</li>
<li><span class="math inline">\(\Delta b=|E(u,&lt;)|-|E(u,&gt;)|\)</span>；</li>
</ul>
<p>在合并的过程中，可能会导致几个连通块合成一个连通块，可以采用并查集提前维护出各个连通块的代表元素，代表元应当是整个连通块中标记最小的点，这样才能正确地完成合并。为下面合并答案，同时记录每个小连通块合并后的大连通块的编号，以及当前连通块的 <span class="math inline">\(k\)</span>.</p>
<p>并查集采用按秩合并+路径压缩，总体时间复杂度为 <span class="math inline">\(O(m+n)\)</span>，下面的代码仅采用了路径压缩，总体时间复杂度为 <span class="math inline">\(O(m\log n+n)\)</span>.</p>
<h3 id="一些细节实现">#一些细节实现</h3>
<p>获取标记时，先用桶排将所有点按照度数从小到大排序，我们自小到大遍历这个序列，对于每个点，将与其相连的所有度数<strong>大于</strong>该点度数的点的度数减一，同时直接改变其在数列中的位置，将其放到原本度数的开头位置，对应度数的开头位置后移一位，这样维护可以保证在任意时刻队列中都是有序的。考虑为什么只有度数大于该点的点需要改变度数：小于该点的意味着已经被遍历，其度数就是其标记；等于该点的点，显然应当与该点属于同一层，直接保留度数作为标记；对于大于的，根据 <span class="math inline">\(k\)</span>-degree 的定义，如果不在同一层，当前边贡献的度数显然不符合要求，应当减去，如果应当在同一层，那么由于处理完的度数对应的应当是正确的标记，而当前大于正确标记，应当减去。</p>
<p>详细见下方代码。</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VI vector <span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;ll, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UFS</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N]; <span class="keyword">int</span> *d_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> *d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= x; ++ i) fa[i] = i;</span><br><span class="line">        <span class="keyword">this</span>-&gt;d_ = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != fa[x]) x = fa[x] = fa[fa[x]];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x != y)  &#123;</span><br><span class="line">            <span class="keyword">if</span> ((d_[x] &gt; d_[y]) || (d_[x] == d_[y] &amp;&amp; x &gt; y))</span><br><span class="line">              <span class="built_in">swap</span>(y, x);</span><br><span class="line">            fa[y] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, d[N], head[N], <span class="built_in">ecnt</span>(<span class="number">1</span>), cbtot;</span><br><span class="line"><span class="keyword">int</span> frt, tal, q[N], pos[N], bin[N], max_k, cb_id[N];</span><br><span class="line"><span class="keyword">int</span> inq[N], kpc[N], kcnt; ll A, B, C;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; tk, pa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v; ++ d[u];</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Get_Tags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_d = <span class="number">0</span>, st = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      ++ bin[d[i]], max_d = <span class="built_in">Max</span>(max_d, d[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_d; ++ i)</span><br><span class="line">      now = bin[i], bin[i] = st, st += now;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      pos[i] = bin[d[i]] ++, q[pos[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = max_d; i; -- i) bin[i] = bin[i - <span class="number">1</span>];</span><br><span class="line">    bin[<span class="number">0</span>] = <span class="number">0</span>, bin[max_d + <span class="number">1</span>] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = q[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[v]; j; j = e[j].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = e[j].v;</span><br><span class="line">            <span class="keyword">if</span> (d[u] &gt; d[v]) &#123;</span><br><span class="line">                <span class="keyword">int</span> du = d[u], pu = pos[u];</span><br><span class="line">                <span class="keyword">int</span> pw = bin[du], w = q[pw];</span><br><span class="line">                <span class="keyword">if</span> (u != w) &#123;</span><br><span class="line">                    pos[u] = pw, q[pu] = w;</span><br><span class="line">                    pos[w] = pu, q[pw] = u;</span><br><span class="line">                &#125; ++ bin[du], -- d[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      max_k = <span class="built_in">Max</span>(max_k, d[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Get_Connected_Blocks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ufs.<span class="built_in">init</span>(n, d); pa.<span class="built_in">push_back</span>(<span class="number">0</span>); tk.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k; -- k) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = bin[k], r = bin[k + <span class="number">1</span>] - <span class="number">1</span>; kcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q[i]; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = head[v]; j; j = e[j].nxt)&#123;</span><br><span class="line">                <span class="keyword">int</span> u = e[j].v;</span><br><span class="line">                <span class="keyword">int</span> fp = ufs.<span class="built_in">find</span>(u);</span><br><span class="line">                <span class="keyword">if</span> (d[fp] &gt; k) <span class="keyword">if</span> (!inq[fp])</span><br><span class="line">                  kpc[++ kcnt] = fp, inq[fp] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (d[fp] &gt;= k) ufs.<span class="built_in">merge</span>(v, fp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q[i], fp = ufs.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (!cb_id[fp]) &#123;</span><br><span class="line">                cb_id[fp] = ++ cbtot;</span><br><span class="line">                pa.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">                tk.<span class="built_in">push_back</span>(d[fp]);</span><br><span class="line">            &#125;</span><br><span class="line">            cb_id[v] = cb_id[fp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kcnt; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = kpc[i], fp = ufs.<span class="built_in">find</span>(v);</span><br><span class="line">            pa[cb_id[v]] = cb_id[fp]，inq[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compute_the_Answer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">VI <span class="title">vert</span><span class="params">(cbtot + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">edge</span><span class="params">(cbtot + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">boun</span><span class="params">(cbtot + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ci = d[i], lt = <span class="number">0</span>, eq = <span class="number">0</span>, gt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j; j = e[j].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> nbr = e[j].v, cnbr = d[nbr];</span><br><span class="line">            <span class="keyword">if</span> (cnbr &lt; ci) ++ lt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnbr == ci) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; nbr) ++ eq;</span><br><span class="line">            &#125; <span class="keyword">else</span> ++ gt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ti = cb_id[i]; ++ vert[ti];</span><br><span class="line">        edge[ti] += gt + eq; boun[ti] += lt - gt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pii <span class="title">ans</span><span class="params">(<span class="number">1ll</span> * (<span class="number">-1e18</span>), <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cbtot; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = pa[i];</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="number">-1</span>)</span><br><span class="line">          vert[f] += vert[i], edge[f] += edge[i], boun[f] += boun[i];</span><br><span class="line">        ll score = A * edge[i] - B * vert[i] + C * boun[i];</span><br><span class="line">        <span class="keyword">if</span> (tk[i] &gt; <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, &#123;score, tk[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %lld\n&quot;</span>, ans.second, ans.first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;A, &amp;B, &amp;C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v); <span class="built_in">add_edge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Get_Tags</span>(); <span class="built_in">Get_Connected_Blocks</span>();</span><br><span class="line">    <span class="built_in">Compute_the_Answer</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP10连-DAY2 总结</title>
    <url>/2021/09/06/ZROI-21-NOIP-DAY2/</url>
    <content><![CDATA[<h2 id="t1-比赛">#T1 比赛</h2>
<h3 id="题意简述">#题意简述</h3>
<p>有 <span class="math inline">\(2^n(n\le15)\)</span> 个人玩剪刀石头布，每个人出的手式固定，已知有 <span class="math inline">\(r\)</span> 个石头，<span class="math inline">\(p\)</span> 个布，<span class="math inline">\(s\)</span> 个剪刀，每一轮让相邻奇偶位的人玩，赢得进入下一轮，要求构造一种安排方式使得游戏最终一定有一个赢家。<strong>多组数据</strong>。</p>
<h3 id="大体思路">#大体思路</h3>
<p>不难想到如果要出某个手势的人胜利，那么整个匹配树（恰好是完全二叉树）上的每一层节点包含的 <span class="math inline">\(R,P,S\)</span> 的个数一定是确定的，于是便可以提前计算出不同层数的匹配树的不同根时的 <span class="math inline">\(R,P,S\)</span> 分别有多少个，可以直接判无解的情况。</p>
<p>同样的，我们也可以直接构造出一组合法的解（不一定字典序最小），最后我们只需要取出对应层上的解并进行排序即可。</p>
<p>关于这里的排序，我们不难发现交换顺序只能是二叉树的一个结点的左右儿子进行交换，于是我们可以选择递归进行合并式的排序，这里笔者怕传参出现问题，直接写成非递归形式，模拟自下而上地合并，时间复杂度为 <span class="math inline">\(O(2^n\log 2^n)=O(n2^n)\)</span>.</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, r, p, s, a[<span class="number">3</span>][<span class="number">20</span>][N], cnt[<span class="number">3</span>][<span class="number">20</span>][<span class="number">3</span>], lg[N], ans[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; ++ i)</span><br><span class="line">      lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">mset</span>(a, <span class="number">-1</span>); a[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>, a[<span class="number">2</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">16</span>; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>); j &lt; (<span class="number">1</span> &lt;&lt; i); ++ j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; ++ k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[k][i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                a[k][i + <span class="number">1</span>][j &lt;&lt; <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                a[k][i + <span class="number">1</span>][j &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k][i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                a[k][i + <span class="number">1</span>][j &lt;&lt; <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                a[k][i + <span class="number">1</span>][j &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k][i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                a[k][i + <span class="number">1</span>][j &lt;&lt; <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                a[k][i + <span class="number">1</span>][j &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cnt[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = cnt[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = cnt[<span class="number">2</span>][<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">16</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++ j) &#123;</span><br><span class="line">            cnt[<span class="number">0</span>][i][j] = cnt[<span class="number">0</span>][i - <span class="number">1</span>][j] + cnt[<span class="number">1</span>][i - <span class="number">1</span>][j];</span><br><span class="line">            cnt[<span class="number">1</span>][i][j] = cnt[<span class="number">1</span>][i - <span class="number">1</span>][j] + cnt[<span class="number">2</span>][i - <span class="number">1</span>][j];</span><br><span class="line">            cnt[<span class="number">2</span>][i][j] = cnt[<span class="number">0</span>][i - <span class="number">1</span>][j] + cnt[<span class="number">2</span>][i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span>; o &lt;= <span class="number">2</span>; ++ o)</span><br><span class="line">      <span class="keyword">if</span> (cnt[o][n][<span class="number">0</span>] == i &amp;&amp; cnt[o][n][<span class="number">1</span>] == j &amp;&amp; cnt[o][n][<span class="number">2</span>] == k)</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="built_in">get_base</span>();</span><br><span class="line">    <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;r, &amp;p, &amp;s);</span><br><span class="line">        <span class="keyword">int</span> n = r + p + s;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="built_in">check</span>(lg[n], p, r, s);</span><br><span class="line">        <span class="keyword">if</span> (!(~op)) &#123;<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="comment">/*取出答案*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; (lg[n] - <span class="number">1</span>); i &lt; <span class="number">1</span> &lt;&lt; lg[n]; ++ i)</span><br><span class="line">          ans[i - (<span class="number">1</span> &lt;&lt; (lg[n] - <span class="number">1</span>)) + <span class="number">1</span>] = a[op][lg[n]][i];</span><br><span class="line">        <span class="comment">/*以下是对答案进行排序*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j += i)</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i &gt;&gt; <span class="number">1</span>; ++ k) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (ans[j + k - <span class="number">1</span>] &lt; ans[j + (i &gt;&gt; <span class="number">1</span>) + k - <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">if</span> (ans[j + k - <span class="number">1</span>] &gt; ans[j + (i &gt;&gt; <span class="number">1</span>) + k - <span class="number">1</span>]) &#123;</span><br><span class="line">                      <span class="keyword">for</span> (<span class="keyword">int</span> l = j; l &lt;= j + (i &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; ++ l)</span><br><span class="line">                        <span class="built_in">swap</span>(ans[l], ans[l + (i &gt;&gt; <span class="number">1</span>)]);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="keyword">if</span> (ans[i] == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;P&quot;</span>);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (ans[i] == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (ans[i] == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;S&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-幸运数字">#T2 幸运数字</h2>
<h3 id="题意简述-1">#题意简述</h3>
<p>给定一个数 <span class="math inline">\(a(a\in Z^+)\)</span> 和一个数位集合 <span class="math inline">\(d_1\dots d_k\)</span>，求一个最小的 <span class="math inline">\(b=da(d\in Z^+)\)</span> 满足 <span class="math inline">\(b\)</span> 没有前缀 <span class="math inline">\(0\)</span>，且不包含 <span class="math inline">\(d_1\dots d_k\)</span> 中的任意一个数位。</p>
<p>无解输出 <span class="math inline">\(-1\)</span>，保证答案<strong>位数</strong>小于等于 <span class="math inline">\(10^6\)</span>.</p>
<h3 id="大体思路-1">#大体思路</h3>
<p>乍一看会以为是数位 DP，但是显然答案范围太大了，不是数位 DP 可以处理的，注意到比较难处理的是<strong>倍数</strong>这一条件，考虑从倍数的性质入手，怎样的数是 <span class="math inline">\(a\)</span> 的倍数呢？应当是 <span class="math inline">\(\bmod a=0\)</span> 的数，这样的一个数 <span class="math inline">\(x\)</span> 显然可以通过一个 <span class="math inline">\(\bmod a\ne0\)</span> 的数 <span class="math inline">\(\left\lfloor\frac{x}{10}\right\rfloor\)</span> 后面加上 <span class="math inline">\([0,9]\)</span> 中的一位得到。</p>
<p>再来考虑模 <span class="math inline">\(a\)</span> 得到的余数是如何变化的，不难想到对于一个 <span class="math inline">\(\bmod a=x\)</span> 的数 <span class="math inline">\(\alpha\)</span>，后面加上一位 <span class="math inline">\(y\)</span>，新的余数应当是 <span class="math inline">\((x\times10+y)\bmod a\)</span>，发现对于同一个 <span class="math inline">\(y\)</span>，得到的余数结果与 <span class="math inline">\(\alpha\)</span> 无关，只与 <span class="math inline">\(x\)</span> 有关，而我们要求最小的答案，所以对于余数相同的只需要知道最小的是谁就好，那么这个过程可以枚举下一位是什么用 bfs 实现。</p>
<p>最差情况下 <span class="math inline">\(a\)</span> 的每一个余数都被遍历到，时间复杂度为 <span class="math inline">\(O(a)\)</span>.</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> val, pre, mod;&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, vis[N], ctuse[<span class="number">10</span>], cnt, tal;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123;<span class="keyword">return</span>;&#125; <span class="built_in">print</span>(p[x].pre); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[x].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        ctuse[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = (Node)&#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;; q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>(), i = <span class="number">0</span>; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (p[now].mod == <span class="number">0</span>) i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= <span class="number">9</span>; ++ i) <span class="keyword">if</span> (!ctuse[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> nmod = (p[now].mod * <span class="number">10</span> + i) % n;</span><br><span class="line">            <span class="keyword">if</span> (!vis[nmod]) &#123;</span><br><span class="line">                vis[nmod] = <span class="number">1</span>; p[++ cnt] = (Node)&#123;i, now, nmod&#125;;</span><br><span class="line">                <span class="keyword">if</span> (!nmod) &#123;tal = cnt; <span class="built_in">print</span>(tal); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">                q.<span class="built_in">push</span>(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3-匹配">#T3 匹配</h2>
<h3 id="题意简述-2">#题意简述</h3>
<p>给定一个 <span class="math inline">\(2n\)</span> 个点的二分图，最初有 <span class="math inline">\(m\)</span> 条边，要求添加尽可能少的边，使得无论怎么选 <span class="math inline">\(n\)</span> 条边，都可以得到一张完全二分图。</p>
<h3 id="大体思路-2">#大体思路</h3>
<p>首先不难得到 <span class="math inline">\(2n\)</span> 个点的联通块，其中左部点和右部点数量相同（即为二分图），如果要满足题目条件，需要 <span class="math inline">\(n^2\)</span> 条边，也就是对于每一个左部点向任意一个右部点都有边，否则一定存在一种选边方法使得无法满足条件，证明不难，略。</p>
<p>于是最差的情况不过是要连 <span class="math inline">\(n^2-m\)</span> 条边。之后的想法便是不断考虑将几个联通块合成一个，而这样的需要添加边数与联通块的形态显然无关，只与已有边数有关，但可以到最后一起减去，于是之后便是不断考虑结合单点合成联通块，通过搜索剪枝进行更新答案，本质不同的联通块个数不多，可通过 DP 计算得到，于是时间复杂度得到保证。详细实现请结合代码理解。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> t, n, m, fa[N], lsiz[N], rsiz[N], ans, sum, vis[N];</span><br><span class="line"></span><br><span class="line">vector &lt;pii &gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x * x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; ++ i)</span><br><span class="line">      fa[i] = i, lsiz[i] = (i &lt;= n), rsiz[i] = (i &gt; n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">      x = fa[x] = fa[fa[x]];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">        lsiz[y] += lsiz[x];</span><br><span class="line">        rsiz[y] += rsiz[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参数分别代表已经处理的联通块个数，选择的上一个要合成的联通块的位置*/</span></span><br><span class="line"><span class="comment">/*单个左部点个数，单个右部点个数，当前并入的联通块多出的右部点个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> lst, <span class="keyword">int</span> tot, <span class="keyword">int</span> ltot, <span class="keyword">int</span> rtot, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum + <span class="built_in">Max</span>(ltot, rtot) &gt;= ans) <span class="keyword">return</span>; <span class="comment">//剪枝，显然不会有更优贡献</span></span><br><span class="line">    <span class="keyword">if</span> (!(~lst)) &#123; <span class="comment">//尝试更新答案</span></span><br><span class="line">        <span class="keyword">if</span> (k == v.<span class="built_in">size</span>()) &#123;ans = <span class="built_in">Min</span>(ans, sum + ltot); <span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sum += <span class="built_in">calc</span>(tot + <span class="built_in">Max</span>(<span class="number">0</span>, delta));</span><br><span class="line">        <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ltot &gt;= delta) <span class="built_in">dfs</span>(k, <span class="number">-1</span>, <span class="number">0</span>, ltot - delta, rtot, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rtot + delta &gt;= <span class="number">0</span>) <span class="built_in">dfs</span>(k, <span class="number">-1</span>, <span class="number">0</span>, ltot, rtot + delta, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="comment">//回溯</span></span><br><span class="line">        sum -= <span class="built_in">calc</span>(tot + <span class="built_in">Max</span>(<span class="number">0</span>, delta));</span><br><span class="line">    &#125;</span><br><span class="line">    pii now = <span class="built_in">mp</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lst + <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">      <span class="keyword">if</span> (!vis[i] &amp;&amp; v[i] != now) &#123;</span><br><span class="line">          <span class="comment">/*相同形态的没必要进行反复查询*/</span></span><br><span class="line">          now = v[i]; vis[i] = <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">dfs</span>(k + <span class="number">1</span>, i, tot + v[i].first, ltot, rtot, delta - v[i].first + v[i].second);</span><br><span class="line">          vis[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="built_in">init</span>(); v.<span class="built_in">clear</span>();</span><br><span class="line">        ans = n * n, sum = m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">              <span class="keyword">if</span> (s[j] == <span class="string">&#x27;1&#x27;</span>) ++ m, <span class="built_in">merge</span>(i, j + n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ltot = <span class="number">0</span>, rtot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; ++ i)</span><br><span class="line">          <span class="keyword">if</span> (fa[i] == i) &#123;</span><br><span class="line">              <span class="keyword">if</span> (lsiz[i] == rsiz[i])</span><br><span class="line">                sum += <span class="built_in">calc</span>(lsiz[i]);</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (!lsiz[i]) ++ rtot;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (!rsiz[i]) ++ ltot;</span><br><span class="line">              <span class="keyword">else</span> v.<span class="built_in">push_back</span>(<span class="built_in">mp</span>(lsiz[i], rsiz[i]));</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, ltot, rtot, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans - m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-拓扑">#T4 拓扑</h2>
<h3 id="题意简述-3">#题意简述</h3>
<p>有一张有向图，有 <span class="math inline">\(2n^2\)</span>个点，分成 <span class="math inline">\(n\)</span> 组，每组 <span class="math inline">\(2n\)</span> 个点。</p>
<p>对于每一组内，对于所有 <span class="math inline">\(1\le i&lt;n\)</span> 都有 <span class="math inline">\(i\to i+1,n+i\to n+i+1\)</span> 的边，对于所有 <span class="math inline">\(1\le i\le n\)</span> 都有 <span class="math inline">\(i\to n+i\)</span> 的边。</p>
<p>然后对于所有 <span class="math inline">\(2\le i\le n\)</span>，第 <span class="math inline">\(1\)</span> 组的 <span class="math inline">\(i+n−1\)</span> 号点向第 <span class="math inline">\(i\)</span> 组的 <span class="math inline">\(1\)</span> 号，第 <span class="math inline">\(1\)</span> 组的 <span class="math inline">\(i\)</span> 号点向第 <span class="math inline">\(i\)</span> 组的 <span class="math inline">\(n+1\)</span> 号点都有连边。求这张图的拓扑序个数，答案很大，对读入的 <span class="math inline">\(p\)</span> 取模。</p>
<p>例如 <span class="math inline">\(n=3\)</span> 的时候图长这样：</p>
<p><img src="https://pic.imgdb.cn/item/6135690144eaada739ddabcc.png" /></p>
<h3 id="大体思路-3">#大体思路</h3>
<p>这种计数问题很大概率是 DP，题目中给出的图已经很好的展现了整张图的性质，即如果已经选择了 <span class="math inline">\((1,i)\)</span> 号点，且又选择了 <span class="math inline">\((1, n+i-1)\)</span> 号点，那么就有一组点完全独立出来了，这时第一组怎么选已经影响不到这一组选择的顺序了，于是我们考虑对于第一组点做 DP。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示当前第一组第一行选了 <span class="math inline">\(i\)</span> 个点，第二行选了 <span class="math inline">\(j\)</span> 个点的方案数，我们做如下讨论：</p>
<ul>
<li>下一步再选第一行的下一个点，那么直接将 <span class="math inline">\(f_{i,j}\)</span> 加到 <span class="math inline">\(f_{i+1,j}\)</span> 中即可；</li>
<li>下一步选第二行的下一个点，
<ul>
<li>如果当前 <span class="math inline">\(j&lt;i-1\)</span>，那么意味着此时会有新的一组解锁，这一组完全独立，在后面所有的位置中选出 <span class="math inline">\(2n\)</span> 个位置，并算出选这一组可行的排列数量（设为 <span class="math inline">\(g\)</span>，后面会讲如何递推 <span class="math inline">\(g\)</span>），乘上此时的 <span class="math inline">\(f\)</span> 贡献到 <span class="math inline">\(f_{i,j+1}\)</span> 即可；</li>
<li>否则选完之后，对于第一组下一步一定是接着选第一行的下一个，所以可以直接贡献到 <span class="math inline">\(f_{i+1,j+1}\)</span>，但是在选第一行下一个前，可以先从第 <span class="math inline">\(j+1\)</span> 组中选出 <span class="math inline">\(k\)</span> 个，这一部分的贡献同样可以通过组合数计算位置个数乘上 <span class="math inline">\(g\)</span> 得到；</li>
</ul></li>
</ul>
<p>上面就是 <span class="math inline">\(f\)</span> 的递推过程，来看如何递推 <span class="math inline">\(g\)</span>；设 <span class="math inline">\(g_{i,j}\)</span> 表示单独一组第一行选了 <span class="math inline">\(i\)</span> 个，第二行选了 <span class="math inline">\(j\)</span> 个，此时<strong>剩下的部分</strong>可行的拓扑序数量，对于 <span class="math inline">\(i&gt;j\)</span> 的情况，下一步可以选第一行的，也可以选第二行的，于是就有 <span class="math display">\[
g_{i,j}=g_{i+1,j}+g_{i,j+1},\tag{1}
\]</span> 当 <span class="math inline">\(i&lt;j\)</span> 时，不合法，规定这样的可行数量为 <span class="math inline">\(0\)</span>，当 <span class="math inline">\(i=j\)</span> 时，应当只能选第一行的，但根据我们上面 <span class="math inline">\(i&lt;j\)</span> 时的定义，发现此时仍然适用式 <span class="math inline">\((1)\)</span>，所以不必特判。</p>
<p>边界是 <span class="math inline">\(g_{n,n}=1\)</span>.</p>
<h3 id="code-3">#Code</h3>
<blockquote>
<p>常数大的离谱，荣登最劣解（</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">20000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, MOD; ll f[N][N], g[N][N];</span><br><span class="line"><span class="keyword">int</span> fac[M], inv[M], invf[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a - b &lt; MOD &amp;&amp; MOD &lt;= a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[a] * inv[b] % MOD * inv[a - b] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;MOD); m = <span class="number">2</span> * n * n;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (i == MOD) fac[i] = fac[i - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">else</span> fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; M; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= MOD) inv[i] = inv[i - MOD];</span><br><span class="line">      <span class="keyword">else</span> inv[i] = <span class="number">1ll</span> * (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; ++ i)</span><br><span class="line">      inv[i] = <span class="number">1ll</span> * inv[i - <span class="number">1</span>] * inv[i] % MOD;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, g[n][n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; ~i; -- i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">Min</span>(n - <span class="number">1</span>, i); ~j; -- j)</span><br><span class="line">        g[i][j] = (g[i + <span class="number">1</span>][j] + g[i][j + <span class="number">1</span>]) % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++ j) &#123;</span><br><span class="line">          <span class="keyword">int</span> rest = <span class="number">2</span> * n * (n - j) - i - j;</span><br><span class="line">          <span class="keyword">if</span> (j == i - <span class="number">1</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (i == n) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[i][j]); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">              (f[i + <span class="number">1</span>][j + <span class="number">1</span>] += <span class="number">1ll</span> * f[i][j] * <span class="built_in">C</span>(rest - <span class="number">2</span>, n &lt;&lt; <span class="number">1</span>) % MOD * g[<span class="number">1</span>][<span class="number">0</span>] % MOD) %= MOD;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">                (f[i + <span class="number">1</span>][j + <span class="number">1</span>] += <span class="number">1ll</span> * f[i][j] * <span class="built_in">C</span>(rest - k - <span class="number">2</span>, (n &lt;&lt; <span class="number">1</span>) - k) % MOD * g[k][<span class="number">0</span>] % MOD) %= MOD;</span><br><span class="line">          &#125; <span class="keyword">else</span> (f[i][j + <span class="number">1</span>] += <span class="number">1ll</span> * f[i][j] * <span class="built_in">C</span>(rest - <span class="number">1</span>, n &lt;&lt; <span class="number">1</span>) % MOD * g[<span class="number">1</span>][<span class="number">0</span>] % MOD) %= MOD;</span><br><span class="line">          <span class="keyword">if</span> (i &lt; n) (f[i + <span class="number">1</span>][j] += f[i][j]) %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」POJ3419 Difference Is Beautiful</title>
    <url>/2021/09/04/POJ3419/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://poj.org/problem?id=3419">题目链接</a></p>
</blockquote>
<h2 id="题意简述">#1.0 题意简述</h2>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列，<span class="math inline">\(q\)</span> 个询问，每次询问区间 <span class="math inline">\([L,R]\)</span> 中最长的可行连续子序列的长度。定义一个序列为可行序列，当且仅当该序列中所有数字出现次数 <span class="math inline">\(\le1\)</span>。</p>
<h2 id="大体思路">#2.0 大体思路</h2>
<p>不难发现答案具有二分性，于是可以采用二分答案，来考虑如何判断是否可行。</p>
<p>首先不难想到可以尝试对于每个 <span class="math inline">\(l\)</span> 找到满足 <span class="math inline">\([l,r]\)</span> 是可行序列的最大的 <span class="math inline">\(r\)</span>，记录其最大长度，长度数组记为 <span class="math inline">\(a_i\)</span>，这一步通过<strong>双指针</strong>可以 <span class="math inline">\(O(n)\)</span> 解决。之后我们的判定就变成了对于 <span class="math inline">\(x\)</span>，判断在 <span class="math inline">\([L,R-x+1]\)</span> 中是否存在一个位置 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(a_i\ge x\)</span>，也就可以转化为判断 <span class="math display">\[
\max_{L\le i\le R-x+1}\{a_i\}\ge x
\]</span> 是否为真，前面的部分是经典的 RMQ 问题，可以用 st 表解决，总体时间复杂度为 <span class="math inline">\(O(n\log n+q\log n)\)</span>.</p>
<h2 id="code">#3.0 Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4000100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], len[N];</span><br><span class="line"><span class="keyword">int</span> vis[N], st[N][<span class="number">30</span>], lg2[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_len</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= n; ++ l) &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; !vis[a[r + <span class="number">1</span>]])</span><br><span class="line">          ++ r, vis[a[r]] = <span class="number">1</span>;</span><br><span class="line">        len[l] = r - l + <span class="number">1</span>, vis[a[l]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">      lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">      st[i][<span class="number">0</span>] = len[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">22</span>; ++ j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) &lt;= n)</span><br><span class="line">          st[i][j] = <span class="built_in">Max</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> st[i][j] = st[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = lg2[r - l - x + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">Max</span>(st[l][L], st[r - x - (<span class="number">1</span> &lt;&lt; L) + <span class="number">2</span>][L]);</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        a[i] += <span class="number">1e6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_len</span>(); <span class="built_in">prework</span>();</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y); x ++, y ++;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = y - x + <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(x, y, mid))</span><br><span class="line">              ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」HDU5118 GRE Words Once More!</title>
    <url>/2021/09/04/HDU5118/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=5118">题目链接</a></p>
</blockquote>
<h2 id="题意简述">#1.0 题意简述</h2>
<p>给定一个 DAG，每条边有一个权值，DAG 上有些点为标记点，定义一个 GRE 为从 <span class="math inline">\(1\)</span> 号节点开始到任意标记点结束，所经过的路径上每个权值作为一位拼成的串；特别的，保证 <span class="math inline">\(1\)</span> 号点永远不是特殊点。</p>
<p>现在要求从 <span class="math inline">\(1\)</span> 号点开始的第 <span class="math inline">\(k\)</span> 小的 GRE 的长度。GRE 的比较方式如下：</p>
<ul>
<li>从头比较每一位，若前面都相等，那么当前位小的 GRE 更小；</li>
<li>若 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(B\)</span> 的一个前缀，那么 <span class="math inline">\(A&lt;B\)</span>；</li>
</ul>
<p><strong>多组数据</strong>，开始时会输入数据组数 <span class="math inline">\(T\)</span>.</p>
<h2 id="大体思路">#2.0 大体思路</h2>
<h3 id="比较简单但看起来很菜的做法">#2.1 比较简单<del>但看起来很菜</del>的做法</h3>
<p>首先不难想到，对于在 <span class="math inline">\(i\)</span> 号节点出发的 GRE，经过权值较小的边的 GRE 一定较小，于是不难想到一种暴力的做法：通过按照 GRE 大小进行 dfs，直接得到第 <span class="math inline">\(k\)</span> 小的 GRE 的长度，注意到由于 <span class="math inline">\(k\le10^8\)</span>，于是我们只用找到排名前 <span class="math inline">\(\min\{10^8,GRE\_tot\}\)</span> 的 GRE 的长度即可。</p>
<p>那么如何按照 GRE 大小进行 dfs 呢？这取决于存边的顺序，而输入的边没有顺序，于是这里采用 <code>vector</code> 存图，在 dfs 开始前现将每个点的出边按边权从小到大排序，这样存图的时间复杂度为 <span class="math inline">\(O(m\log m)\)</span>.</p>
<p>但是即使是只用找到排名前 <span class="math inline">\(\min\{10^8,GRE\_tot\}\)</span> 个 GRE 的长度，直接 dfs 也是无法保证时间复杂度的，所以我们需要考虑记忆化，考虑如何将之前的信息进行利用，不难发现，不论何时访问点 <span class="math inline">\(i\)</span>（即不论点 <span class="math inline">\(i\)</span> 前的 GRE 片段是什么），从点 <span class="math inline">\(i\)</span> 开始的 GRE 的相对大小是不变的，且在答案数组中一定是连续的，假设我们已经得到了第一次进入 <span class="math inline">\(i\)</span> 时的各个 GRE 的长度，不难想到当前这一次访问 <span class="math inline">\(i\)</span> 号节点得到的 GRE 长度，应当是第一次得到的长度减去第一次访问到 <span class="math inline">\(i\)</span> 时的深度，加上当前的深度。</p>
<p>而我们需要单独开数组保存第一次到达 <span class="math inline">\(i\)</span> 时，从 <span class="math inline">\(i\)</span> 出发的 GRE 长度吗？不需要，因为我们的答案数组就是 GRE 长度，而且由于每一次到达 <span class="math inline">\(i\)</span> 后从 <span class="math inline">\(i\)</span> 出发的 GRE 大小一定连续，所以我们只需要保存在答案数组中的开始位置和数量即可。</p>
<p>这样的话，整体时间复杂度为 <span class="math inline">\(O(m\log m+\min\{10^8,GRE\_tot\})\)</span>.</p>
<h3 id="比较困难但可以装b的做法">#2.1 比较困难<del>但可以装B</del>的做法</h3>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示从 <span class="math inline">\(i\)</span> 开始第 <span class="math inline">\(j\)</span> 小的 GRE 长度，考虑用一种数据结构进行维护，单个数据结构维护从 <span class="math inline">\(i\)</span> 开始的各个 GRE 长度，考虑转移过程，发现需要支持以下几种操作：</p>
<ul>
<li>合并两个数据结构</li>
<li>全局加一</li>
<li>插入一个结点</li>
</ul>
<p>以上三种操作都可以采用<strong>可持久化平衡树</strong>进行维护，同样的，当一棵树的大小超过 <span class="math inline">\(10^8\)</span>，就可以把多余的部分删去了。</p>
<p>实现时细节极多（当然我没实现，只是脑中 yy 了一下[doge]），这样的合并需要按照逆拓扑序进行遍历、合并，即建出原图的反图进行拓扑。由于同一棵平衡树可能需要合并多次，所以需要可持久化。由于是采用拓扑，所以不好控制遍历边的顺序，于是我们合并时同样需要先进行分裂，所以需要维护权值，再将当前平衡树合并进去，涉及到改变整棵平衡树的权值，需要进行打标记处理。</p>
<p>合并之后再将整棵平衡树点数维持在 <span class="math inline">\(10^8\)</span> 以内，多出的部分回收处理，所以还需要维护每个子树的大小。</p>
<p><del>总之就是很麻烦就对了。</del></p>
<h2 id="code">#3.0 Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIMIT = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">Edge</span> (<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _w) &#123;u = _u, v = _v, w = _w;&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> w &lt; x.w;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[N], n, m, q, sum, ans[M];</span><br><span class="line"><span class="keyword">int</span> tot[N], fv[N], fvd[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;G[u].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, w));&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= LIMIT) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (～tot[u]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot[u]; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= LIMIT) <span class="keyword">return</span>;</span><br><span class="line">            ans[++ sum] = ans[fv[u] + i] + dep - fvd[u];</span><br><span class="line">        &#125; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fv[u] = sum, fvd[u] = dep;</span><br><span class="line">    <span class="keyword">if</span> (s[u]) ans[++ sum] = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++ i)</span><br><span class="line">      <span class="built_in">dfs</span>(G[u][i].v, dep + <span class="number">1</span>);</span><br><span class="line">    tot[u] = sum - fv[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= T; ++ t) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q); s[<span class="number">1</span>] = sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            <span class="built_in">add_edge</span>(u, v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">mset</span>(tot, <span class="number">-1</span>); <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= sum) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[x]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」HDU5756 Boss Bo</title>
    <url>/2021/09/03/HDU5756/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=5756">题目链接</a></p>
</blockquote>
<h2 id="题意简述">#1.0 题意简述</h2>
<p>给定一棵以 <span class="math inline">\(1\)</span> 为根的 <span class="math inline">\(n\)</span> 个点的树，<span class="math inline">\(q\)</span> 次询问，每次给定一个集合 <span class="math inline">\(\{a_1,a_2,\dots,a_k\}\)</span>，定义“可行点”为不属于给定集合中的任意一点的子树的点，给定点 <span class="math inline">\(p\)</span>，有以下三种询问：</p>
<ul>
<li>问 <span class="math inline">\(p\)</span> 到所有可行点的距离之和；</li>
<li>问 <span class="math inline">\(p\)</span> 到所有可行点的距离最小值；</li>
<li>问 <span class="math inline">\(p\)</span> 到所有可行点的距离最大值；</li>
</ul>
<p>定义树上每条边的长度为 <span class="math inline">\(1\)</span>，每个点到自己的距离为 <span class="math inline">\(0\)</span>，如果不存在可行点，则输出 <code>-1</code>。</p>
<p>本题<strong>强制在线</strong>，记上一次的答案为 <span class="math inline">\(lastans\)</span>，每次询问给出 <span class="math inline">\(p&#39;\)</span>，询问真正的 <span class="math inline">\(p\)</span> 为</p>
<p><span class="math display">\[
p=(p&#39;+lastans)\bmod n+1.
\]</span></p>
<p>若为第一个询问或上个询问答案为 <span class="math inline">\(-1\)</span>，则令 <span class="math inline">\(lastans=0.\)</span></p>
<p>有<strong>多组数据</strong>，直至读入文件结束符（EOF）程序停止。</p>
<h2 id="大体思路">#2.0 大体思路</h2>
<p>看到一个点被选中的影响是整棵子树，我们便考虑通过 dfn 序将树上的问题变成序列上的问题。如果我们当前序列保存的是 dfn 序为 <span class="math inline">\(i\)</span> 的点与 <span class="math inline">\(p\)</span> 的距离，那么问题变为了给定 <span class="math inline">\(k\)</span> 个区间，询问在 <span class="math inline">\([1,n]\)</span> 中去掉这 <span class="math inline">\(k\)</span> 个区间后，剩下所有区间的权值和/最小值/最大值。</p>
<p>那么现在来考虑对于每个点如何维护距离序列。</p>
<p>考虑从一个父节点进入其的一个儿子，发现该儿子的子树中的点的距离全部减少 <span class="math inline">\(1\)</span>，其余的点的距离全部增加 <span class="math inline">\(1\)</span>。因为整棵树以 <span class="math inline">\(1\)</span> 为根，所以可以通过一次 dfs 得到 <span class="math inline">\(p=1\)</span> 时的序列，之后的所有修改都可以从这个序列的基础上得到，不难想到此过程可以用可持久化线段树维护。</p>
<p>于是我们的具体实现流程为</p>
<ul>
<li>通过一次 dfs 得到 <span class="math inline">\(p=1\)</span> 时的序列和其他必要信息；</li>
<li>利用 dfs 得到的信息建出初始线段树，按 dfn 序通过区间修改得到各版本的序列；</li>
<li>处理每个询问，得到在 <span class="math inline">\([1,n]\)</span> 中去掉这 <span class="math inline">\(k\)</span> 个区间后，剩下所有区间的答案；</li>
</ul>
<p>对于每个询问，最多会要查询 <span class="math inline">\(k+1\)</span> 个区间，于是时间复杂度为 <span class="math inline">\(O(\left(n+\sum k\right)\log n).\)</span></p>
<h2 id="一些细节">#3.0 一些细节</h2>
<h3 id="如何得到询问区间">#3.1 如何得到询问区间</h3>
<p>因为序列是按 dfn 序排列，所以不难得到这条性质：任意两个子树代表的区间要么为包含关系，要么毫不相关；</p>
<p>于是我们可以对选定点代表的区间按左端点进行排序，如果当前处理到的询问右端点 <span class="math inline">\(r\)</span> 比上一个右端点 <span class="math inline">\(R\)</span> 大，就询问 <span class="math inline">\([R+1,l-1]\)</span> 这个区间，注意要特殊处理 <span class="math inline">\(R+1=l\)</span> 的情况；最后需要判断是否要查询 <span class="math inline">\([R+1,n]\)</span> 这个区间。</p>
<p>直接采用 <code>sort()</code> 不会影响时间复杂度。</p>
<h3 id="关于区间修改">#3.2 关于区间修改</h3>
<p>因为涉及到区间修改，所以会涉及到区间标记，如果这里采用标记下传，下传标记时为保证不对历史版本的节点进行修改，便需要新建节点，空间复杂度大致约为 <span class="math inline">\(O(n\log^2n)\)</span>，而我们只有 <span class="math inline">\(128M\)</span> 空间，无法接受，而区间加法的标记具有可加性，故应当采用标记永久化，这样空间复杂度便为 <span class="math inline">\(O(n\log n).\)</span></p>
<h2 id="code">#4.0 Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x3fffffffffffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> u, v, nxt;&#125; e[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs; ll sum, mn, mx, lz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;sum = mn = mx = (ll)x; lz = ls = rs = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;ls = rs = sum = mn = mx = lz = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;ls = rs = sum = mn = mx = lz = <span class="number">0</span>;&#125;</span><br><span class="line">&#125; p[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BAD_NODES</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> BAD_NODES b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> l &lt; b.l;&#125;</span><br><span class="line">&#125; bp[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span> &#123;</span></span><br><span class="line">    ll sum, mn, mx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Answer</span><span class="params">()</span> </span>&#123;sum = <span class="number">0</span>, mn = INF, mx = -INF;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Answer</span><span class="params">(ll _sum, ll _mn, ll _mx)</span> </span>&#123;</span><br><span class="line">        sum = _sum, mn = _mn, mx = _mx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Answer</span><span class="params">(Node P)</span> </span>&#123;</span><br><span class="line">        sum = P.sum, mn = P.mn, mx = P.mx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Answer b)</span> </span>&#123;</span><br><span class="line">        sum += b.sum, mn = <span class="built_in">Min</span>(mn, b.mn), mx = <span class="built_in">Max</span>(mx, b.mx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Answer <span class="title">addtag</span><span class="params">(ll x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        sum += (r - l + <span class="number">1</span>) * x, mn += x, mx += x;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Answer</span>(sum, mn, mx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, cnt, rt[N], head[N], ecnt = <span class="number">1</span>, f[N];</span><br><span class="line"><span class="keyword">int</span> T, dfn[N], d[N], lx[N], rx[N], id[N]; ll lsta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) p[i].<span class="built_in">del</span>();</span><br><span class="line">    cnt = lsta = T = <span class="number">0</span>; d[<span class="number">0</span>] = <span class="number">-1</span>; ecnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">mset</span>(rt, <span class="number">0</span>); <span class="built_in">mset</span>(head, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;p[++ cnt] = p[k]; <span class="keyword">return</span> cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[ecnt].u = u, e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u], head[u] = ecnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll x)</span> </span>&#123;</span><br><span class="line">    p[k].sum += (r - l + <span class="number">1</span>) * x;</span><br><span class="line">    p[k].mn += x, p[k].mx += x, p[k].lz += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = p[k].ls, rs = p[k].rs;</span><br><span class="line">    p[k].sum = p[ls].sum + p[rs].sum + (r - l + <span class="number">1</span>) * p[k].lz;</span><br><span class="line">    p[k].mn = <span class="built_in">Min</span>(p[ls].mn, p[rs].mn) + p[k].lz;</span><br><span class="line">    p[k].mx = <span class="built_in">Max</span>(p[ls].mx, p[rs].mx) + p[k].lz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="keyword">if</span> (!k) k = ++ cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;p[k] = <span class="built_in">Node</span>(d[id[l]]); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">build</span>(p[k].ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p[k].rs, mid + <span class="number">1</span>, r); <span class="built_in">pushup</span>(k, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, ll c)</span> </span>&#123;</span><br><span class="line">    k = <span class="built_in">clone</span>(k); <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;<span class="built_in">update</span>(k, l, r, c); <span class="keyword">return</span> k;&#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) p[k].ls = <span class="built_in">modify</span>(p[k].ls, l, mid, x, y, c);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) p[k].rs = <span class="built_in">modify</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y, c);</span><br><span class="line">    <span class="built_in">pushup</span>(k, l, r);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Answer <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, ll z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> <span class="built_in">Answer</span>(p[k]).<span class="built_in">addtag</span>(z, l, r);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; Answer res;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) res.<span class="built_in">update</span>(<span class="built_in">query</span>(p[k].ls, l, mid, x, y, z + p[k].lz));</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) res.<span class="built_in">update</span>(<span class="built_in">query</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y, z + p[k].lz));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dfn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++ T, lx[x] = T, id[T] = x;</span><br><span class="line">    d[x] = d[fa] + <span class="number">1</span>, f[x] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> (e[i].v != fa) <span class="built_in">get_dfn</span>(e[i].v, x);</span><br><span class="line">    rx[x] = T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q)) &#123;</span><br><span class="line">        <span class="built_in">clear</span>(); <span class="keyword">int</span> pt = <span class="number">0</span>, k = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">add_edge</span>(u, v); <span class="built_in">add_edge</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">get_dfn</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">build</span>(rt[<span class="number">1</span>], <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            rt[i] = <span class="built_in">modify</span>(rt[dfn[f[id[i]]]], <span class="number">1</span>, n, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">            rt[i] = <span class="built_in">modify</span>(rt[i], <span class="number">1</span>, n, lx[id[i]], rx[id[i]], <span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;pt, &amp;t);</span><br><span class="line">            pt = (pt + lsta) % n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="number">0</span>; Answer res;</span><br><span class="line">            <span class="keyword">if</span> (k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">                    bp[i] = (BAD_NODES)&#123;lx[x], rx[x]&#125;;</span><br><span class="line">                &#125; <span class="built_in">sort</span>(bp + <span class="number">1</span>, bp + k + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (bp[<span class="number">1</span>].l == <span class="number">1</span>) &#123;lsta = <span class="number">0</span>; <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (bp[i].r &lt;= r) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (bp[i].l == r + <span class="number">1</span>) &#123;r = bp[i].r; <span class="keyword">continue</span>;&#125;</span><br><span class="line">                    res.<span class="built_in">update</span>(<span class="built_in">query</span>(rt[dfn[pt]], <span class="number">1</span>, n, r + <span class="number">1</span>, bp[i].l - <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">                    r = bp[i].r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; n) res.<span class="built_in">update</span>(<span class="built_in">query</span>(rt[dfn[pt]], <span class="number">1</span>, n, r + <span class="number">1</span>, n, <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, lsta = res.sum);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, lsta = res.mn);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, lsta = res.mx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-NOIP10连-DAY1 总结</title>
    <url>/2021/08/30/ZROI-21-NOIP-DAY1/</url>
    <content><![CDATA[<blockquote>
<p>被完虐... QwQ</p>
</blockquote>
<h2 id="t1">#T1</h2>
<h3 id="problem">#Problem</h3>
<p>给定 <span class="math inline">\(n,p\)</span>，求：</p>
<p><span class="math display">\[
\sum\limits_{i=1}^n\sum\limits_{j=1}^p\varphi(i^j)\mod 10^9+7.
\]</span></p>
<h3 id="solution">#Solution</h3>
<h4 id="pts">#60pts</h4>
<p>考场上最初以为是莫比乌斯反演的题，先简单推一推：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum\limits_{i=1}^n\sum\limits_{j=1}^p\varphi(i^j)=\sum\limits_{i=1}^n\sum\limits_{j=1}^p\sum\limits_{d|i^j}\mu(d)\dfrac{i^j}{d}\\
=&amp;\sum\limits_{d=1}^n\mu(d)\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum\limits_{j=1}^pi^jd^{j-1}=\sum\limits_{j=1}^p\sum\limits_{d=1}^n\mu(d)d^{j-1}\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}i^j
\end{aligned}
\]</span></p>
<p>推到这里，我已经做不下去了，这样的时空复杂度可以做到 <span class="math inline">\(O(np)\)</span>，可得 <span class="math inline">\(60pts\)</span>，注意到，这里无法继续进行的原因是幂没有合适的处理方法。</p>
<h4 id="pts-1">#100pts</h4>
<p>接着上面的错误思路返回原点，突然想起欧拉函数具有以下性质：</p>
<p><span class="math display">\[
\varphi(i^j)=\varphi(i)\cdot i^{j-1}
\]</span></p>
<p>于是原式化为</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum\limits_{i=1}^n\sum\limits_{j=1}^p\varphi(i^j)=\sum\limits_{i=1}^n\sum\limits_{j=1}^pi^{j-1}\varphi(i)=\sum\limits_{i=1}^n\varphi(i)\sum\limits_{j=1}^pi^{j-1}\\
=&amp;p\cdot\varphi(1)+\sum\limits_{i=2}^n\varphi(i)\dfrac{i^p-1}{i-1}=p\cdot\varphi(1)+\sum\limits_{i=2}^n\dfrac{1}{i-1}\varphi(i)(i^p-1)\\
=&amp;p\cdot\varphi(1)+\sum\limits_{i=2}^n\dfrac{1}{i-1}\left(\varphi(i)\cdot i^p-\varphi(i)\right)
\end{aligned}
\]</span></p>
<p>对于后面的和式，不难发现 <span class="math inline">\(\varphi\)</span> 是<strong>积性函数</strong>，<span class="math inline">\(i^p\)</span> 是<strong>完全积性函数</strong>，于是我们便可以用线性筛筛出这两个函数，其中在 <span class="math inline">\(i\)</span> 为质数时，<span class="math inline">\(i^p\)</span> 需要使用一次快速幂，而小于等于 <span class="math inline">\(n\)</span> 的质数个数 <span class="math inline">\(\pi(n)\)</span> 约为 <span class="math inline">\(\dfrac{n}{\ln n}\)</span>，于是线性筛的整体时间复杂度约为 <span class="math inline">\(O(n\log_np)\)</span>，可以接受。</p>
<p>我们再线性推个逆元，直接求和即得答案。</p>
<h3 id="code">#Code</h3>
<h4 id="pts-2">#60pts</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p, nprm[N], prm[N], pcnt;</span><br><span class="line">ll mi[M][M], mu[N], sum[M][M], ans, sum1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= MOD;</span><br><span class="line">        (a *= a) %= MOD; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nprm[i]) prm[++ pcnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prm[j] * i &gt; x) <span class="keyword">break</span>;</span><br><span class="line">            nprm[prm[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prm[j]) mu[i * prm[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;p); <span class="built_in">euler</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          sum1[i] = (sum1[i - <span class="number">1</span>] + i) % MOD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d) &#123;</span><br><span class="line">            ans += mu[d] * sum1[n / d] % MOD;</span><br><span class="line">            (ans += MOD) %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= p; ++ j) &#123;</span><br><span class="line">            mi[i][j] = <span class="built_in">fpow</span>(i, j) % MOD;</span><br><span class="line">            sum[i][j] = (sum[i - <span class="number">1</span>][j] + mi[i][j]) % MOD;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++ i)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d) &#123;</span><br><span class="line">              ans += mu[d] * mi[d][i - <span class="number">1</span>] % MOD * sum[n / d][i] % MOD;</span><br><span class="line">              (ans += MOD) %= MOD; </span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pts-3">#100pts</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line">ll n, p, mu[N], nprm[N], prm[N], pcnt;</span><br><span class="line">ll ans, phi[N], f[N], mi[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= MOD;</span><br><span class="line">        (a *= a) %= MOD; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>; f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nprm[i]) &#123;</span><br><span class="line">            prm[++ pcnt] = i, mi[i] = <span class="built_in">fpow</span>(i, p);</span><br><span class="line">            phi[i] = i - <span class="number">1</span>, f[i] = phi[i] * mi[i] % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prm[j] * i &gt; x) <span class="keyword">break</span>;</span><br><span class="line">            nprm[prm[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prm[j]) &#123;</span><br><span class="line">                f[i * prm[j]] = f[i] * f[prm[j]] % MOD;</span><br><span class="line">                phi[i * prm[j]] = phi[i] * (prm[j] - <span class="number">1</span>) % MOD;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * prm[j]] = phi[i] * prm[j] % MOD;</span><br><span class="line">                f[i * prm[j]] = f[i] * prm[j] % MOD * mi[prm[j]] % MOD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;p);</span><br><span class="line">    <span class="built_in">euler</span>(n); inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) </span><br><span class="line">      inv[i] = ((MOD - MOD / i) * inv[MOD % i]) % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">      (ans += inv[i - <span class="number">1</span>] * (f[i] - phi[i]) % MOD + MOD) %= MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (ans + p % MOD + MOD) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2">#T2</h2>
<blockquote>
<p>巨大诈骗题，赛时想麻烦了（</p>
</blockquote>
<h3 id="problem-1">#Problem</h3>
<p>一个含有 <span class="math inline">\(n\)</span> 个点的大根堆是一个二叉树，左右儿子有区别，每个节点上有一个 <span class="math inline">\(1\sim n\)</span> 的值，任意两个节点上的值不同，且父亲节点的权值大于子节点的权值。</p>
<p>现在给定一个集合 <span class="math inline">\(S\)</span>，要求 <span class="math inline">\(\forall a\in S\)</span>，值 <span class="math inline">\(a\)</span> 对应的节点是叶结点。求有多少个满足要求的大根堆，答案 <span class="math inline">\(\bmod 10^9+7\)</span>。</p>
<h3 id="solution-1">#Solution</h3>
<p>首先明确概念：<strong>堆不一定是完全二叉树！</strong></p>
<blockquote>
<p>“左偏堆是不是堆？左偏堆是完全二叉树吗？” ——wzy</p>
</blockquote>
<p>因为是一个大根堆，于是插入顺序可以直接确定为由大到小插入，我们设当前可选位置个数为 <span class="math inline">\(s\)</span>，不难发现，对于一个必须为叶子的节点，不论放到哪里，下一个点的可选位置一定减少一，如果不是，那么自己占了一个位置，又提供了两个可选位置，于是下一个点的可选位置一定增加一，将每一步的 <span class="math inline">\(s\)</span> 相乘即得答案。</p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,  p, vis[N];</span><br><span class="line">ll s = <span class="number">1</span>, ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); vis[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">        (ans *= s) %= MOD;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) -- s; <span class="keyword">else</span> ++ s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3">#T3</h2>
<h3 id="problem-2">#Problem</h3>
<p>初始有一张含有 <span class="math inline">\(n\)</span> 个点的有向图，你可以不断向其中加入至多 <span class="math inline">\(n(n−1)\)</span> 条边，不允许加入重边或者自环。</p>
<p>定义一个长度为 <span class="math inline">\(m\)</span> 的序列 <span class="math inline">\(\{ai\}\)</span> 为一个 SCC 序列，当且仅当存在一种加边方案，使得加入 <span class="math inline">\(i\)</span> 条边后图中恰好存在 <span class="math inline">\(a_i\)</span> 个强连通分量（两个点在一个强连通分量中当且仅当他们能够相互到达）。</p>
<p>给定 <span class="math inline">\(n\)</span>，你需要求出当序列长度分别为 <span class="math inline">\(1\cdots n(n−1)\)</span> 时，有多少种 SCC 序列，由于答案可能很大，需要对于一个数字取模。为了防止打表，模数是输入的。</p>
<h3 id="solution-2">#Solution</h3>
<p>用的 zyc 大佬的思路，这里说的详细一点。</p>
<p>我们考虑这个序列字典序最大是多少，假设 <span class="math inline">\(n=4\)</span>，那么这个序列是：</p>
<p><span class="math display">\[
4,4,4,4,4,4,3,2,2,1,1,1
\]</span></p>
<p>记该序列为 <span class="math inline">\(\{mxl_i\}\)</span> 我们考虑这个序列是怎么形成的，一开始有 <span class="math inline">\(n\)</span> 个空点，然后相邻连边，就可以使 scc 个数不变。加的不能加为止，不难发现，每多连一条边，就可以有 <span class="math inline">\(x\)</span> 条边使得 scc 个数为 <span class="math inline">\(n−x\)</span> 不变。这个自己画一下图就能论证。</p>
<p>接下来我们考虑如果已知一个前缀 scc 序列，如何看下一个值最小能填多少？我们不难发现，这个数是 <span class="math inline">\(n−k+1\)</span>，其中 <span class="math inline">\(n\)</span> 是序列长度，<span class="math inline">\(k\)</span> 是序列中不同的数的个数。这个很好论证，用构造的方法就可以证明。</p>
<p>至于上界，这个就是上一位和这一位的 <span class="math inline">\(mxl\)</span> 值做 <span class="math inline">\(\min\)</span> 就可以。</p>
<p>上下界固定后，暴力就好想了，DP 也很自然。</p>
<p>设 <span class="math inline">\(f_{i,j,k}\)</span> 表示序列长度为 <span class="math inline">\(i\)</span>，最后一个数为 <span class="math inline">\(j\)</span>，有 <span class="math inline">\(k\)</span> 个不同的数的方案数。</p>
<p>我们考虑有哪些状态可以转移到 <span class="math inline">\(f_{i,j,k}\)</span>。我们考虑如果这个序列中 <span class="math inline">\(j\)</span> 不止一个，那么就可以从 <span class="math inline">\(f_{i−1,j,k}\)</span> 中转移。</p>
<p>否则，我们枚举第 <span class="math inline">\(i−1\)</span> 个填了什么，然后转移，不难发现这个东西是 <span class="math inline">\(f_{i−1,j&#39;,k−1}\)</span> 其中 <span class="math inline">\(j&#39;&gt;j\)</span>，因为不合法的状态我们已经设置为 <span class="math inline">\(0\)</span>，所以可以放心转移。用前缀和优化，可以做到 O(Tn^4)。</p>
<p>空间简单卡一下可以通过，保险起见，这里采用滚动数组优化。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][N][N], pre[N][N], MOD, mxl[N * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * (n - <span class="number">1</span>) / <span class="number">2</span>; ++ i) mxl[i] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; -- i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = (n - i) * (n - i - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>; j &lt;= (n - i) * (n - i - <span class="number">1</span>) / <span class="number">2</span> + n - i; ++ j)</span><br><span class="line">        mxl[n * (n - <span class="number">1</span>) / <span class="number">2</span> + j] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">red</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &gt;= MOD ? x - MOD : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mset</span>(f, <span class="number">0</span>); f[<span class="number">1</span>][n][<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n * (n - <span class="number">1</span>); ++ i) &#123;</span><br><span class="line">        <span class="built_in">mset</span>(f[i &amp; <span class="number">1</span>], <span class="number">0</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; j &lt;= i; ++ j) &#123;</span><br><span class="line">            pre[<span class="number">1</span>][j] = f[!(i &amp; <span class="number">1</span>)][<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= mxl[i - <span class="number">1</span>]; ++ k)</span><br><span class="line">              pre[k][j] = <span class="built_in">red</span>(pre[k - <span class="number">1</span>][j] + f[!(i &amp; <span class="number">1</span>)][k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mxl[i]; ++ j)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n &amp;&amp; k &lt;= i &amp;&amp; k &lt;= (n - j + <span class="number">1</span>); ++ k) &#123;</span><br><span class="line">              <span class="keyword">int</span> l = <span class="built_in">max</span>(j, n - i + k - <span class="number">1</span>); <span class="keyword">if</span> (l &gt; j) <span class="keyword">continue</span>; </span><br><span class="line">              f[i &amp; <span class="number">1</span>][j][k] = (pre[mxl[i - <span class="number">1</span>]][k - <span class="number">1</span>] - pre[l + (l == j) - <span class="number">1</span>][k - <span class="number">1</span>] + MOD) % MOD;</span><br><span class="line">              <span class="keyword">if</span> (l == j) f[i &amp; <span class="number">1</span>][j][k] = <span class="built_in">red</span>(f[i &amp; <span class="number">1</span>][j][k] + f[!(i &amp; <span class="number">1</span>)][j][k]);</span><br><span class="line">              ans = <span class="built_in">red</span>(ans + f[i &amp; <span class="number">1</span>][j][k]);</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans);</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;MOD);</span><br><span class="line">        <span class="built_in">prework</span>(n); <span class="built_in">solve</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4">#T4</h2>
<h3 id="problem-3">#Problem</h3>
<p>有一个长度为 <span class="math inline">\(n\)</span> 的数列 <span class="math inline">\(a_i\)</span>，Alice 和 Bob 手上分别有一个初始为 <span class="math inline">\(0\)</span> 的数字（分别记为 <span class="math inline">\(A,B\)</span>）。Alice 和 Bob 轮流做如下操作：</p>
<ul>
<li>从序列开头或者结尾取出一个数 <span class="math inline">\(x\)</span>，让自己手上的数字异或上 <span class="math inline">\(x\)</span>，并把 <span class="math inline">\(x\)</span> 从序列中删除。</li>
</ul>
<p>Alice 先手，最后谁手上的数字大谁就胜了。如果 Alice,Bob 均使用最优策略，那么谁能取胜？（或者平局，即两个人手上的数字一样大）</p>
<h3 id="solution-3">#Solution</h3>
<p>首先不难发现，当 <span class="math inline">\(a_i\)</span> 的异或和为 <span class="math inline">\(0\)</span> 时一定为平局，否则 <span class="math inline">\(s\)</span> 在二进制下最高的非零位 <span class="math inline">\(p\)</span> 必然是决胜的关键，于是我们便可以将原本的 <span class="math inline">\(a_i\)</span> 按照第 <span class="math inline">\(p\)</span> 位是否为 <span class="math inline">\(1\)</span> 转变为 01 序列，下面的操作都是在 01 序列上进行的讨论。</p>
<p>分为两种情况：长度为奇数和长度为偶数。</p>
<p>先来看第一种：长度为偶数。我们将 01 序列分为<strong>奇数位</strong>和<strong>偶数位</strong>，此时 a_i 的异或和不为 <span class="math inline">\(0\)</span>，所以必然要么是奇数位上有奇数个 <span class="math inline">\(1\)</span>，要么是偶数位上有奇数个 <span class="math inline">\(1\)</span>，于是先手可以直接控制后手所选的 <span class="math inline">\(1\)</span> 的奇偶性，故在此种情况下先手必胜。</p>
<p>再来看长度为奇数的情况：</p>
<ul>
<li><p>假如两端都是 <span class="math inline">\(0\)</span>，那么无论先手选哪个都会使当前后手变为长度为偶数的先手状态，于是此时先手必败；</p></li>
<li><p>假如一端为 <span class="math inline">\(1\)</span>，那么先手必然要选作为 <span class="math inline">\(1\)</span> 的一端，否则必败，不是最优策略；之后先手需要跟随后手的选择，保证两者的选择完全一致，否则必败我们来简单讨论一下原因：</p>
<ul>
<li>假如在这一步之前，所有的先手的每一步都跟随着后手选，所以此时先后手选的 <span class="math inline">\(1\)</span> 的数量的奇偶性一定不同，在这一步时，后手选了 <span class="math inline">\(1\)</span>，先手选了 <span class="math inline">\(0\)</span>，那么此时先后手选的 <span class="math inline">\(1\)</span> 的数量的奇偶性变为相同，于是一共选了偶数个 <span class="math inline">\(1\)</span>，还剩奇数个 <span class="math inline">\(1\)</span>，此时一共选了奇数个数字，于是还剩偶数个数字，此时后手作为当前局面的先手进入必胜状态；于是这样选先手必败。</li>
<li>在这一步时，后手选了 <span class="math inline">\(0\)</span>，先手选了 <span class="math inline">\(1\)</span>，与上面的证明同理，可得这样先手必败。</li>
</ul>
<p>由于先手取走了一个 <span class="math inline">\(1\)</span>，那么此时 <span class="math inline">\(1\)</span> 的个数为偶数，由于每一步先手都跟着后手选，所以先后手必然平分偶数个 <span class="math inline">\(1\)</span>，如果这个个数不能被 <span class="math inline">\(4\)</span> 整除，也就意味着先手被分到了奇数个 <span class="math inline">\(1\)</span>，加上了最初的那个 <span class="math inline">\(1\)</span>，必败。</p></li>
</ul>
<p>那么，怎样的序列才能满足先手能跟着后周的每一步选呢？删除掉左右两边相同的数后，剩下的应当满足相邻奇偶位（如 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(2\)</span> 是，但 <span class="math inline">\(2\)</span> 和 <span class="math inline">\(3\)</span> 不是）上的数字相同，这里不证正确性，证法与上面相似。</p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], s, n, T, l, r, p, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; a[l] == a[r]) ++ l, -- r;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; a[l] == a[l + <span class="number">1</span>]) l += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); l = <span class="number">1</span>, r = n;</span><br><span class="line">        p = <span class="number">30</span>, tot = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), s ^= a[i];</span><br><span class="line">        <span class="keyword">if</span> (!s) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Draw\n&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>)) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Alice\n&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !((s &gt;&gt; p) &amp; <span class="number">1</span>)) -- p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          a[i] = (a[i] &gt;&gt; p) &amp; <span class="number">1</span>, tot += a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; a[n] == <span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Bob\n&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        -- tot; <span class="keyword">if</span> (tot % <span class="number">4</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Bob\n&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> ((a[<span class="number">1</span>] &amp;&amp; <span class="built_in">check</span>(<span class="number">2</span>, n, tot)) || (a[n] &amp;&amp; <span class="built_in">check</span>(<span class="number">1</span>, n - <span class="number">1</span>, tot)))</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Alice\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Bob\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<blockquote>
<p>期望得分：<span class="math inline">\(100+20+0+0=120\)</span> 实际得分：<span class="math inline">\(100+30+0+0=130\)</span> 没想到还骗过了一个点（</p>
</blockquote>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「考试总结」ZROI-21-CSP7连-DAY1 总结</title>
    <url>/2021/08/30/ZROI-21-CSP-DAY1/</url>
    <content><![CDATA[<blockquote>
<p>估计是温水煮青蛙，本场比赛比较水。</p>
</blockquote>
<h2 id="t1">#T1</h2>
<h3 id="problem">#Problem</h3>
<p>一种递归定义的数列（字符串列？）：第一项为 <code>1</code>，后面的每一项形式为上一项自左往右 <code>相邻的相同数字个数+该数字</code>，比如第二项为 <code>11</code>，表示 <code>1</code> 个 <code>1</code>，问第 <span class="math inline">\(n(n\leq 25)\)</span> 项。</p>
<h3 id="solution">#Solution</h3>
<p>就是简单模拟，没有难度。</p>
<h3 id="code">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, t[N][<span class="number">2</span>], cnt, len, tlen, lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    t[len = <span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        tlen = <span class="number">0</span>, lst = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">1</span> &amp;&amp; t[j][(i - <span class="number">1</span>) % <span class="number">2</span>] != lst) &#123;</span><br><span class="line">                t[++ tlen][i % <span class="number">2</span>] = cnt;</span><br><span class="line">                t[++ tlen][i % <span class="number">2</span>] = lst; cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lst = t[j][(i - <span class="number">1</span>) % <span class="number">2</span>]; ++ cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        t[++ tlen][i % <span class="number">2</span>] = cnt;</span><br><span class="line">        t[++ tlen][i % <span class="number">2</span>] = lst;</span><br><span class="line">        len = tlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++ i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t[i][n % <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2">#T2</h2>
<h3 id="problem-1">#Problem</h3>
<p>一个严格递增的序列 <span class="math inline">\(a_i\)</span>，支持两种操作：</p>
<ul>
<li>区间修改</li>
<li>查询是否有位置满足 <span class="math inline">\(a_i=i\)</span></li>
</ul>
<h3 id="solution-1">#Solution</h3>
<p>我们来考虑所有满足 <span class="math inline">\(a_i=i\)</span> 的位置中 <span class="math inline">\(i\)</span> 最大的，不难发现如果存在这样的位置，那么其一定具有二分性，即设该位置为 <span class="math inline">\(i\)</span>，那么对于所有的 <span class="math inline">\(j&lt;i\)</span>，有 <span class="math inline">\(a_j\leq j\)</span>，对于 <span class="math inline">\(j&gt;i\)</span>，则有 <span class="math inline">\(a_j &gt; i\)</span>，于是我们可以依靠此性质进行二分，注意我们需要判断二分结束后的位置是否满足条件（赛时脑抽忘判了 <span class="math inline">\(100pts\to 10pts\)</span> QwQ），如果不满足，那么意味着不存在这样的位置，同时需要注意边界。</p>
<p>关于区间修改，我们可以直接采用线段树维护，由于线段树本身便是天然的二分结构，所以二分的过程可以直接在线段树上进行。总体时间复杂度为 <span class="math inline">\(O(k\log n).\)</span></p>
<h3 id="code-1">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> ls, rs, mx, tag;&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, n, m, a[N], rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    p[k].tag += x; p[k].mx += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = p[k].ls, rs = p[k].rs;</span><br><span class="line">    <span class="keyword">if</span> (ls) <span class="built_in">add</span>(ls, p[k].tag);</span><br><span class="line">    <span class="keyword">if</span> (rs) <span class="built_in">add</span>(rs, p[k].tag);</span><br><span class="line">    p[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    p[k].mx = p[p[k].rs].mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) k = ++ cnt;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;p[k].mx = a[l]; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">build</span>(p[k].ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p[k].rs, mid + <span class="number">1</span>, r); <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;<span class="built_in">add</span>(k, c); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(p[k].ls, l, mid, x, y, c);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) <span class="built_in">modify</span>(p[k].rs, mid + <span class="number">1</span>, r, x, y, c);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pos</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;<span class="keyword">return</span> p[k].mx == l ? l : <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k); <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lval = p[p[k].ls].mx;</span><br><span class="line">    <span class="keyword">if</span> (lval &gt; mid) <span class="keyword">return</span> <span class="built_in">get_pos</span>(p[k].ls, l, mid);</span><br><span class="line">    <span class="keyword">if</span> (lval &lt; mid) <span class="keyword">return</span> <span class="built_in">get_pos</span>(p[k].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(m); <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    a[n + <span class="number">1</span>] = n + <span class="number">1</span>; <span class="built_in">build</span>(rt, <span class="number">0</span>, n + <span class="number">1</span>); -- m;</span><br><span class="line">    <span class="keyword">int</span> pos1 = <span class="built_in">get_pos</span>(rt, <span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos1 &lt; <span class="number">1</span> || pos1 &gt; n) <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c; <span class="built_in">read</span>(l); <span class="built_in">read</span>(r); <span class="built_in">read</span>(c);</span><br><span class="line">        <span class="built_in">modify</span>(rt, <span class="number">0</span>, n + <span class="number">1</span>, l, r, c);</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="built_in">get_pos</span>(rt, <span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">1</span> || pos &gt; n) <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t3">#T3</h2>
<h3 id="problem-2">#Problem</h3>
<p>给定序列 <span class="math inline">\(a_i\)</span>，<span class="math inline">\(q\)</span> 个询问，每次询问位于 <span class="math inline">\(a_l\)</span> 到 <span class="math inline">\(a_r\)</span> 这个子序列中出现次数为奇数的数的个数。</p>
<h3 id="solution-2">#Solution</h3>
<p>莫队的板子题，不多讲。</p>
<h3 id="code-2">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], t[N], cnt[N];</span><br><span class="line"><span class="keyword">int</span> len, res, ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l / len != b.l / len) <span class="keyword">return</span> l &lt; b.l;</span><br><span class="line">        <span class="keyword">if</span> ((l / len) &amp; <span class="number">1</span>) <span class="keyword">return</span> r &lt; b.r;</span><br><span class="line">        <span class="keyword">return</span> r &gt; b.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Query q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++ cnt[x]; <span class="keyword">if</span> (cnt[x] &amp; <span class="number">1</span>) ++ res; <span class="keyword">else</span> -- res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    -- cnt[x]; <span class="keyword">if</span> (cnt[x] &amp; <span class="number">1</span>) ++ res; <span class="keyword">else</span> -- res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[i]), a[i] = t[i];</span><br><span class="line">    <span class="built_in">sort</span>(t + <span class="number">1</span>, t + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> _n = <span class="built_in">unique</span>(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      a[i] = <span class="built_in">lower_bound</span>(t + <span class="number">1</span>, t + _n + <span class="number">1</span>, a[i]) - t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i;</span><br><span class="line">    len = <span class="built_in">sqrt</span>(n); <span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">1</span>, r = <span class="number">0</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(a[-- l]);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(a[++ r]);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">del</span>(a[l ++]);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">del</span>(a[r --]);</span><br><span class="line">        ans[q[i].id] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4">#T4</h2>
<blockquote>
<p>本题是 TJOI 的一道原题 <a href="https://www.luogu.com.cn/problem/P3978">[题目链接]</a></p>
</blockquote>
<h3 id="problem-3">#Problem</h3>
<p>求 <span class="math inline">\(n\)</span> 个点的二叉树的叶结点期望个数，对 <span class="math inline">\(2148473647\)</span> 取模。</p>
<blockquote>
<p>用 <span class="math inline">\(2148473647\)</span> 做模数就恶心人，最开始以为是 <span class="math inline">\(2147483647(2^{31}-1)\)</span>，发现这样没有逆元...</p>
</blockquote>
<h3 id="solution-3">#Solution</h3>
<p>设 <span class="math inline">\(f_n\)</span> 表示 <span class="math inline">\(n\)</span> 个节点的不同二叉树的个数，<span class="math inline">\(g_n\)</span> 表示 <span class="math inline">\(n\)</span> 个节点的 <span class="math inline">\(f_n\)</span> 个二叉树的叶结点总数。答案显然应当是</p>
<p><span class="math display">\[
\dfrac{g_n}{f_n}
\]</span></p>
<p><span class="math inline">\(f_n\)</span> 显而易见是 Catalan 数，那么来考虑 <span class="math inline">\(g_n\)</span> 怎么求，通过打表可以得到如下性质</p>
<p><span class="math display">\[
g_n=nf_{n-1}
\]</span></p>
<p>我们这样考虑证明：</p>
<ul>
<li>对于每棵 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(k\)</span> 个叶结点的二叉树，如果我们把这 <span class="math inline">\(k\)</span> 个叶结点分别去掉，可以得到 <span class="math inline">\(k\)</span> 棵不同的 <span class="math inline">\(n-1\)</span> 个节点的二叉树；</li>
<li>对于每棵 <span class="math inline">\(n-1\)</span> 个点的二叉树，我们知道有 <span class="math inline">\(n\)</span> 个位置可以挂上一个叶结点，所以通过上面的变换，每一棵 <span class="math inline">\(n-1\)</span> 个点的二叉树可以被得到 <span class="math inline">\(n\)</span> 次；</li>
</ul>
<p>于是综合上面两点不难得到 <span class="math inline">\(g_n=nf_{n-1}\)</span> 的结论，于是有</p>
<p><span class="math display">\[
\dfrac{g_n}{f_n}=\dfrac{nf_{n-1}}{f_n}
\]</span></p>
<p>其中有 <span class="math inline">\(f_n=\dfrac{\binom{2n}{n}}{n+1}\)</span>，带入化简后可以得到</p>
<p><span class="math display">\[
\dfrac{g_n}{f_n}=\dfrac{nf_{n-1}}{f_n}=\dfrac{n(n+1)}{2(2n-1)}.
\]</span></p>
<h3 id="code-3">#Code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">2148473647</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= MOD;</span><br><span class="line">        (a *= a) %= MOD; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>, &amp;n);</span><br><span class="line">    ll res1 = n * (n + <span class="number">1</span>) % MOD;</span><br><span class="line">    ll res2 = <span class="built_in">fpow</span>(<span class="number">2</span> * (<span class="number">2</span> * n - <span class="number">1</span>) % MOD, MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, (res1 * res2 % MOD + MOD) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<blockquote>
<p>期望得分：<span class="math inline">\(100+100+100+100=400\)</span> 实际得分：<span class="math inline">\(100+10+100+100=310\)</span> 血亏QwQ</p>
</blockquote>
]]></content>
      <categories>
        <category>考试总结</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」UVA1519 Dictionary Size</title>
    <url>/2021/08/22/UVA1519/</url>
    <content><![CDATA[<h2 id="大致题意">#0.0 大致题意</h2>
<p>给定 <span class="math inline">\(n(n\le 10^4)\)</span> 个字符串，定义任意一个字符串 <span class="math inline">\(s\)</span> 为“好的”，当且仅当满足下列任意一个条件：</p>
<ol type="1">
<li><span class="math inline">\(s\)</span> 为这 <span class="math inline">\(n\)</span> 个字符串其中一个。</li>
<li><span class="math inline">\(s\)</span> 可以被划分为一个前缀和一个后缀，其中前缀为给定 <span class="math inline">\(n\)</span> 个字符串中的一个字符串的前缀，后缀为给定 <span class="math inline">\(n\)</span> 个字符串中的一个字符串的后缀。</li>
</ol>
<p>给定 <span class="math inline">\(n\)</span> 个串，求一共有多少个好的字符串 <span class="math inline">\(s\)</span> 。数据保证每个字符串长度 <span class="math inline">\(len\)</span> 有 <span class="math inline">\(1\le len \le 40\)</span>。</p>
<p>注意有多组数据。</p>
<h2 id="简单思路">#1.0 简单思路</h2>
<p>直接计算无重复的字符串有多少个是不好做的，我们来考虑进行容斥，先得到具有重复的字符串数量，再减去重复的贡献。</p>
<p>首先将所有字符串正向插入第一棵 trie 中，那么此时这棵 trie 中的节点数量（不包含根节点）便是所有非空前缀的数量，非空后缀的数量大同小异，不过注意需要将字符串反转，这样从根节点向下到达任意一个节点所经过的路径才能组成一个原串中的后缀。</p>
<p>前后缀数量相乘得到了我们的第一部分答案，但这个答案代表的可重集中是否包含了所有的“好的”字符串呢？并不是，注意到我们拼出来的串的长度 <span class="math inline">\(\geq2\)</span>，如果输入的字典中存在长度为 <span class="math inline">\(1\)</span> 的字符串，那么他显然是不被包含在其中的，所以我们需要特别记录，但是这样的字符串可以直接去重（每个字符最多单个出现 <span class="math inline">\(1\)</span> 次）。</p>
<p>最后再来考虑如何去掉重复的贡献。考虑一个前缀为 <span class="math inline">\(Ax\)</span>，一个后缀为 <span class="math inline">\(xB\)</span>（<span class="math inline">\(x\)</span> 为任意单个字符，<span class="math inline">\(A,B\)</span> 为两个<strong>非空</strong>字符串），那么有这样一个结合为 <span class="math inline">\(AxB\)</span>，会以下面两种方式计入当前答案：<span class="math inline">\(Ax+B\)</span> 和 <span class="math inline">\(A+xB\)</span>，所以说一个形如 <span class="math inline">\(AxB\)</span> 的字符串便被计算了两遍。</p>
<p>所以对于任何一个以 <span class="math inline">\(x\)</span> 为结尾的前缀 <span class="math inline">\(Ax\)</span> 和任何一个以 <span class="math inline">\(x\)</span> 为开头的后缀 <span class="math inline">\(xB\)</span>，都会有这样的重复计算，所以我们可以统计以 <span class="math inline">\(x\)</span> 为结尾的长度大于 <span class="math inline">\(1\)</span> 的前缀数量，和以 <span class="math inline">\(x\)</span> 为开头的长度大于 <span class="math inline">\(1\)</span> 的后缀数量，两者相乘便是这个字符做出的重复贡献，应当被减去。</p>
<p>这样的时间复杂度为 <span class="math inline">\(O(|S|)\)</span>，瓶颈在于建立 trie.</p>
<p>更多的细节请见下方代码。</p>
<h2 id="代码">#2.0 代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mset(l, x) memset(l, x, sizeof(l))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">30</span>], rt; ll cnt, res[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = rt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">mset</span>(ch, <span class="number">0</span>); <span class="built_in">mset</span>(res, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = rt, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ch[p][k]) &#123;</span><br><span class="line">                ch[p][k] = ++ cnt;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) ++ res[k];</span><br><span class="line">                <span class="comment">/*注意统计的前、后缀长度要大于 1*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = ch[p][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, al[<span class="number">30</span>]; ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123; <span class="comment">//多组数据，需要清空</span></span><br><span class="line">    ans = <span class="number">0</span>; <span class="built_in">mset</span>(al, <span class="number">0</span>);</span><br><span class="line">    t[<span class="number">0</span>].<span class="built_in">clear</span>(); t[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">reset</span>(); <span class="keyword">char</span> s[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            <span class="comment">/*分别将正反向加入两棵 trie*/</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s); t[<span class="number">0</span>].<span class="built_in">insert</span>(s);</span><br><span class="line">            <span class="built_in">reverse</span>(s, s + len); t[<span class="number">1</span>].<span class="built_in">insert</span>(s);</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) al[s[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/*对于单个字符的记录与去重*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = t[<span class="number">0</span>].cnt * t[<span class="number">1</span>].cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (al[i]) ++ ans;</span><br><span class="line">            ans -= t[<span class="number">0</span>].res[i] * t[<span class="number">1</span>].res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>「字符串相关」后缀数组 - 倍增算法</title>
    <url>/2021/07/06/suffix-array/</url>
    <content><![CDATA[<blockquote>
<p>我们约定，下文所提到的字符串下标都从 <span class="math inline">\(0\)</span> 开始。下文中的“第 <span class="math inline">\(x\)</span> 后缀”指的是从下标 <span class="math inline">\(x\)</span> 开始的后缀。</p>
<p>对于后缀数组的学习，本人建议可以自己随便写一个字符串，然后按照相应的过程进行模拟，会很方便的理解每一步的作用以及原理。</p>
</blockquote>
<h1 id="何为后缀数组">#1.0 何为后缀数组</h1>
<h2 id="后缀树">#1.1 后缀树</h2>
<p>我们知道，像 <a href="https://www.cnblogs.com/Dfkuaid-210/p/ac_auto.html"><span class="math inline">\(\texttt{AC}\)</span> 自动机</a> 这样的多模式串匹配需要预处理的是模式串，但是在很多时候，我们会先知道文本串，而非模式串，对于每个模式串的询问要求在线回答，那怎么办？我们引入<strong>后缀树</strong>这个概念。</p>
<p>所谓后缀树，就是将一个字符串的所有后缀建成一棵树，设 <span class="math inline">\(S=&#39;abaca&#39;\)</span>，<span class="math inline">\(S\)</span> 的后缀树为：</p>
<p><img src="https://pic.imgdb.cn/item/60e442f95132923bf8eb1e93.png" /></p>
<p><code>$</code> 符号是为了标记每一个后缀的结束位置，每个叶节点下面的数字表示该后缀从原字符串的第几位开始，我们已经把所有后缀按字典序从左向右摆放（默认 <code>$</code> 符号的字典序最小），显然从上面寻找模式串是非常方便的，但我们发现整个后缀树的结构非常庞大，有没有合适的替代品呢？</p>
<h2 id="后缀数组">#1.2 后缀数组</h2>
<p>将上面的叶结点下的数字从左往右取出放在数组中，便得到了<strong>后缀数组</strong>（<span class="math inline">\(\texttt{Suffix Array}\)</span>），</p>
<p>由此便不难得到后缀数组的定义：所有的后缀按字典序排序后的编号数组。</p>
<h1 id="后缀数组的构建">#2.0 后缀数组的构建</h1>
<h2 id="朴素算法">#2.1 朴素算法</h2>
<p>一个很简单的算法便是直接采用快排 <code>sort()</code>，快排的时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>，但由于字符串比较需要按位比较，所以实际时间复杂度为 <span class="math inline">\(O(n^2\log n)\)</span>，显然不能接受。</p>
<h2 id="倍增算法">#2.2 倍增算法</h2>
<p>这里采用倍增的双关键字排序。大致流程如下：</p>
<ol type="1">
<li>给所有后缀的第一个字符排序；</li>
<li>给所有后缀的前两个字符排序，实际是双关键字排序；</li>
<li>枚举长度 <span class="math inline">\(l=2^k\)</span>，给所有后缀的前 <span class="math inline">\(l\)</span> 个字符排序，实际依旧是双关键字排序，因为可以借助上一次排序的结果（<span class="math inline">\(l=2^k=2^{k-1}+2^{k-1}\)</span>），即错开 <span class="math inline">\(l-1\)</span> 位进行双关键字排序；重复这一步直到所有后缀的排名不同。</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/60e446c25132923bf8fc2d8c.png" /></p>
<p>显然，上面的过程最多只需要 <span class="math inline">\(\log n\)</span> 次，如果这里的双关键字排序采用快排的话，时间复杂度为 <span class="math inline">\(O(n\log^2 n)\)</span></p>
<h2 id="基数排序优化">#2.3 基数排序优化</h2>
<p>我们注意到最多只有 <span class="math inline">\(n\)</span> 个后缀，所以可以采用<a href="https://oi-wiki.org/basic/radix-sort/">基数排序</a>（我们常用的桶排序便是单关键字的基数排序），这里需要采用双关键字的基数排序。</p>
<p>直接讲解并没有非常好讲，所以这里先贴出代码，我们来一行一行的分析。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> sa[N], t[N], t2[N], c[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_sa</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//m 是编号的最大值</span></span><br><span class="line">    <span class="keyword">int</span> i, *x = t, *y = t2;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++ i) c[x[i] = s[i]] ++;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; ++ i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) sa[-- c[x[i]]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = n - k; i &lt; n; i ++) y[p ++] = i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span> (sa[i] &gt;= k)</span><br><span class="line">          y[p ++] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++ i) c[x[y[i]]] ++;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; ++ i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">          sa[-- c[x[y[i]]]] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y); p = <span class="number">1</span>; x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">          x[sa[i]] = y[sa[i<span class="number">-1</span>]] == y[sa[i]] &amp;&amp; y[sa[i - <span class="number">1</span>] + k] == y[sa[i] + k] ? p - <span class="number">1</span> : p ++;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">        m = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>UPD on 10.30.21: 上述代码<strong>可能</strong>存在问题，建议使用下述代码（思路一致）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> sa[N], rk[N], oldrk[N], px[N], id[N], cnt[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_sa</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, p, w;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ++ cnt[rk[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i) sa[cnt[rk[i]] --] = i;</span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">1</span>;; w &lt;&lt;= <span class="number">1</span>, m = p) &#123;</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>, i = n; i &gt; n - w; --i) id[++ p] = i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (sa[i] &gt; w) id[++ p] = sa[i] - w;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ++ cnt[px[i] = rk[id[i]]];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i) sa[cnt[px[i]] --] = id[i];</span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk, rk, <span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">          rk[sa[i]] = <span class="built_in">comp</span>(sa[i], sa[i - <span class="number">1</span>], w) ? p : ++ p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sa[rk[i]] = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>首先是第一部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++ i) c[x[i] = s[i]] ++;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; ++ i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) sa[-- c[x[i]]] = i;</span><br></pre></td></tr></table></figure>
<p>这里是先对每个后缀的首字母进行排序，<code>x[i]</code> 在这里表示的是第 <code>i</code> 个字符的编号（此时的第一关键字），<code>sa[i]</code> 表示的是按第一关键字排序后的第 <code>i</code> 个后缀在原字符串的起始位置。</p>
<hr />
<p>然后是循环中的这一部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = n - k; i &lt; n; i ++) y[p ++] = i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span> (sa[i] &gt;= k)</span><br><span class="line">  y[p ++] = sa[i] - k;</span><br></pre></td></tr></table></figure>
<p>这一部分是按第二关键字排序，<code>y[i]</code> 储存的是按第二关键字排序后第 <code>i</code> 个后缀在原字符串上的开始位置。</p>
<p>其中第一个 <code>for</code> 是将没有第二关键字的后缀的第二关键字设置为无限小，所以要放在 <code>y[]</code> 数组的最前面。</p>
<p>考虑第二个 <code>for</code> 为什么可以直接借助 <code>sa[]</code> 数组进行赋值，我们知道，<code>sa[i]</code> 表示的是在长度为 <span class="math inline">\(\frac k 2\)</span> 时，按当时的双关键字排序后的第 <code>i</code> 个后缀在原字符串的起始下标，这时对应的也就是在此时长度为 <span class="math inline">\(k\)</span> 的情况下按第一关键字排序后的第 <code>i</code> 个后缀在原字符串的起始下标。</p>
<p>而 <code>sa[i] - k</code> 就相当于按第一关键字排序后的第 <code>i</code> 个后缀在原字符串的下标的第前 <code>k</code> 个位置，那么如果将 <code>sa[i]</code> 看作第二关键字，那么 <code>sa[i] - k</code> 便是所对应的第一关键字在原字符串中的下标位置，那么数组 <code>y[]</code> 中的数恰好便是按第二关键字排序后的第 <code>i</code> 个后缀在原字符串的起始下标。</p>
<hr />
<p>循环中的第二大部分<del>梦幻四重循环</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++ i) c[x[y[i]]] ++;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; ++ i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) sa[-- c[x[y[i]]]] = y[i];</span><br></pre></td></tr></table></figure>
<p>这里 <code>x[i]</code> 表示的是第 <span class="math inline">\(i\)</span> 后缀在按第一关键字排序后对应的 <code>sa[]</code> 数组上的排名（注意这样的排名的大小只是相对性的，可能并不连续）。</p>
<blockquote>
<p>在整个算法的大部分时间里，<code>x[]</code> 都是从后缀映射到排名，<code>sa[]</code> 则是从排名映射到后缀。</p>
</blockquote>
<p>不难发现这里和第一部分几乎一模一样。这里是结合两个关键字的分别排序，构建出当前的双关键字排序后的结果，也是下一次长度为 <span class="math inline">\(2k\)</span> 时按第一关键字排序后的结果。</p>
<p>原因不难想到：<code>y[]</code> 本身具有顺序性，即第二关键字小的在前面，而本身这个排序则是将第一关键字小的排在前面，而不改变第一关键字相同的数之间的相对位置，综合起来，得到的答案便是按双关键字排序后的结果。</p>
<hr />
<p>这是循环中的最后一部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(x, y); p = <span class="number">1</span>; x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">  x[sa[i]] = y[sa[i<span class="number">-1</span>]] == y[sa[i]] &amp;&amp; y[sa[i - <span class="number">1</span>] + k] == y[sa[i] + k] ? p - <span class="number">1</span> : p ++;</span><br><span class="line"><span class="keyword">if</span> (p &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">m = p;</span><br></pre></td></tr></table></figure>
<p>注意在开始前我们先交换了指针 <code>x</code> 和指针 <code>y</code> 所指向的地址，所以此时 <code>x[i]</code> 指的是按第二关键字排序后的第 <code>i</code> 个后缀在原字符串的起始下标，这个数据对于我们来说已经没有用处了；<code>y[i]</code> 表示的是第 <span class="math inline">\(i\)</span> 后缀在按第一关键字排序后对应的 <code>sa[]</code> 数组上的排名（注意这样的排名的大小只是相对性的，可能并不连续）。</p>
<p>这里是统计按现在的结果，还会有多少个不同的排名，如果排名数达到了后缀的总数，那么就没有必要继续进行下去了，如果不够，那么同时为各个不同的后缀重新编号（记录按双关键字排序后对应的 <code>sa[]</code> 数组上的排名），这样编号最大为 <span class="math inline">\(p-1\)</span>。</p>
<p>中间的三目运算符写成 <code>if</code> 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (y[sa[i<span class="number">-1</span>]] == y[sa[i]] &amp;&amp; y[sa[i - <span class="number">1</span>] + k] == y[sa[i] + k])</span><br><span class="line">  x[sa[i]] = p - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> x[sa[i]] = p ++;</span><br></pre></td></tr></table></figure>
<p>这里判等的条件分别是按长度为 <span class="math inline">\(2k\)</span> 时的第一关键字相等（<code>y[sa[i-1]] == y[sa[i]]</code>）和第二关键字相等（<code>y[sa[i - 1] + k] == y[sa[i] + k]</code>），至于为什么 <code>sa[]</code> 的下标是连续的：两个双关键字都相等，而 <code>sa[i]</code> 中是当前双关键字排序后时排名为 <span class="math inline">\(i\)</span> 的后缀的起始位置，双关键字排序的要求便是先满足第一关键字从小到大，再满足第二关键字从小到大，所以如果两个都相等，那么在 <code>sa[]</code> 中的排名必然是相邻的。</p>
<blockquote>
<p>笔者中午在宿舍里思考这里时脑子抽了，是这样断的句：<code>(((x[sa[i]] = y[sa[i-1]]) == y[sa[i]]) &amp;&amp; (y[sa[i - 1] + k)] == y[sa[i] + k]) ? p - 1/*错误地以为是 p --*/ : p ++</code>，当时愣是搞不明白为啥这样做是对的，吹起床哨了才发现我™又断错句了. QnQ</p>
</blockquote>
<hr />
<p>整体来说比较复杂，一遍不懂就需要多啃几遍。</p>
<h1 id="后缀数组的应用">#3.0 后缀数组的应用</h1>
<h2 id="在线模式串匹配">#3.1 在线模式串匹配</h2>
<p>采用二分查找的方式，在文本串中寻找是否存在一个位置开始的后缀的前缀是模式串。</p>
<p>我们可以二分所属的后缀的排名，并与模式串比较大小，如果小了就让排名增大，反之亦然。</p>
<p>设模式串长度为 <span class="math inline">\(m\)</span>，文本串长度为 <span class="math inline">\(n\)</span>，那么单次询问时间复杂度为 <span class="math inline">\(O(m\log n).\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp_suffix</span><span class="params">(<span class="keyword">char</span>* pattern, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(pattern, s + sa[p], m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* P)</span> </span>&#123;</span><br><span class="line">    m = <span class="built_in">strlen</span>(P);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp_suffix</span>(P, <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp_suffix</span>(P, n - <span class="number">1</span>) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= l) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r + l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">cmp_suffix</span>(P, mid);</span><br><span class="line">        <span class="keyword">if</span> (!res) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<p>[1] 刘汝佳, 陈锋. 算法竞赛入门经典：训练指南. 北京: 清华大学出版社, 2012.</p>
<p>[2] <a href="https://www.cnblogs.com/TianMeng-hyl/p/14695293.html">后缀数组——倍增算法 - hyl天梦</a></p>
<p>[3] <a href="https://oi-wiki.org/string/sa/">后缀数组简介 - OI Wiki</a></p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>字符串</tag>
        <tag>基数排序</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
</search>
