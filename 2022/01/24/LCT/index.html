<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat.png">
  <link rel="mask-icon" href="/images/cat.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"dfkuaid.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="LCT 的简单讲解">
<meta property="og:type" content="article">
<meta property="og:title" content="「数据结构」Link-Cut Tree(LCT)">
<meta property="og:url" content="https://dfkuaid.github.io/2022/01/24/LCT/index.html">
<meta property="og:site_name" content="Dfkuaid の 小窝">
<meta property="og:description" content="LCT 的简单讲解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/X5EHxDOaGeopNb6.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/26/nGgDc96EoreVauZ.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/M8gUIJrvZhHBNGe.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/afvt8rOdYsPhibB.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/gPSO2nG3BaZEeh1.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/8sNGA5vWd2Ztg6b.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/QYBopbuUPdlsRqr.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/fdapNCiV7smOKqA.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/hMCzkTKXu1wIr5c.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/kKVIeyCHovint9s.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/s5NdrMOvtX4yzCh.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/Y16e4ulNWGkpnHV.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/27/rsHXCdt3h8eTkNj.png">
<meta property="article:published_time" content="2022-01-23T23:51:06.000Z">
<meta property="article:modified_time" content="2022-02-23T09:42:00.231Z">
<meta property="article:author" content="Dfkuaid">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="Splay">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/01/26/X5EHxDOaGeopNb6.png">


<link rel="canonical" href="https://dfkuaid.github.io/2022/01/24/LCT/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dfkuaid.github.io/2022/01/24/LCT/","path":"2022/01/24/LCT/","title":"「数据结构」Link-Cut Tree(LCT)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>「数据结构」Link-Cut Tree(LCT) | Dfkuaid の 小窝</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Dfkuaid の 小窝</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">暖呼呼~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">39</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">57</span></a></li>
        <li class="menu-item menu-item-friends"><a href="/friends/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li>
        <li class="menu-item menu-item-goals"><a href="/goals/" rel="section"><i class="fa fa-calendar fa-fw"></i>目标</a></li>
        <li class="menu-item menu-item-tricks"><a href="/tricks/" rel="section"><i class="fa fa-lightbulb fa-fw"></i>技巧</a></li>
        <li class="menu-item menu-item-diary"><a href="/diary/" rel="section"><i class="fa fa-book fa-fw"></i>朝话昔事</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">#1.0 简述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%A0%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text">#1.1 动态树问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%93%BE%E5%89%96%E5%88%86"><span class="nav-number">1.2.</span> <span class="nav-text">#1.2 实链剖分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E6%A0%91"><span class="nav-number">1.3.</span> <span class="nav-text">#1.3 辅助树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">#2.0 主要函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">一些变量及其含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.</span> <span class="nav-text">一些基础操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rotate-%E4%B8%8E-splay"><span class="nav-number">2.3.</span> <span class="nav-text">rotate() 与 splay()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#access"><span class="nav-number">2.4.</span> <span class="nav-text">Access()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make_root-%E4%B8%8E-find_root"><span class="nav-number">2.5.</span> <span class="nav-text">make_root() 与 find_root()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linkcutsplit"><span class="nav-number">2.6.</span> <span class="nav-text">link()、cut()、split()!</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">#3.0 例题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#luogu3690-%E6%A8%A1%E6%9D%BF%E5%8A%A8%E6%80%81%E6%A0%91link-cut-tree"><span class="nav-number">3.1.</span> <span class="nav-text">#3.1 Luogu3690 【模板】动态树（Link Cut Tree）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hnoi2010%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A"><span class="nav-number">3.2.</span> <span class="nav-text">#3.2 「HNOI2010」弹飞绵羊</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">#4.0 时间复杂度分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">5.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dfkuaid"
      src="/images/head.jpeg">
  <p class="site-author-name" itemprop="name">Dfkuaid</p>
  <div class="site-description" itemprop="description">每个人的心里都有一团火，路过的人只看到烟。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dfkuaid" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dfkuaid" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kuaid_yd@protonmail.com" title="E-Mail → mailto:kuaid_yd@protonmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dfkuaid.github.io/2022/01/24/LCT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpeg">
      <meta itemprop="name" content="Dfkuaid">
      <meta itemprop="description" content="每个人的心里都有一团火，路过的人只看到烟。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dfkuaid の 小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「数据结构」Link-Cut Tree(LCT)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-24 07:51:06" itemprop="dateCreated datePublished" datetime="2022-01-24T07:51:06+08:00">2022-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-23 17:42:00" itemprop="dateModified" datetime="2022-02-23T17:42:00+08:00">2022-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">LCT 的简单讲解</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="简述">#1.0 简述</h2>
<h3 id="动态树问题">#1.1 动态树问题</h3>
<p>维护一个森林，支持删除某条边，加入某条边，并保证加边、删边之后仍然是森林。我们需要维护这个森林的一些信息。</p>
<p>一般的操作有两点连通性，两点路径权值和等等。</p>
<h3 id="实链剖分">#1.2 实链剖分</h3>
<p>先来回顾一下树链剖分，我们可以按照子树大小进行剖分（重链剖分），也可以按照子树高度进行剖分（长链剖分），使得原本的一棵树被分为若干条链，然后可以在链上通过如线段树这样的数据结构维护信息。</p>
<p>那么，存不存在一种剖分方式能够使我们更加得心应手地处理动态树问题？显然剖出的可能会不停变换，于是我们希望我们剖出来的链能够是我们想要的，那么只要我们选择剖出我们想要的链不就行了？(～￣▽￣)～</p>
<p>看起来很随意是不是？但是这就是<strong>实链剖分</strong>：</p>
<ul>
<li>对于一个点连向儿子的所有边，我们自己选择一条作为<strong>实边</strong>，剩下的边作为<strong>虚边</strong>。</li>
<li>实边连向的儿子是<strong>实儿子</strong>，剩下的是<strong>虚儿子</strong>。</li>
<li>一条由实边组成的链，我们称之为<strong>实链</strong>。</li>
</ul>
<p>显然这种剖分方法是极为灵活的，灵活到一条实链上的点根本不是固定的 (lll￢ω￢)，那么驯服这种放荡不羁的树链，我们要任用一种更加灵活的数据结构进行管理——Splay（伸展树）。</p>
<div class="note info"><p>关于伸展树，可以参考笔者的博客 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Dfkuaid-210/p/splay.html">[数据结构]伸展树(Splay)</a>。</p>
</div>
<h3 id="辅助树">#1.3 辅助树</h3>
<p>先来捋清各种名称之间的关系：</p>
<ul>
<li>树上的每个节点与 Splay 上的节点一一对应 ；</li>
<li>一棵 Splay 维护一棵树上一条深度递增的链，Splay 上按照深度排序；</li>
<li>若干颗 Splay 组成一棵辅助树(AuxTree)，一棵辅助树代表一棵原树；</li>
<li>所有辅助树组成 LCT；</li>
</ul>
<p>一个很重要的点：辅助树上的所有 Splay <strong>并不是相互独立的</strong>。原本一棵 Splay 的根节点是不应该有父节点的，但是在辅助树上，一棵 Splay 的根节点的父节点就是这棵 Splay 维护的树链在原树上的父亲。但是，这种父亲链接的特点是：<strong>子认父而父不认子</strong>，换句话讲，这种父亲链接中的父亲所存储的左右儿子都不是这个链接中的儿子，也就是说辅助树可能并不是一棵二叉树，同时，我们也可以利用这个性质快速判断一个节点是否是所在 Splay 的根节点。</p>
<p>同时，Splay 可以在满足辅助树、Splay 的性质的前提下任意变换。意味着原树中的根在辅助树中不一定是根。</p>
<p>如图，这是一棵原树：</p>
<figure>
<img src="https://s2.loli.net/2022/01/26/X5EHxDOaGeopNb6.png" alt="lct_1.png" /><figcaption aria-hidden="true">lct_1.png</figcaption>
</figure>
<p>其中实线代表的是实边，虚线代表是虚边。</p>
<p>那么相应的辅助树<strong>可能</strong>如下（Splay 是可以变换的哦 OvO）：</p>
<figure>
<img src="https://s2.loli.net/2022/01/26/nGgDc96EoreVauZ.png" alt="lct_2.png" /><figcaption aria-hidden="true">lct_2.png</figcaption>
</figure>
<h2 id="主要函数">#2.0 主要函数</h2>
<h3 id="一些变量及其含义">一些变量及其含义</h3>
<p>直接把代码丢在这里吧 (￣▽￣)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>], fa; <span class="comment">//左右儿子及父亲</span></span><br><span class="line">    <span class="keyword">int</span> rev_tag, lzy_tag; <span class="comment">//翻转标记及信息懒标记</span></span><br><span class="line">    <span class="keyword">int</span> val, siz, var; <span class="comment">//单点信息，子树大小，维护信息</span></span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) p[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) p[x].ch[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) p[x].ch[1]</span></span><br></pre></td></tr></table></figure>
<p>具体用途下文再说 &lt;(ˉ^ˉ)&gt;</p>
<h3 id="一些基础操作">一些基础操作</h3>
<p>首先是 <code>pushup()</code> 和 <code>pushdown()</code>，没什么好说的，根据题目有所不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    p[k].siz = p[p[k].ch[<span class="number">0</span>]].siz + p[p[k].ch[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*Other things that need to be maintained.*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[k].rev_tag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[k].ch[<span class="number">0</span>]) <span class="built_in">reverse</span>(p[k].ch[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (p[k].ch[<span class="number">1</span>]) <span class="built_in">reverse</span>(p[k].ch[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">/*reverse() 是个什么函数请见下文*/</span></span><br><span class="line">        p[k].rev_tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Other things that need to be maintained.*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是 <code>get_type()</code> 和 <code>isroot()</code>，前者获取当前节点是父亲的哪一种儿子，后者则是判断当前节点是不是所在 Splay 的根。</p>
<p><code>get_type()</code> 是 Splay 的经典操作了，不多展开；<code>isroot()</code> 需要用到辅助树上 Splay 的性质：根节点的父亲不认这个儿子，所以只需要判断当前节点的父亲记录的儿子中是否包含当前节点即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_type</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x == p[p[x].fa].ch[<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x != <span class="built_in">ls</span>(<span class="built_in">f</span>(x)) &amp;&amp; x != <span class="built_in">rs</span>(<span class="built_in">f</span>(x));&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-与-splay">rotate() 与 splay()</h3>
<p><code>rotate()</code> 还是将当前节点在 Splay 中上移一层，不过与经典 Splay 中的略有不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">f</span>(x), z = <span class="built_in">f</span>(y), op = <span class="built_in">get_type</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y)) p[z].ch[<span class="built_in">get_type</span>(y)] = x; <span class="comment">//Here.</span></span><br><span class="line">    p[y].ch[op] = p[x].ch[!op], p[p[x].ch[!op]].fa = y;</span><br><span class="line">    p[x].ch[!op] = y, p[y].fa = x, p[x].fa = z;</span><br><span class="line">    <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们一定要先判断当前节点的父节点是不是根节点，然后在进行变换。至于为什么不用判断 <code>x</code> 是不是根节点，因为 <code>rotate()</code> 只会在 <code>splay()</code> 中被调用，然鹅 <code>splay()</code> 中限定了此节点不是根节点。</p>
<p>现在我们来看 <code>splay()</code>；注意到一点，我们可能需要下放许多标记，由于 Splay 本身极其灵活，我们一定要考虑将所有的标记下放之后再调整其结构，也就需要在 <code>splay()</code> 之前先调用一个 <code>update()</code> 函数进行标记的下放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (!<span class="built_in">isroot</span>(x)) <span class="built_in">update</span>(<span class="built_in">f</span>(x)); <span class="built_in">pushdown</span>(x);&#125;</span><br></pre></td></tr></table></figure>
<p><code>update()</code> 我们采用递归的形式实现，从要调整上去的节点开始，一层层向上深搜，直到到达根部，此时所有儿子可能发生变化的节点上的信息都已经下放完毕。然后我们就可以随心所欲的<del>调教</del>改变这棵 Splay 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fa; fa = <span class="built_in">f</span>(x), !<span class="built_in">isroot</span>(x); <span class="built_in">rotate</span>(x))</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">isroot</span>(fa)) <span class="built_in">rotate</span>(<span class="built_in">get_type</span>(fa) == <span class="built_in">get_type</span>(x) ? fa : x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info"><p>这里并不会展开讲解 <code>rotate()</code> 与 <code>splay()</code>，因为他们都是 Splay 的基础函数，详细解释见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Dfkuaid-210/p/splay.html">[数据结构]伸展树(Splay)</a>。</p>
</div>
<h3 id="access">Access()</h3>
<p>首先来了解一下 <code>Access()</code> 的本质：将一个点 <span class="math inline">\(x\)</span> 到原树上的根之间的路径中的所有边选择为实边，组成实链。</p>
<p>于是我们考虑从底部开始，一层一层向上构建。</p>
<p>当我们把当前处理到的点 <span class="math inline">\(x\)</span> <code>splay()</code> 到所在 Splay 的根后，显然此时在他右子树中的点深度都要比 <span class="math inline">\(x\)</span> 的深度大，一定不被包含在所要构建的 Splay 中，于是直接将其断掉；</p>
<p>再考虑他的父亲（在另一棵 Splay 中），我们就同样将他 <code>splay()</code> 到根部，考虑当前右子树中的点一定要么与 <span class="math inline">\(x\)</span> 深度相同，要么比 <span class="math inline">\(x\)</span> 的还要深，这些点一定都不能出现在 Splay 中，于是断掉，接上 <span class="math inline">\(x\)</span>，那么在左子树中的点呢？他们的深度一定更浅，且根据辅助树上 Splay 的要求，这些点一定是在从 <span class="math inline">\(x\)</span> 到根的路径上的，于是不用管。重复这个过程，直到根也被处理完。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; x; t = x, x = <span class="built_in">f</span>(x))</span><br><span class="line">      <span class="built_in">splay</span>(x), p[x].ch[<span class="number">1</span>] = t, <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> t; <span class="comment">//这里返回的是所在 Splay 的根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉这样讲应该很清楚了吧 QwQ，但还是做了图帮助理解 &lt;(￣ˇ￣)/</p>
<details class="note info no-icon"><summary><p>帮助理解的图示过程</p>
</summary>
<p>（经典老图重置版了属于是）现在我们有如下的一棵树，实线是实边，虚线是虚边。</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/M8gUIJrvZhHBNGe.png" alt="lct_access_1.png" /><figcaption aria-hidden="true">lct_access_1.png</figcaption>
</figure>
<p>现在我们想要 <code>Access(N)</code>，也就是想将其变为</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/afvt8rOdYsPhibB.png" alt="lct_access_2.png" /><figcaption aria-hidden="true">lct_access_2.png</figcaption>
</figure>
<p>他的辅助树的一种可能的形态为</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/gPSO2nG3BaZEeh1.png" alt="lct_access_3.png" /><figcaption aria-hidden="true">lct_access_3.png</figcaption>
</figure>
<p>（图中实线连接的点存在于同一棵 Splay 中，红色线表示相对上一步做出了更改）</p>
<p>按照上面的步骤进行变换</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/8sNGA5vWd2Ztg6b.png" alt="lct_access_4.png" /><figcaption aria-hidden="true">lct_access_4.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/27/QYBopbuUPdlsRqr.png" alt="lct_access_5.png" /><figcaption aria-hidden="true">lct_access_5.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/27/fdapNCiV7smOKqA.png" alt="lct_access_6.png" /><figcaption aria-hidden="true">lct_access_6.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/27/hMCzkTKXu1wIr5c.png" alt="lct_access_7.png" /><figcaption aria-hidden="true">lct_access_7.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/27/kKVIeyCHovint9s.png" alt="lct_access_8.png" /><figcaption aria-hidden="true">lct_access_8.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/27/s5NdrMOvtX4yzCh.png" alt="lct_access_9.png" /><figcaption aria-hidden="true">lct_access_9.png</figcaption>
</figure>

</details>
<h3 id="make_root-与-find_root">make_root() 与 find_root()</h3>
<p>在实际运用中，我们需要维护的路径很有可能不是一条深度递增的链，但是这种链是不被允许组成一颗 Splay，由于 LCT 极为灵活，此时，如果题目性质允许，我们可以尝试将一端转换为原树的根节点。</p>
<p>比如这里有一棵以 <span class="math inline">\(A\)</span> 为根的树：</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/Y16e4ulNWGkpnHV.png" alt="lct_mr_1.png" /><figcaption aria-hidden="true">lct_mr_1.png</figcaption>
</figure>
<p>现在我们要将他变为以 <span class="math inline">\(I\)</span> 为根（红色边为父子关系变化的边）：</p>
<figure>
<img src="https://s2.loli.net/2022/01/27/rsHXCdt3h8eTkNj.png" alt="lct_mr_2.png" /><figcaption aria-hidden="true">lct_mr_2.png</figcaption>
</figure>
<p>通过图片容易看出，从我们要变为根的 <span class="math inline">\(x\)</span> 到原根的路径上的所有父子关系都应该反转，但是不在该路径上的点并没有受到影响，他的父亲该是谁还是谁。注意到，在原树上的一条链的父子关系反转就是其深度关系完全反转，于是在 <code>Access(x)</code> 之后，我们需要做的就是将 <span class="math inline">\(x\)</span> 所在的 Splay 上的每个节点的左右儿子全部交换，一下做完的时间复杂度是很难被保证的，于是我们采用打标记的方式进行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="built_in">swap</span>(p[x].ch[<span class="number">0</span>], p[x].ch[<span class="number">1</span>]); p[x].rev_tag ^= <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;x = <span class="built_in">Access</span>(x); <span class="built_in">reverse</span>(x);&#125;</span><br></pre></td></tr></table></figure>
<p>既然我们很多时候修改了原树的根，那么又该如何确定当前原树的根是谁呢？这对于我们判断两者是否在同一棵树上很重要。</p>
<p>同样还是利用 Splay 的性质，我们是按照深度进行的排序，于是在 <code>Access()</code> 之后，根一定是深度最浅的那个，于是我们直接不断进入左子树，找到最左端的节点即可。注意，我们一定要将所有的标记全部下传，少传一个标记可能整个 Splay 的结构就被粉碎了 QwQ。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">Access</span>(x), <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ls</span>(x)) x = <span class="built_in">ls</span>(x), <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="built_in">splay</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="linkcutsplit">link()、cut()、split()!</h3>
<p>叫了这么久的 Link-Cut Tree，终于讲到 <code>link()</code> 与 <code>Cut()</code> 操作了 OvO。</p>
<p><code>link()</code> 操作很简单，显然我们只需要在确保要连接的两者不在同一棵树中，然后将一者变为所在树的根（原树与 Splay 双重意义）然后直接相连就是了。</p>
<p><code>cut()</code> 的时候，我们同样先将其中一点 <span class="math inline">\(x\)</span> 变为所在树的根，然后进行一波判断。</p>
<ul>
<li><p>判断 <span class="math inline">\(y\)</span> 与 <span class="math inline">\(x\)</span> 是否在同一棵树中；</p></li>
<li><p>判断 <span class="math inline">\(y\)</span> 是否是 <span class="math inline">\(x\)</span> 的直接儿子；</p>
<ol type="1">
<li>要求 <span class="math inline">\(y\)</span> 的父亲是 <span class="math inline">\(x\)</span>，这是一个必要不充分条件；</li>
<li>由于父亲存的是辅助树上的父亲，<span class="math inline">\(y\)</span> 可能是所在 Splay 的根，但是还有比他深度浅的节点（<span class="math inline">\(y\)</span> 的左儿子），由于 Splay 维护的是从上到下的一条链，于是如果 <span class="math inline">\(y\)</span> 有左儿子，那么一定意味着 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 之间还有其他的点。</li>
</ol></li>
</ul>
<p>都满足后，此时 <span class="math inline">\(y\)</span> 一定是 <span class="math inline">\(x\)</span> 的左儿子，于是我们就可以直接断开。</p>
<p><code>split()</code> 实际就是单独分出原树上 <span class="math inline">\(x\to y\)</span> 的路径，我们只需要将一者变为根，然后 <code>Access()</code> 另一者即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="built_in">make_root</span>(x); <span class="keyword">if</span> (<span class="built_in">find_root</span>(y) != x) <span class="built_in">splay</span>(x), p[x].fa = y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="built_in">make_root</span>(x); <span class="built_in">Access</span>(y); <span class="built_in">splay</span>(y);&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">make_root</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_root</span>(y) == x &amp;&amp; <span class="built_in">f</span>(y) == x &amp;&amp; !<span class="built_in">ls</span>(y))</span><br><span class="line">      p[y].fa = p[x].ch[<span class="number">1</span>] = <span class="number">0</span>, <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题">#3.0 例题</h2>
<h3 id="luogu3690-模板动态树link-cut-tree">#3.1 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3690">Luogu3690 【模板】动态树（Link Cut Tree）</a></h3>
<p>是真的模板呢 ( 0 - 0 )。</p>
<details class="note info no-icon"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> val, sum, rev_tag, ch[<span class="number">2</span>], fa;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) p[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) p[x].ch[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) p[x].ch[1]</span></span><br><span class="line"></span><br><span class="line">    Node p[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">LCT</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">get_type</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x == p[<span class="built_in">f</span>(x)].ch[<span class="number">1</span>];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ls</span>(<span class="built_in">f</span>(x)) != x &amp;&amp; <span class="built_in">rs</span>(<span class="built_in">f</span>(x)) != x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;p[k].sum = p[k].val ^ p[<span class="built_in">ls</span>(k)].sum ^ p[<span class="built_in">rs</span>(k)].sum;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="built_in">swap</span>(p[x].ch[<span class="number">0</span>], p[x].ch[<span class="number">1</span>]); p[x].rev_tag ^= <span class="number">1</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x].rev_tag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ls</span>(x)) <span class="built_in">reverse</span>(<span class="built_in">ls</span>(x));</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">rs</span>(x)) <span class="built_in">reverse</span>(<span class="built_in">rs</span>(x));</span><br><span class="line">            p[x].rev_tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (!<span class="built_in">isroot</span>(x)) <span class="built_in">update</span>(<span class="built_in">f</span>(x)); <span class="built_in">pushdown</span>(x);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">f</span>(x), z = <span class="built_in">f</span>(y), op = <span class="built_in">get_type</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y)) p[z].ch[<span class="built_in">get_type</span>(y)] = x;</span><br><span class="line">        p[y].ch[op] = p[x].ch[!op], p[p[x].ch[!op]].fa = y;</span><br><span class="line">        p[x].ch[!op] = y, p[y].fa = x, p[x].fa = z;</span><br><span class="line">        <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fa; fa = <span class="built_in">f</span>(x), !<span class="built_in">isroot</span>(x); <span class="built_in">rotate</span>(x))</span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">isroot</span>(fa)) <span class="built_in">rotate</span>(<span class="built_in">get_type</span>(fa) == <span class="built_in">get_type</span>(x) ? fa : x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (t = <span class="number">0</span>; x; t = x, x = <span class="built_in">f</span>(x))</span><br><span class="line">          <span class="built_in">splay</span>(x), p[x].ch[<span class="number">1</span>] = t, <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">Access</span>(x), <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">ls</span>(x)) x = <span class="built_in">ls</span>(x), <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="built_in">splay</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;x = <span class="built_in">Access</span>(x); <span class="built_in">reverse</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="built_in">make_root</span>(x); <span class="keyword">if</span> (<span class="built_in">find_root</span>(y) != x) <span class="built_in">splay</span>(x), p[x].fa = y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="built_in">make_root</span>(x); <span class="built_in">Access</span>(y); <span class="built_in">splay</span>(y);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">make_root</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find_root</span>(y) == x &amp;&amp; <span class="built_in">f</span>(y) == x &amp;&amp; !<span class="built_in">ls</span>(y))</span><br><span class="line">          p[y].fa = p[x].ch[<span class="number">1</span>] = <span class="number">0</span>, <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; lct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(lct.p[i].val);</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">read</span>(op), <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) lct.<span class="built_in">split</span>(x, y), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lct.p[y].sum);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) lct.<span class="built_in">link</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) lct.<span class="built_in">cut</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> lct.<span class="built_in">splay</span>(x), lct.p[x].val = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>
<h3 id="hnoi2010弹飞绵羊">#3.2 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3203">「HNOI2010」弹飞绵羊</a></h3>
<p>我们将 <span class="math inline">\(i+k_i\)</span> 作为 <span class="math inline">\(i\)</span> 的父亲节点，显然每个点最多只有一个出边，并且至少有一个点没有出边，显然这会构成一个森林，每次修改弹簧劲度时，实际就是断边然后重连，于是显然可以 LCT.</p>
<p>注意到，我们每次询问时要查询的东西就是从 <span class="math inline">\(x\)</span> 到所在树的根构成的链上一共有多少个节点，于是我们的树根是不方便改变的，于是就没有办法使用 <code>make_root()</code>，对于 <code>link()</code> 的影响不大，因为连接时一定是刚断开这个位置的边，如果我们不能改变原树的根，那么此时这个点一定是所在树的根，于是只需要把他拉到所在 Splay 的根部即可。同时，由于 <code>cut()</code> 的操作完全由我们操作，任一时刻一定是合法的，于是便不需要使用 <code>make_root()</code> 来辅助判断合法性。假如我们要断开 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 之间的边，我们只需要先 <code>Access(x)</code>，由于 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(x\)</span> 的父亲，于是这样 <span class="math inline">\(y\)</span> 与 <span class="math inline">\(x\)</span> 一定在同一棵 Splay 上，然后 <code>splay(y)</code>，由于在原树中 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(x\)</span> 的直接父亲，此时 <span class="math inline">\(x\)</span> 一定是 <span class="math inline">\(y\)</span> 的右儿子，直接断开即可。</p>
<p>查询时直接 <code>Access()</code> 然后返回所在 Splay 上的节点数即可。</p>
<p>剩下的都是 LCT 的板子了，这道题我们充分运用了 LCT 的灵活性。</p>
<details class="note info no-icon"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = -f;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> siz, ch[<span class="number">2</span>], fa;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) p[x].ch[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) p[x].ch[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) p[x].fa</span></span><br><span class="line"></span><br><span class="line">    Node p[N]; <span class="keyword">int</span> siz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">LCT</span><span class="params">()</span> </span>&#123;siz = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _siz)</span> </span>&#123;siz = _siz; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= siz; ++ i) p[i].siz = <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;p[k].siz = p[<span class="built_in">ls</span>(k)].siz + p[<span class="built_in">rs</span>(k)].siz + <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_type</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">rs</span>(<span class="built_in">f</span>(k)) == k;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ls</span>(<span class="built_in">f</span>(k)) != k &amp;&amp; <span class="built_in">rs</span>(<span class="built_in">f</span>(k)) != k;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">f</span>(x), z = <span class="built_in">f</span>(y), op = <span class="built_in">get_type</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y)) p[z].ch[<span class="built_in">get_type</span>(y)] = x;</span><br><span class="line">        p[y].ch[op] = p[x].ch[!op], p[p[x].ch[!op]].fa = y;</span><br><span class="line">        p[x].ch[!op] = y, p[y].fa = x, p[x].fa = z;</span><br><span class="line">        <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fa; fa = <span class="built_in">f</span>(x), !<span class="built_in">isroot</span>(x); <span class="built_in">rotate</span>(x))</span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">isroot</span>(fa)) <span class="built_in">rotate</span>(<span class="built_in">get_type</span>(fa) == <span class="built_in">get_type</span>(x) ? fa : x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (t = <span class="number">0</span>; x; t = x, x = <span class="built_in">f</span>(x))</span><br><span class="line">          <span class="built_in">splay</span>(x), p[x].ch[<span class="number">1</span>] = t, <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="built_in">splay</span>(x), p[x].fa = y;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Access</span>(x); <span class="built_in">splay</span>(y); p[y].ch[<span class="number">1</span>] = p[x].fa = <span class="number">0</span>; <span class="built_in">pushup</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="built_in">Access</span>(x); <span class="built_in">splay</span>(x); <span class="keyword">return</span> p[x].siz;&#125;</span><br><span class="line">&#125; lct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, to[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + to[x] &lt;= n) lct.<span class="built_in">cut</span>(x, x + to[x]);</span><br><span class="line">    <span class="keyword">if</span> (x + y &lt;= n) lct.<span class="built_in">link</span>(x, x + (to[x] = y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); lct.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(to[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (i + to[i] &lt;= n) lct.<span class="built_in">link</span>(i, i + to[i]);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="built_in">read</span>(op), <span class="built_in">read</span>(x); ++ x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lct.<span class="built_in">query</span>(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">read</span>(y), <span class="built_in">modify</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>
<h2 id="时间复杂度分析">#4.0 时间复杂度分析</h2>
<p>对于 LCT 的时间复杂度分析我们采用<strong>势能法</strong>，详情见笔者博客<a href="https://dfkuaid.github.io/2022/02/07/potential-method/#lctlink-cut-tree的时间复杂度分析">势能分析法 - #2.4 LCT 的时间复杂度分析</a>.</p>
<div id="refer">

</div>
<h2 id="参考文章">参考文章</h2>
<ul>
<li>[1] <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/lct/">Link Cur Tree - OI Wiki</a></li>
<li>[2] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/flashhu/p/8324551.html">LCT总结——概念篇+洛谷P3690[模板]Link Cut Tree(动态树)（LCT，Splay）- FlashHu</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c++</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/Splay/" rel="tag"># Splay</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/01/22/LiChao-Tree/" rel="prev" title="「数据结构」李超线段树">
                  <i class="fa fa-chevron-left"></i> 「数据结构」李超线段树
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/07/potential-method/" rel="next" title="势能分析法">
                  势能分析法 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dfkuaid</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"Dfkuaid","repo":"commit_for_blogs","client_id":"a60e970d81232433980f","client_secret":"08e596627e7cbff9b465ca374e3201366cfbc4ab","admin_user":"Dfkuaid","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","pagerDirection":"first","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"34a4e3f3e30381c3595e59312dabe1d5"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
